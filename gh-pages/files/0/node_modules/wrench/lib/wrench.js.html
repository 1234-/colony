<h1>wrench</h1>
<pre><code class="lang-js"><span class="comment">/*  wrench.js
 *
 *  A collection of various utility functions I've found myself in need of
 *  for use with Node.js (http://nodejs.org/). This includes things like:
 *
 *  - Recursively deleting directories in Node.js (Sync, not Async)
 *  - Recursively copying directories in Node.js (Sync, not Async)
 *  - Recursively chmoding a directory structure from Node.js (Sync, not Async)
 *  - Other things that I'll add here as time goes on. Shhhh...
 *
 *  ~ Ryan McGrath (ryan [at] venodesigns.net)
 */</span>

<span class="keyword">var</span> fs = require(<span class="string">"fs"</span>),
    _path = require(<span class="string">"path"</span>);


<span class="comment">/*  wrench.readdirSyncRecursive("directory_path");
 *
 *  Recursively dives through directories and read the contents of all the
 *  children directories.
 */</span>
exports.readdirSyncRecursive = <span class="keyword">function</span>(baseDir) {
    baseDir = baseDir.replace(<span class="regexp">/\/$/</span>, <span class="string">''</span>);

    <span class="keyword">var</span> readdirSyncRecursive = <span class="keyword">function</span>(baseDir) {
        <span class="keyword">var</span> files = [],
            curFiles,
            nextDirs,
            isDir = <span class="keyword">function</span>(fname){
                <span class="keyword">return</span> fs.statSync( _path.join(baseDir, fname) ).isDirectory();
            },
            prependBaseDir = <span class="keyword">function</span>(fname){
                <span class="keyword">return</span> _path.join(baseDir, fname);
            };

        curFiles = fs.readdirSync(baseDir);
        nextDirs = curFiles.filter(isDir);
        curFiles = curFiles.map(prependBaseDir);

        files = files.concat( curFiles );

        <span class="keyword">while</span> (nextDirs.length) {
            files = files.concat( readdirSyncRecursive( _path.join(baseDir, nextDirs.shift()) ) );
        }

        <span class="keyword">return</span> files;
    };

    <span class="comment">// convert absolute paths to relative</span>
    <span class="keyword">var</span> fileList = readdirSyncRecursive(baseDir).map(<span class="keyword">function</span>(val){
        <span class="keyword">return</span> _path.relative(baseDir, val);
    });

    <span class="keyword">return</span> fileList;
};

<span class="comment">/*  wrench.readdirRecursive("directory_path", function(error, files) {});
 *
 *  Recursively dives through directories and read the contents of all the
 *  children directories.
 *
 *  Asynchronous, so returns results/error in callback.
 *  Callback receives the of files in currently recursed directory.
 *  When no more directories are left, callback is called with null for all arguments.
 *
 */</span>
exports.readdirRecursive = <span class="keyword">function</span>(baseDir, fn) {
    baseDir = baseDir.replace(<span class="regexp">/\/$/</span>, <span class="string">''</span>);

    <span class="keyword">var</span> waitCount = <span class="number">0</span>;

    <span class="function"><span class="keyword">function</span> <span class="title">readdirRecursive</span><span class="params">(curDir)</span> {</span>
        <span class="keyword">var</span> files = [],
            curFiles,
            nextDirs,
            prependcurDir = <span class="keyword">function</span>(fname){
                <span class="keyword">return</span> _path.join(curDir, fname);
            };

        waitCount++;
        fs.readdir(curDir, <span class="keyword">function</span>(e, curFiles) {
            waitCount--;

            curFiles = curFiles.map(prependcurDir);

            curFiles.forEach(<span class="keyword">function</span>(it) {
                waitCount++;

                fs.stat(it, <span class="keyword">function</span>(e, stat) {
                    waitCount--;

                    <span class="keyword">if</span> (e) {
                        fn(e);
                    } <span class="keyword">else</span> {
                        <span class="keyword">if</span> (stat.isDirectory()) {
                            readdirRecursive(it);
                        }
                    }

                    <span class="keyword">if</span> (waitCount == <span class="number">0</span>) {
                        fn(<span class="literal">null</span>, <span class="literal">null</span>);
                    }
                });
            });

            fn(<span class="literal">null</span>, curFiles.map(<span class="keyword">function</span>(val) {
                <span class="comment">// convert absolute paths to relative</span>
                <span class="keyword">return</span> _path.relative(baseDir, val);
            }));

            <span class="keyword">if</span> (waitCount == <span class="number">0</span>) {
                fn(<span class="literal">null</span>, <span class="literal">null</span>);
            }
        });
    };

    readdirRecursive(baseDir);
};



<span class="comment">/*  wrench.rmdirSyncRecursive("directory_path", forceDelete, failSilent);
 *
 *  Recursively dives through directories and obliterates everything about it. This is a
 *  Sync-function, which blocks things until it's done. No idea why anybody would want an
 *  Asynchronous version. :\
 */</span>
exports.rmdirSyncRecursive = <span class="keyword">function</span>(path, failSilent) {
    <span class="keyword">var</span> files;

    <span class="keyword">try</span> {
        files = fs.readdirSync(path);
    } <span class="keyword">catch</span> (err) {
        <span class="keyword">if</span>(failSilent) <span class="keyword">return</span>;
        <span class="keyword">throw</span> <span class="keyword">new</span> Error(err.message);
    }

    <span class="comment">/*  Loop through and delete everything in the sub-tree after checking it */</span>
    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.length; i++) {
        <span class="keyword">var</span> currFile = fs.lstatSync(path + <span class="string">"/"</span> + files[i]);

        <span class="keyword">if</span>(currFile.isDirectory()) <span class="comment">// Recursive function back to the beginning</span>
            exports.rmdirSyncRecursive(path + <span class="string">"/"</span> + files[i]);

        <span class="keyword">else</span> <span class="keyword">if</span>(currFile.isSymbolicLink()) <span class="comment">// Unlink symlinks</span>
            fs.unlinkSync(path + <span class="string">"/"</span> + files[i]);

        <span class="keyword">else</span> <span class="comment">// Assume it's a file - perhaps a try/catch belongs here?</span>
            fs.unlinkSync(path + <span class="string">"/"</span> + files[i]);
    }

    <span class="comment">/*  Now that we know everything in the sub-tree has been deleted, we can delete the main
        directory. Huzzah for the shopkeep. */</span>
    <span class="keyword">return</span> fs.rmdirSync(path);
};

<span class="comment">/*  wrench.copyDirSyncRecursive("directory_to_copy", "new_directory_location", opts);
 *
 *  Recursively dives through a directory and moves all its files to a new location. This is a
 *  Synchronous function, which blocks things until it's done. If you need/want to do this in
 *  an Asynchronous manner, look at wrench.copyDirRecursively() below.
 *
 *  Note: Directories should be passed to this function without a trailing slash.
 */</span>
exports.copyDirSyncRecursive = <span class="keyword">function</span>(sourceDir, newDirLocation, opts) {

    <span class="keyword">if</span> (!opts || !opts.preserve) {
        <span class="keyword">try</span> {
            <span class="keyword">if</span>(fs.statSync(newDirLocation).isDirectory()) exports.rmdirSyncRecursive(newDirLocation);
        } <span class="keyword">catch</span>(e) { }
    }

    <span class="comment">/*  Create the directory where all our junk is moving to; read the mode of the source directory and mirror it */</span>
    <span class="keyword">var</span> checkDir = fs.statSync(sourceDir);
    <span class="keyword">try</span> {
        fs.mkdirSync(newDirLocation, checkDir.mode);
    } <span class="keyword">catch</span> (e) {
        <span class="comment">//if the directory already exists, that's okay</span>
        <span class="keyword">if</span> (e.code !== <span class="string">'EEXIST'</span>) <span class="keyword">throw</span> e;
    }

    <span class="keyword">var</span> files = fs.readdirSync(sourceDir);

    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.length; i++) {
        <span class="keyword">var</span> currFile = fs.lstatSync(sourceDir + <span class="string">"/"</span> + files[i]);

        <span class="keyword">if</span>(currFile.isDirectory()) {
            <span class="comment">/*  recursion this thing right on back. */</span>
            exports.copyDirSyncRecursive(sourceDir + <span class="string">"/"</span> + files[i], newDirLocation + <span class="string">"/"</span> + files[i], opts);
        } <span class="keyword">else</span> <span class="keyword">if</span>(currFile.isSymbolicLink()) {
            <span class="keyword">var</span> symlinkFull = fs.readlinkSync(sourceDir + <span class="string">"/"</span> + files[i]);
            fs.symlinkSync(symlinkFull, newDirLocation + <span class="string">"/"</span> + files[i]);
        } <span class="keyword">else</span> {
            <span class="comment">/*  At this point, we've hit a file actually worth copying... so copy it on over. */</span>
            <span class="keyword">var</span> contents = fs.readFileSync(sourceDir + <span class="string">"/"</span> + files[i]);
            fs.writeFileSync(newDirLocation + <span class="string">"/"</span> + files[i], contents);
        }
    }
};

<span class="comment">/*  wrench.chmodSyncRecursive("directory", filemode);
 *
 *  Recursively dives through a directory and chmods everything to the desired mode. This is a
 *  Synchronous function, which blocks things until it's done.
 *
 *  Note: Directories should be passed to this function without a trailing slash.
 */</span>
exports.chmodSyncRecursive = <span class="keyword">function</span>(sourceDir, filemode) {
    <span class="keyword">var</span> files = fs.readdirSync(sourceDir);

    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.length; i++) {
        <span class="keyword">var</span> currFile = fs.lstatSync(sourceDir + <span class="string">"/"</span> + files[i]);

        <span class="keyword">if</span>(currFile.isDirectory()) {
            <span class="comment">/*  ...and recursion this thing right on back. */</span>
            exports.chmodSyncRecursive(sourceDir + <span class="string">"/"</span> + files[i], filemode);
        } <span class="keyword">else</span> {
            <span class="comment">/*  At this point, we've hit a file actually worth copying... so copy it on over. */</span>
            fs.chmod(sourceDir + <span class="string">"/"</span> + files[i], filemode);
        }
    }

    <span class="comment">/*  Finally, chmod the parent directory */</span>
    fs.chmod(sourceDir, filemode);
};


<span class="comment">/*  wrench.chownSyncRecursive("directory", uid, gid);
 *
 *  Recursively dives through a directory and chowns everything to the desired user and group. This is a
 *  Synchronous function, which blocks things until it's done.
 *
 *  Note: Directories should be passed to this function without a trailing slash.
 */</span>
exports.chownSyncRecursive = <span class="keyword">function</span>(sourceDir, uid, gid) {
    <span class="keyword">var</span> files = fs.readdirSync(sourceDir);

    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.length; i++) {
        <span class="keyword">var</span> currFile = fs.lstatSync(sourceDir + <span class="string">"/"</span> + files[i]);

        <span class="keyword">if</span>(currFile.isDirectory()) {
            <span class="comment">/*  ...and recursion this thing right on back. */</span>
            exports.chownSyncRecursive(sourceDir + <span class="string">"/"</span> + files[i], uid, gid);
        } <span class="keyword">else</span> {
            <span class="comment">/*  At this point, we've hit a file actually worth chowning... so own it. */</span>
            fs.chownSync(sourceDir + <span class="string">"/"</span> + files[i], uid, gid);
        }
    }

    <span class="comment">/*  Finally, chown the parent directory */</span>
    fs.chownSync(sourceDir, uid, gid);
};



<span class="comment">/*  wrench.rmdirRecursive("directory_path", callback);
 *
 *  Recursively dives through directories and obliterates everything about it.
 */</span>
exports.rmdirRecursive = <span class="function"><span class="keyword">function</span> <span class="title">rmdirRecursive</span><span class="params">(dir, clbk)</span>{</span>
    fs.readdir(dir, <span class="keyword">function</span>(err, files){
        <span class="keyword">if</span> (err) <span class="keyword">return</span> clbk(err);
        (<span class="function"><span class="keyword">function</span> <span class="title">rmFile</span><span class="params">(err)</span>{</span>
            <span class="keyword">if</span> (err) <span class="keyword">return</span> clbk(err);

            <span class="keyword">var</span> filename = files.shift();
            <span class="keyword">if</span> (filename === <span class="literal">null</span> || <span class="keyword">typeof</span> filename == <span class="string">'undefined'</span>)
                <span class="keyword">return</span> fs.rmdir(dir, clbk);

            <span class="keyword">var</span> file = dir+<span class="string">'/'</span>+filename;
            fs.stat(file, <span class="keyword">function</span>(err, stat){
                <span class="keyword">if</span> (err) <span class="keyword">return</span> clbk(err);
                <span class="keyword">if</span> (stat.isDirectory())
                    rmdirRecursive(file, rmFile);
                <span class="keyword">else</span>
                    fs.unlink(file, rmFile);
            });
        })();
    });
};

<span class="comment">/*  wrench.copyDirRecursive("directory_to_copy", "new_location", callback);
 *
 *  Recursively dives through a directory and moves all its files to a new
 *  location.
 *
 *  Note: Directories should be passed to this function without a trailing slash.
 */</span>
exports.copyDirRecursive = <span class="function"><span class="keyword">function</span> <span class="title">copyDirRecursive</span><span class="params">(srcDir, newDir, clbk)</span> {</span>
    fs.stat(newDir, <span class="keyword">function</span>(err, newDirStat){
        <span class="keyword">if</span> (!err) <span class="keyword">return</span> exports.rmdirRecursive(newDir, <span class="keyword">function</span>(err){
            copyDirRecursive(srcDir, newDir, clbk);
        });

        fs.stat(srcDir, <span class="keyword">function</span>(err, srcDirStat){
            <span class="keyword">if</span> (err) <span class="keyword">return</span> clbk(err);
            fs.mkdir(newDir, srcDirStat.mode, <span class="keyword">function</span>(err){
                <span class="keyword">if</span> (err) <span class="keyword">return</span> clbk(err);
                fs.readdir(srcDir, <span class="keyword">function</span>(err, files){
                    <span class="keyword">if</span> (err) <span class="keyword">return</span> clbk(err);
                    (<span class="function"><span class="keyword">function</span> <span class="title">copyFiles</span><span class="params">(err)</span>{</span>
                        <span class="keyword">if</span> (err) <span class="keyword">return</span> clbk(err);

                        <span class="keyword">var</span> filename = files.shift();
                        <span class="keyword">if</span> (filename === <span class="literal">null</span> || <span class="keyword">typeof</span> filename == <span class="string">'undefined'</span>)
                            <span class="keyword">return</span> clbk();

                        <span class="keyword">var</span> file = srcDir+<span class="string">'/'</span>+filename,
                            newFile = newDir+<span class="string">'/'</span>+filename;

                        fs.stat(file, <span class="keyword">function</span>(err, fileStat){
                            <span class="keyword">if</span> (fileStat.isDirectory())
                                copyDirRecursive(file, newFile, copyFiles);
                            <span class="keyword">else</span> <span class="keyword">if</span> (fileStat.isSymbolicLink())
                                fs.readlink(file, <span class="keyword">function</span>(err, link){
                                    fs.symlink(link, newFile, copyFiles);
                                });
                            <span class="keyword">else</span>
                                fs.readFile(file, <span class="keyword">function</span>(err, data){
                                    fs.writeFile(newFile, data, copyFiles);
                                });
                        });
                    })();
                });
            });
        });
    });
};

<span class="keyword">var</span> mkdirSyncRecursive = <span class="keyword">function</span>(path, mode) {
    <span class="keyword">var</span> self = <span class="keyword">this</span>;

    <span class="keyword">try</span> {
        fs.mkdirSync(path, mode);
    } <span class="keyword">catch</span>(err) {
        <span class="keyword">if</span>(err.code == <span class="string">"ENOENT"</span>) {
            <span class="keyword">var</span> slashIdx = path.lastIndexOf(<span class="string">"/"</span>);
            <span class="keyword">if</span>(slashIdx &lt; <span class="number">0</span>) {
                slashIdx = path.lastIndexOf(<span class="string">"\\"</span>);
            }

            <span class="keyword">if</span>(slashIdx > <span class="number">0</span>) {
                <span class="keyword">var</span> parentPath = path.substring(<span class="number">0</span>, slashIdx);
                mkdirSyncRecursive(parentPath, mode);
                mkdirSyncRecursive(path, mode);
            } <span class="keyword">else</span> {
                <span class="keyword">throw</span> err;
            }
        } <span class="keyword">else</span> <span class="keyword">if</span>(err.code == <span class="string">"EEXIST"</span>) {
            <span class="keyword">return</span>;
        } <span class="keyword">else</span> {
            <span class="keyword">throw</span> err;
        }
    }
};
exports.mkdirSyncRecursive = mkdirSyncRecursive;

exports.LineReader = <span class="keyword">function</span>(filename, bufferSize) {
    <span class="keyword">this</span>.bufferSize = bufferSize || <span class="number">8192</span>;
    <span class="keyword">this</span>.buffer = <span class="string">""</span>;
    <span class="keyword">this</span>.fd = fs.openSync(filename, <span class="string">"r"</span>);
    <span class="keyword">this</span>.currentPosition = <span class="number">0</span>;
};

exports.LineReader.prototype = {
    getBufferAndSetCurrentPosition: <span class="keyword">function</span>(position) {
        <span class="keyword">var</span> res = fs.readSync(<span class="keyword">this</span>.fd, <span class="keyword">this</span>.bufferSize, position, <span class="string">"ascii"</span>);

        <span class="keyword">this</span>.buffer += res[<span class="number">0</span>];
        <span class="keyword">if</span>(res[<span class="number">1</span>] === <span class="number">0</span>) {
            <span class="keyword">this</span>.currentPosition = -<span class="number">1</span>;
        } <span class="keyword">else</span> {
            <span class="keyword">this</span>.currentPosition = position + res[<span class="number">1</span>];
        }

        <span class="keyword">return</span> <span class="keyword">this</span>.currentPosition;
    },

    hasNextLine: <span class="keyword">function</span>() {
        <span class="keyword">while</span>(<span class="keyword">this</span>.buffer.indexOf(<span class="string">'\n'</span>) === -<span class="number">1</span>) {
            <span class="keyword">this</span>.getBufferAndSetCurrentPosition(<span class="keyword">this</span>.currentPosition);
            <span class="keyword">if</span>(<span class="keyword">this</span>.currentPosition === -<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;
        }

        <span class="keyword">if</span>(<span class="keyword">this</span>.buffer.indexOf(<span class="string">"\n"</span>) > -<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;
        <span class="keyword">return</span> <span class="literal">false</span>;
    },

    getNextLine: <span class="keyword">function</span>() {
        <span class="keyword">var</span> lineEnd = <span class="keyword">this</span>.buffer.indexOf(<span class="string">"\n"</span>),
            result = <span class="keyword">this</span>.buffer.substring(<span class="number">0</span>, lineEnd);

        <span class="keyword">this</span>.buffer = <span class="keyword">this</span>.buffer.substring(result.length + <span class="number">1</span>, <span class="keyword">this</span>.buffer.length);
        <span class="keyword">return</span> result;
    }
};

<span class="comment">// vim: et ts=4 sw=4</span>
</code></pre>