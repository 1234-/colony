<h1>highlight.js</h1>
<pre><code class="lang-js"><span class="keyword">var</span> hljs = <span class="keyword">new</span> <span class="keyword">function</span>() {

  <span class="comment">/* Utility functions */</span>

  <span class="function"><span class="keyword">function</span> <span class="title">escape</span><span class="params">(value)</span> {</span>
    <span class="keyword">return</span> value.replace(<span class="regexp">/&amp;/gm</span>, <span class="string">'&amp;amp;'</span>).replace(<span class="regexp">/&lt;/gm</span>, <span class="string">'&amp;lt;'</span>);
  }

  <span class="function"><span class="keyword">function</span> <span class="title">findCode</span><span class="params">(pre)</span> {</span>
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; pre.childNodes.length; i++) {
      <span class="keyword">var</span> node = pre.childNodes[i];
      <span class="keyword">if</span> (node.nodeName == <span class="string">'CODE'</span>)
        <span class="keyword">return</span> node;
      <span class="keyword">if</span> (!(node.nodeType == <span class="number">3</span> &amp;&amp; node.nodeValue.match(<span class="regexp">/\s+/</span>)))
        <span class="keyword">break</span>;
    }
  }

  <span class="keyword">var</span> is_old_IE = (<span class="keyword">typeof</span> navigator !== <span class="string">'undefined'</span> &amp;&amp; <span class="regexp">/MSIE [678]/</span>.test(navigator.userAgent));

  <span class="function"><span class="keyword">function</span> <span class="title">blockText</span><span class="params">(block, ignoreNewLines)</span> {</span>
    <span class="keyword">var</span> result = <span class="string">''</span>;
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; block.childNodes.length; i++)
      <span class="keyword">if</span> (block.childNodes[i].nodeType == <span class="number">3</span>) {
        <span class="keyword">var</span> chunk = block.childNodes[i].nodeValue;
        <span class="keyword">if</span> (ignoreNewLines)
          chunk = chunk.replace(<span class="regexp">/\n/g</span>, <span class="string">''</span>);
        result += chunk;
      } <span class="keyword">else</span> <span class="keyword">if</span> (block.childNodes[i].nodeName == <span class="string">'BR'</span>)
        result += <span class="string">'\n'</span>;
      <span class="keyword">else</span>
        result += blockText(block.childNodes[i]);
    <span class="keyword">if</span> (is_old_IE)
      result = result.replace(<span class="regexp">/\r/g</span>, <span class="string">'\n'</span>);
    <span class="keyword">return</span> result;
  }

  <span class="function"><span class="keyword">function</span> <span class="title">blockLanguage</span><span class="params">(block)</span> {</span>
    <span class="keyword">var</span> classes = block.className.split(<span class="regexp">/\s+/</span>);
    classes = classes.concat(block.parentNode.className.split(<span class="regexp">/\s+/</span>));
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; classes.length; i++) {
      <span class="keyword">var</span> class_ = classes[i].replace(<span class="regexp">/^language-/</span>, <span class="string">''</span>);
      <span class="keyword">if</span> (languages[class_] || class_ == <span class="string">'no-highlight'</span>) {
        <span class="keyword">return</span> class_;
      }
    }
  }

  <span class="comment">/* Stream merging */</span>

  <span class="function"><span class="keyword">function</span> <span class="title">nodeStream</span><span class="params">(node)</span> {</span>
    <span class="keyword">var</span> result = [];
    (<span class="function"><span class="keyword">function</span> <span class="title">_nodeStream</span><span class="params">(node, offset)</span> {</span>
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; node.childNodes.length; i++) {
        <span class="keyword">if</span> (node.childNodes[i].nodeType == <span class="number">3</span>)
          offset += node.childNodes[i].nodeValue.length;
        <span class="keyword">else</span> <span class="keyword">if</span> (node.childNodes[i].nodeName == <span class="string">'BR'</span>)
          offset += <span class="number">1</span>;
        <span class="keyword">else</span> <span class="keyword">if</span> (node.childNodes[i].nodeType == <span class="number">1</span>) {
          result.push({
            event: <span class="string">'start'</span>,
            offset: offset,
            node: node.childNodes[i]
          });
          offset = _nodeStream(node.childNodes[i], offset);
          result.push({
            event: <span class="string">'stop'</span>,
            offset: offset,
            node: node.childNodes[i]
          });
        }
      }
      <span class="keyword">return</span> offset;
    })(node, <span class="number">0</span>);
    <span class="keyword">return</span> result;
  }

  <span class="function"><span class="keyword">function</span> <span class="title">mergeStreams</span><span class="params">(stream1, stream2, value)</span> {</span>
    <span class="keyword">var</span> processed = <span class="number">0</span>;
    <span class="keyword">var</span> result = <span class="string">''</span>;
    <span class="keyword">var</span> nodeStack = [];

    <span class="function"><span class="keyword">function</span> <span class="title">selectStream</span><span class="params">()</span> {</span>
      <span class="keyword">if</span> (stream1.length &amp;&amp; stream2.length) {
        <span class="keyword">if</span> (stream1[<span class="number">0</span>].offset != stream2[<span class="number">0</span>].offset)
          <span class="keyword">return</span> (stream1[<span class="number">0</span>].offset &lt; stream2[<span class="number">0</span>].offset) ? stream1 : stream2;
        <span class="keyword">else</span> {
          <span class="comment">/*
          To avoid starting the stream just before it should stop the order is
          ensured that stream1 always starts first and closes last:

          if (event1 == 'start' &amp;&amp; event2 == 'start')
            return stream1;
          if (event1 == 'start' &amp;&amp; event2 == 'stop')
            return stream2;
          if (event1 == 'stop' &amp;&amp; event2 == 'start')
            return stream1;
          if (event1 == 'stop' &amp;&amp; event2 == 'stop')
            return stream2;

          ... which is collapsed to:
          */</span>
          <span class="keyword">return</span> stream2[<span class="number">0</span>].event == <span class="string">'start'</span> ? stream1 : stream2;
        }
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> stream1.length ? stream1 : stream2;
      }
    }

    <span class="function"><span class="keyword">function</span> <span class="title">open</span><span class="params">(node)</span> {</span>
      <span class="keyword">var</span> result = <span class="string">'&lt;'</span> + node.nodeName.toLowerCase();
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; node.attributes.length; i++) {
        <span class="keyword">var</span> attribute = node.attributes[i];
        result += <span class="string">' '</span> + attribute.nodeName.toLowerCase();
        <span class="keyword">if</span> (attribute.value !== <span class="literal">undefined</span> &amp;&amp; attribute.value !== <span class="literal">false</span> &amp;&amp; attribute.value !== <span class="literal">null</span>) {
          result += <span class="string">'="'</span> + escape(attribute.value) + <span class="string">'"'</span>;
        }
      }
      <span class="keyword">return</span> result + <span class="string">'>'</span>;
    }

    <span class="keyword">while</span> (stream1.length || stream2.length) {
      <span class="keyword">var</span> current = selectStream().splice(<span class="number">0</span>, <span class="number">1</span>)[<span class="number">0</span>];
      result += escape(value.substr(processed, current.offset - processed));
      processed = current.offset;
      <span class="keyword">if</span> ( current.event == <span class="string">'start'</span>) {
        result += open(current.node);
        nodeStack.push(current.node);
      } <span class="keyword">else</span> <span class="keyword">if</span> (current.event == <span class="string">'stop'</span>) {
        <span class="keyword">var</span> node, i = nodeStack.length;
        <span class="keyword">do</span> {
          i--;
          node = nodeStack[i];
          result += (<span class="string">'&lt;/'</span> + node.nodeName.toLowerCase() + <span class="string">'>'</span>);
        } <span class="keyword">while</span> (node != current.node);
        nodeStack.splice(i, <span class="number">1</span>);
        <span class="keyword">while</span> (i &lt; nodeStack.length) {
          result += open(nodeStack[i]);
          i++;
        }
      }
    }
    <span class="keyword">return</span> result + escape(value.substr(processed));
  }

  <span class="comment">/* Initialization */</span>

  <span class="function"><span class="keyword">function</span> <span class="title">compileLanguage</span><span class="params">(language)</span> {</span>

    <span class="function"><span class="keyword">function</span> <span class="title">langRe</span><span class="params">(value, global)</span> {</span>
      <span class="keyword">return</span> RegExp(
        value,
        <span class="string">'m'</span> + (language.case_insensitive ? <span class="string">'i'</span> : <span class="string">''</span>) + (global ? <span class="string">'g'</span> : <span class="string">''</span>)
      );
    }

    <span class="function"><span class="keyword">function</span> <span class="title">compileMode</span><span class="params">(mode, parent)</span> {</span>
      <span class="keyword">if</span> (mode.compiled)
        <span class="keyword">return</span>;
      mode.compiled = <span class="literal">true</span>;

      <span class="keyword">var</span> keywords = []; <span class="comment">// used later with beginWithKeyword but filled as a side-effect of keywords compilation</span>
      <span class="keyword">if</span> (mode.keywords) {
        <span class="keyword">var</span> compiled_keywords = {};

        <span class="function"><span class="keyword">function</span> <span class="title">flatten</span><span class="params">(className, str)</span> {</span>
          <span class="keyword">var</span> group = str.split(<span class="string">' '</span>);
          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; group.length; i++) {
            <span class="keyword">var</span> pair = group[i].split(<span class="string">'|'</span>);
            compiled_keywords[pair[<span class="number">0</span>]] = [className, pair[<span class="number">1</span>] ? Number(pair[<span class="number">1</span>]) : <span class="number">1</span>];
            keywords.push(pair[<span class="number">0</span>]);
          }
        }

        mode.lexemsRe = langRe(mode.lexems || hljs.IDENT_RE, <span class="literal">true</span>);
        <span class="keyword">if</span> (<span class="keyword">typeof</span> mode.keywords == <span class="string">'string'</span>) { <span class="comment">// string</span>
          flatten(<span class="string">'keyword'</span>, mode.keywords)
        } <span class="keyword">else</span> {
          <span class="keyword">for</span> (<span class="keyword">var</span> className <span class="keyword">in</span> mode.keywords) {
            <span class="keyword">if</span> (!mode.keywords.hasOwnProperty(className))
              <span class="keyword">continue</span>;
            flatten(className, mode.keywords[className]);
          }
        }
        mode.keywords = compiled_keywords;
      }
      <span class="keyword">if</span> (parent) {
        <span class="keyword">if</span> (mode.beginWithKeyword) {
          mode.begin = <span class="string">'\\b('</span> + keywords.join(<span class="string">'|'</span>) + <span class="string">')\\s'</span>;
        }
        mode.beginRe = langRe(mode.begin ? mode.begin : <span class="string">'\\B|\\b'</span>);
        <span class="keyword">if</span> (!mode.end &amp;&amp; !mode.endsWithParent)
          mode.end = <span class="string">'\\B|\\b'</span>;
        <span class="keyword">if</span> (mode.end)
          mode.endRe = langRe(mode.end);
        mode.terminator_end = mode.end || <span class="string">''</span>;
        <span class="keyword">if</span> (mode.endsWithParent &amp;&amp; parent.terminator_end)
          mode.terminator_end += (mode.end ? <span class="string">'|'</span> : <span class="string">''</span>) + parent.terminator_end;
      }
      <span class="keyword">if</span> (mode.illegal)
        mode.illegalRe = langRe(mode.illegal);
      <span class="keyword">if</span> (mode.relevance === <span class="literal">undefined</span>)
        mode.relevance = <span class="number">1</span>;
      <span class="keyword">if</span> (!mode.contains) {
        mode.contains = [];
      }
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; mode.contains.length; i++) {
        <span class="keyword">if</span> (mode.contains[i] == <span class="string">'self'</span>) {
          mode.contains[i] = mode;
        }
        compileMode(mode.contains[i], mode);
      }
      <span class="keyword">if</span> (mode.starts) {
        compileMode(mode.starts, parent);
      }

      <span class="keyword">var</span> terminators = [];
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; mode.contains.length; i++) {
        terminators.push(mode.contains[i].begin);
      }
      <span class="keyword">if</span> (mode.terminator_end) {
        terminators.push(mode.terminator_end);
      }
      <span class="keyword">if</span> (mode.illegal) {
        terminators.push(mode.illegal);
      }
      mode.terminators = terminators.length ? langRe(terminators.join(<span class="string">'|'</span>), <span class="literal">true</span>) : <span class="literal">null</span>;
    }

    compileMode(language);
  }

  <span class="comment">/*
  Core highlighting function. Accepts a language name and a string with the
  code to highlight. Returns an object with the following properties:

  - relevance (int)
  - keyword_count (int)
  - value (an HTML string with highlighting markup)

  */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">highlight</span><span class="params">(language_name, value)</span> {</span>

    <span class="function"><span class="keyword">function</span> <span class="title">subMode</span><span class="params">(lexem, mode)</span> {</span>
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; mode.contains.length; i++) {
        <span class="keyword">var</span> match = mode.contains[i].beginRe.exec(lexem);
        <span class="keyword">if</span> (match &amp;&amp; match.index == <span class="number">0</span>) {
          <span class="keyword">return</span> mode.contains[i];
        }
      }
    }

    <span class="function"><span class="keyword">function</span> <span class="title">endOfMode</span><span class="params">(mode_index, lexem)</span> {</span>
      <span class="keyword">if</span> (modes[mode_index].end &amp;&amp; modes[mode_index].endRe.test(lexem))
        <span class="keyword">return</span> <span class="number">1</span>;
      <span class="keyword">if</span> (modes[mode_index].endsWithParent) {
        <span class="keyword">var</span> level = endOfMode(mode_index - <span class="number">1</span>, lexem);
        <span class="keyword">return</span> level ? level + <span class="number">1</span> : <span class="number">0</span>;
      }
      <span class="keyword">return</span> <span class="number">0</span>;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">isIllegal</span><span class="params">(lexem, mode)</span> {</span>
      <span class="keyword">return</span> mode.illegal &amp;&amp; mode.illegalRe.test(lexem);
    }

    <span class="function"><span class="keyword">function</span> <span class="title">eatModeChunk</span><span class="params">(value, index)</span> {</span>
      <span class="keyword">var</span> mode = modes[modes.length - <span class="number">1</span>];
      <span class="keyword">if</span> (mode.terminators) {
        mode.terminators.lastIndex = index;
        <span class="keyword">return</span> mode.terminators.exec(value);
      }
    }

    <span class="function"><span class="keyword">function</span> <span class="title">keywordMatch</span><span class="params">(mode, match)</span> {</span>
      <span class="keyword">var</span> match_str = language.case_insensitive ? match[<span class="number">0</span>].toLowerCase() : match[<span class="number">0</span>];
      <span class="keyword">var</span> value = mode.keywords[match_str];
      <span class="keyword">if</span> (value &amp;&amp; value <span class="keyword">instanceof</span> Array)
          <span class="keyword">return</span> value;
      <span class="keyword">return</span> <span class="literal">false</span>;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">processKeywords</span><span class="params">(buffer, mode)</span> {</span>
      buffer = escape(buffer);
      <span class="keyword">if</span> (!mode.keywords)
        <span class="keyword">return</span> buffer;
      <span class="keyword">var</span> result = <span class="string">''</span>;
      <span class="keyword">var</span> last_index = <span class="number">0</span>;
      mode.lexemsRe.lastIndex = <span class="number">0</span>;
      <span class="keyword">var</span> match = mode.lexemsRe.exec(buffer);
      <span class="keyword">while</span> (match) {
        result += buffer.substr(last_index, match.index - last_index);
        <span class="keyword">var</span> keyword_match = keywordMatch(mode, match);
        <span class="keyword">if</span> (keyword_match) {
          keyword_count += keyword_match[<span class="number">1</span>];
          result += <span class="string">'&lt;span class="'</span>+ keyword_match[<span class="number">0</span>] +<span class="string">'">'</span> + match[<span class="number">0</span>] + <span class="string">'&lt;/span>'</span>;
        } <span class="keyword">else</span> {
          result += match[<span class="number">0</span>];
        }
        last_index = mode.lexemsRe.lastIndex;
        match = mode.lexemsRe.exec(buffer);
      }
      <span class="keyword">return</span> result + buffer.substr(last_index);
    }

    <span class="function"><span class="keyword">function</span> <span class="title">processSubLanguage</span><span class="params">(buffer, mode)</span> {</span>
      <span class="keyword">var</span> result;
      <span class="keyword">if</span> (mode.subLanguage == <span class="string">''</span>) {
        result = highlightAuto(buffer);
      } <span class="keyword">else</span> {
        result = highlight(mode.subLanguage, buffer);
      }
      <span class="comment">// Counting embedded language score towards the host language may be disabled</span>
      <span class="comment">// with zeroing the containing mode relevance. Usecase in point is Markdown that</span>
      <span class="comment">// allows XML everywhere and makes every XML snippet to have a much larger Markdown</span>
      <span class="comment">// score.</span>
      <span class="keyword">if</span> (mode.relevance > <span class="number">0</span>) {
        keyword_count += result.keyword_count;
        relevance += result.relevance;
      }
      <span class="keyword">return</span> <span class="string">'&lt;span class="'</span> + result.language  + <span class="string">'">'</span> + result.value + <span class="string">'&lt;/span>'</span>;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">processBuffer</span><span class="params">(buffer, mode)</span> {</span>
      <span class="keyword">if</span> (mode.subLanguage &amp;&amp; languages[mode.subLanguage] || mode.subLanguage == <span class="string">''</span>) {
        <span class="keyword">return</span> processSubLanguage(buffer, mode);
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> processKeywords(buffer, mode);
      }
    }

    <span class="function"><span class="keyword">function</span> <span class="title">startNewMode</span><span class="params">(mode, lexem)</span> {</span>
      <span class="keyword">var</span> markup = mode.className? <span class="string">'&lt;span class="'</span> + mode.className + <span class="string">'">'</span>: <span class="string">''</span>;
      <span class="keyword">if</span> (mode.returnBegin) {
        result += markup;
        mode.buffer = <span class="string">''</span>;
      } <span class="keyword">else</span> <span class="keyword">if</span> (mode.excludeBegin) {
        result += escape(lexem) + markup;
        mode.buffer = <span class="string">''</span>;
      } <span class="keyword">else</span> {
        result += markup;
        mode.buffer = lexem;
      }
      modes.push(mode);
      relevance += mode.relevance;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">processModeInfo</span><span class="params">(buffer, lexem)</span> {</span>
      <span class="keyword">var</span> current_mode = modes[modes.length - <span class="number">1</span>];
      <span class="keyword">if</span> (lexem === <span class="literal">undefined</span>) {
        result += processBuffer(current_mode.buffer + buffer, current_mode);
        <span class="keyword">return</span>;
      }

      <span class="keyword">var</span> new_mode = subMode(lexem, current_mode);
      <span class="keyword">if</span> (new_mode) {
        result += processBuffer(current_mode.buffer + buffer, current_mode);
        startNewMode(new_mode, lexem);
        <span class="keyword">return</span> new_mode.returnBegin;
      }

      <span class="keyword">var</span> end_level = endOfMode(modes.length - <span class="number">1</span>, lexem);
      <span class="keyword">if</span> (end_level) {
        <span class="keyword">var</span> markup = current_mode.className?<span class="string">'&lt;/span>'</span>:<span class="string">''</span>;
        <span class="keyword">if</span> (current_mode.returnEnd) {
          result += processBuffer(current_mode.buffer + buffer, current_mode) + markup;
        } <span class="keyword">else</span> <span class="keyword">if</span> (current_mode.excludeEnd) {
          result += processBuffer(current_mode.buffer + buffer, current_mode) + markup + escape(lexem);
        } <span class="keyword">else</span> {
          result += processBuffer(current_mode.buffer + buffer + lexem, current_mode) + markup;
        }
        <span class="keyword">while</span> (end_level > <span class="number">1</span>) {
          markup = modes[modes.length - <span class="number">2</span>].className?<span class="string">'&lt;/span>'</span>:<span class="string">''</span>;
          result += markup;
          end_level--;
          modes.length--;
        }
        <span class="keyword">var</span> last_ended_mode = modes[modes.length - <span class="number">1</span>];
        modes.length--;
        modes[modes.length - <span class="number">1</span>].buffer = <span class="string">''</span>;
        <span class="keyword">if</span> (last_ended_mode.starts) {
          startNewMode(last_ended_mode.starts, <span class="string">''</span>);
        }
        <span class="keyword">return</span> current_mode.returnEnd;
      }

      <span class="keyword">if</span> (isIllegal(lexem, current_mode))
        <span class="keyword">throw</span> <span class="string">'Illegal'</span>;
    }

    <span class="keyword">var</span> language = languages[language_name];
    compileLanguage(language);
    <span class="keyword">var</span> modes = [language];
    language.buffer = <span class="string">''</span>;
    <span class="keyword">var</span> relevance = <span class="number">0</span>;
    <span class="keyword">var</span> keyword_count = <span class="number">0</span>;
    <span class="keyword">var</span> result = <span class="string">''</span>;
    <span class="keyword">try</span> {
      <span class="keyword">var</span> match, index = <span class="number">0</span>;
      <span class="keyword">while</span> (<span class="literal">true</span>) {
        match = eatModeChunk(value, index);
        <span class="keyword">if</span> (!match)
          <span class="keyword">break</span>;
        <span class="keyword">var</span> return_lexem = processModeInfo(value.substr(index, match.index - index), match[<span class="number">0</span>]);
        index = match.index + (return_lexem ? <span class="number">0</span> : match[<span class="number">0</span>].length);
      }
      processModeInfo(value.substr(index), <span class="literal">undefined</span>);
      <span class="keyword">return</span> {
        relevance: relevance,
        keyword_count: keyword_count,
        value: result,
        language: language_name
      };
    } <span class="keyword">catch</span> (e) {
      <span class="keyword">if</span> (e == <span class="string">'Illegal'</span>) {
        <span class="keyword">return</span> {
          relevance: <span class="number">0</span>,
          keyword_count: <span class="number">0</span>,
          value: escape(value)
        };
      } <span class="keyword">else</span> {
        <span class="keyword">throw</span> e;
      }
    }
  }

  <span class="comment">/*
  Highlighting with language detection. Accepts a string with the code to
  highlight. Returns an object with the following properties:

  - language (detected language)
  - relevance (int)
  - keyword_count (int)
  - value (an HTML string with highlighting markup)
  - second_best (object with the same structure for second-best heuristically
    detected language, may be absent)

  */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">highlightAuto</span><span class="params">(text)</span> {</span>
    <span class="keyword">var</span> result = {
      keyword_count: <span class="number">0</span>,
      relevance: <span class="number">0</span>,
      value: escape(text)
    };
    <span class="keyword">var</span> second_best = result;
    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> languages) {
      <span class="keyword">if</span> (!languages.hasOwnProperty(key))
        <span class="keyword">continue</span>;
      <span class="keyword">var</span> current = highlight(key, text);
      current.language = key;
      <span class="keyword">if</span> (current.keyword_count + current.relevance > second_best.keyword_count + second_best.relevance) {
        second_best = current;
      }
      <span class="keyword">if</span> (current.keyword_count + current.relevance > result.keyword_count + result.relevance) {
        second_best = result;
        result = current;
      }
    }
    <span class="keyword">if</span> (second_best.language) {
      result.second_best = second_best;
    }
    <span class="keyword">return</span> result;
  }

  <span class="comment">/*
  Post-processing of the highlighted markup:

  - replace TABs with something more useful
  - replace real line-breaks with '&lt;br>' for non-pre containers

  */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">fixMarkup</span><span class="params">(value, tabReplace, useBR)</span> {</span>
    <span class="keyword">if</span> (tabReplace) {
      value = value.replace(<span class="regexp">/^((&lt;[^>]+>|\t)+)/gm</span>, <span class="keyword">function</span>(match, p1, offset, s) {
        <span class="keyword">return</span> p1.replace(<span class="regexp">/\t/g</span>, tabReplace);
      });
    }
    <span class="keyword">if</span> (useBR) {
      value = value.replace(<span class="regexp">/\n/g</span>, <span class="string">'&lt;br>'</span>);
    }
    <span class="keyword">return</span> value;
  }

  <span class="comment">/*
  Applies highlighting to a DOM node containing code. Accepts a DOM node and
  two optional parameters for fixMarkup.
  */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">highlightBlock</span><span class="params">(block, tabReplace, useBR)</span> {</span>
    <span class="keyword">var</span> text = blockText(block, useBR);
    <span class="keyword">var</span> language = blockLanguage(block);
    <span class="keyword">var</span> result, pre;
    <span class="keyword">if</span> (language == <span class="string">'no-highlight'</span>)
        <span class="keyword">return</span>;
    <span class="keyword">if</span> (language) {
      result = highlight(language, text);
    } <span class="keyword">else</span> {
      result = highlightAuto(text);
      language = result.language;
    }
    <span class="keyword">var</span> original = nodeStream(block);
    <span class="keyword">if</span> (original.length) {
      pre = document.createElement(<span class="string">'pre'</span>);
      pre.innerHTML = result.value;
      result.value = mergeStreams(original, nodeStream(pre), text);
    }
    result.value = fixMarkup(result.value, tabReplace, useBR);

    <span class="keyword">var</span> class_name = block.className;
    <span class="keyword">if</span> (!class_name.match(<span class="string">'(\\s|^)(language-)?'</span> + language + <span class="string">'(\\s|$)'</span>)) {
      class_name = class_name ? (class_name + <span class="string">' '</span> + language) : language;
    }
    <span class="keyword">if</span> (is_old_IE &amp;&amp; block.tagName == <span class="string">'CODE'</span> &amp;&amp; block.parentNode.tagName == <span class="string">'PRE'</span>) {
      <span class="comment">// This is for backwards compatibility only. IE needs this strange</span>
      <span class="comment">// hack becasue it cannot just cleanly replace &lt;code> block contents.</span>
      pre = block.parentNode;
      <span class="keyword">var</span> container = document.createElement(<span class="string">'div'</span>);
      container.innerHTML = <span class="string">'&lt;pre>&lt;code>'</span> + result.value + <span class="string">'&lt;/code>&lt;/pre>'</span>;
      block = container.firstChild.firstChild;
      container.firstChild.className = pre.className;
      pre.parentNode.replaceChild(container.firstChild, pre);
    } <span class="keyword">else</span> {
      block.innerHTML = result.value;
    }
    block.className = class_name;
    block.result = {
      language: language,
      kw: result.keyword_count,
      re: result.relevance
    };
    <span class="keyword">if</span> (result.second_best) {
      block.second_best = {
        language: result.second_best.language,
        kw: result.second_best.keyword_count,
        re: result.second_best.relevance
      };
    }
  }

  <span class="comment">/*
  Applies highlighting to all &lt;pre>&lt;code>..&lt;/code>&lt;/pre> blocks on a page.
  */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">initHighlighting</span><span class="params">()</span> {</span>
    <span class="keyword">if</span> (initHighlighting.called)
      <span class="keyword">return</span>;
    initHighlighting.called = <span class="literal">true</span>;
    <span class="keyword">var</span> pres = document.getElementsByTagName(<span class="string">'pre'</span>);
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; pres.length; i++) {
      <span class="keyword">var</span> code = findCode(pres[i]);
      <span class="keyword">if</span> (code)
        highlightBlock(code, hljs.tabReplace);
    }
  }

  <span class="comment">/*
  Attaches highlighting to the page load event.
  */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">initHighlightingOnLoad</span><span class="params">()</span> {</span>
    <span class="keyword">if</span> (window.addEventListener) {
      window.addEventListener(<span class="string">'DOMContentLoaded'</span>, initHighlighting, <span class="literal">false</span>);
      window.addEventListener(<span class="string">'load'</span>, initHighlighting, <span class="literal">false</span>);
    } <span class="keyword">else</span> <span class="keyword">if</span> (window.attachEvent)
      window.attachEvent(<span class="string">'onload'</span>, initHighlighting);
    <span class="keyword">else</span>
      window.onload = initHighlighting;
  }

  <span class="keyword">var</span> languages = {}; <span class="comment">// a shortcut to avoid writing "this." everywhere</span>

  <span class="comment">/* Interface definition */</span>

  <span class="keyword">this</span>.LANGUAGES = languages;
  <span class="keyword">this</span>.highlight = highlight;
  <span class="keyword">this</span>.highlightAuto = highlightAuto;
  <span class="keyword">this</span>.fixMarkup = fixMarkup;
  <span class="keyword">this</span>.highlightBlock = highlightBlock;
  <span class="keyword">this</span>.initHighlighting = initHighlighting;
  <span class="keyword">this</span>.initHighlightingOnLoad = initHighlightingOnLoad;

  <span class="comment">// Common regexps</span>
  <span class="keyword">this</span>.IDENT_RE = <span class="string">'[a-zA-Z][a-zA-Z0-9_]*'</span>;
  <span class="keyword">this</span>.UNDERSCORE_IDENT_RE = <span class="string">'[a-zA-Z_][a-zA-Z0-9_]*'</span>;
  <span class="keyword">this</span>.NUMBER_RE = <span class="string">'\\b\\d+(\\.\\d+)?'</span>;
  <span class="keyword">this</span>.C_NUMBER_RE = <span class="string">'(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)'</span>; <span class="comment">// 0x..., 0..., decimal, float</span>
  <span class="keyword">this</span>.BINARY_NUMBER_RE = <span class="string">'\\b(0b[01]+)'</span>; <span class="comment">// 0b...</span>
  <span class="keyword">this</span>.RE_STARTERS_RE = <span class="string">'!|!=|!==|%|%=|&amp;|&amp;&amp;|&amp;=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|&lt;|&lt;&lt;|&lt;&lt;=|&lt;=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~'</span>;

  <span class="comment">// Common modes</span>
  <span class="keyword">this</span>.BACKSLASH_ESCAPE = {
    begin: <span class="string">'\\\\[\\s\\S]'</span>, relevance: <span class="number">0</span>
  };
  <span class="keyword">this</span>.APOS_STRING_MODE = {
    className: <span class="string">'string'</span>,
    begin: <span class="string">'\''</span>, end: <span class="string">'\''</span>,
    illegal: <span class="string">'\\n'</span>,
    contains: [<span class="keyword">this</span>.BACKSLASH_ESCAPE],
    relevance: <span class="number">0</span>
  };
  <span class="keyword">this</span>.QUOTE_STRING_MODE = {
    className: <span class="string">'string'</span>,
    begin: <span class="string">'"'</span>, end: <span class="string">'"'</span>,
    illegal: <span class="string">'\\n'</span>,
    contains: [<span class="keyword">this</span>.BACKSLASH_ESCAPE],
    relevance: <span class="number">0</span>
  };
  <span class="keyword">this</span>.C_LINE_COMMENT_MODE = {
    className: <span class="string">'comment'</span>,
    begin: <span class="string">'//'</span>, end: <span class="string">'$'</span>
  };
  <span class="keyword">this</span>.C_BLOCK_COMMENT_MODE = {
    className: <span class="string">'comment'</span>,
    begin: <span class="string">'/\\*'</span>, end: <span class="string">'\\*/'</span>
  };
  <span class="keyword">this</span>.HASH_COMMENT_MODE = {
    className: <span class="string">'comment'</span>,
    begin: <span class="string">'#'</span>, end: <span class="string">'$'</span>
  };
  <span class="keyword">this</span>.NUMBER_MODE = {
    className: <span class="string">'number'</span>,
    begin: <span class="keyword">this</span>.NUMBER_RE,
    relevance: <span class="number">0</span>
  };
  <span class="keyword">this</span>.C_NUMBER_MODE = {
    className: <span class="string">'number'</span>,
    begin: <span class="keyword">this</span>.C_NUMBER_RE,
    relevance: <span class="number">0</span>
  };
  <span class="keyword">this</span>.BINARY_NUMBER_MODE = {
    className: <span class="string">'number'</span>,
    begin: <span class="keyword">this</span>.BINARY_NUMBER_RE,
    relevance: <span class="number">0</span>
  };

  <span class="comment">// Utility functions</span>
  <span class="keyword">this</span>.inherit = <span class="keyword">function</span>(parent, obj) {
    <span class="keyword">var</span> result = {}
    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> parent)
      result[key] = parent[key];
    <span class="keyword">if</span> (obj)
      <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj)
        result[key] = obj[key];
    <span class="keyword">return</span> result;
  }
}();
hljs.LANGUAGES[<span class="string">'bash'</span>] = require(<span class="string">'./bash.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'erlang'</span>] = require(<span class="string">'./erlang.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'cs'</span>] = require(<span class="string">'./cs.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'ruby'</span>] = require(<span class="string">'./ruby.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'rust'</span>] = require(<span class="string">'./rust.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'rib'</span>] = require(<span class="string">'./rib.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'diff'</span>] = require(<span class="string">'./diff.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'javascript'</span>] = require(<span class="string">'./javascript.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'glsl'</span>] = require(<span class="string">'./glsl.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'rsl'</span>] = require(<span class="string">'./rsl.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'lua'</span>] = require(<span class="string">'./lua.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'xml'</span>] = require(<span class="string">'./xml.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'markdown'</span>] = require(<span class="string">'./markdown.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'css'</span>] = require(<span class="string">'./css.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'lisp'</span>] = require(<span class="string">'./lisp.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'profile'</span>] = require(<span class="string">'./profile.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'http'</span>] = require(<span class="string">'./http.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'java'</span>] = require(<span class="string">'./java.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'php'</span>] = require(<span class="string">'./php.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'haskell'</span>] = require(<span class="string">'./haskell.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'1c'</span>] = require(<span class="string">'./1c.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'python'</span>] = require(<span class="string">'./python.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'smalltalk'</span>] = require(<span class="string">'./smalltalk.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'tex'</span>] = require(<span class="string">'./tex.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'actionscript'</span>] = require(<span class="string">'./actionscript.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'sql'</span>] = require(<span class="string">'./sql.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'vala'</span>] = require(<span class="string">'./vala.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'ini'</span>] = require(<span class="string">'./ini.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'d'</span>] = require(<span class="string">'./d.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'axapta'</span>] = require(<span class="string">'./axapta.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'perl'</span>] = require(<span class="string">'./perl.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'scala'</span>] = require(<span class="string">'./scala.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'cmake'</span>] = require(<span class="string">'./cmake.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'objectivec'</span>] = require(<span class="string">'./objectivec.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'avrasm'</span>] = require(<span class="string">'./avrasm.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'vhdl'</span>] = require(<span class="string">'./vhdl.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'coffeescript'</span>] = require(<span class="string">'./coffeescript.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'nginx'</span>] = require(<span class="string">'./nginx.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'erlang-repl'</span>] = require(<span class="string">'./erlang-repl.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'r'</span>] = require(<span class="string">'./r.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'json'</span>] = require(<span class="string">'./json.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'django'</span>] = require(<span class="string">'./django.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'delphi'</span>] = require(<span class="string">'./delphi.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'vbscript'</span>] = require(<span class="string">'./vbscript.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'mel'</span>] = require(<span class="string">'./mel.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'dos'</span>] = require(<span class="string">'./dos.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'apache'</span>] = require(<span class="string">'./apache.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'cpp'</span>] = require(<span class="string">'./cpp.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'matlab'</span>] = require(<span class="string">'./matlab.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'parser3'</span>] = require(<span class="string">'./parser3.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'clojure'</span>] = require(<span class="string">'./clojure.js'</span>)(hljs);
hljs.LANGUAGES[<span class="string">'go'</span>] = require(<span class="string">'./go.js'</span>)(hljs);
module.exports = hljs;</code></pre>