<h1>reqursive</h1>
<pre><code class="lang-js"><span class="keyword">var</span> detective = require(<span class="string">'detective'</span>)
  , async = require(<span class="string">'async'</span>)
  , nub = require(<span class="string">'nub'</span>)
  , fs = require(<span class="string">'fs'</span>)
  , path = require(<span class="string">'path'</span>)
  , mod = require(<span class="string">'module'</span>).Module

<span class="keyword">var</span> findPath = mod._findPath
  , lookupPaths = mod._resolveLookupPaths
  , nodeModules = mod._nodeModulePaths

<span class="comment">/**
 * Finds a file that is required using an absolute
 * or relative path.
 *
 * @param  {String} request   The string supplied to require()
 * @param  {String} directory The directory of the file calling require()
 * @param  {Object} parent    id, filename, etc. of the file calling require()
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">findRelative</span><span class="params">(request, directory, parent)</span> {</span>
    <span class="keyword">var</span> target = path.resolve(directory, request)
    <span class="keyword">var</span> exists = <span class="literal">false</span>

    ;[
          target
        , target + <span class="string">'.js'</span>
        , target + <span class="string">'.json'</span>
        , target + <span class="string">'.coffee'</span>
        , target + <span class="string">'/index.js'</span>
    ].forEach(<span class="keyword">function</span>(attempt) {
        <span class="keyword">var</span> ok = (path.existsSync || fs.existsSync)(attempt)
        exists = ok || exists
        
        <span class="keyword">if</span> (ok) {
            target = attempt
        }
    })

    <span class="keyword">return</span> {
          <span class="string">'id'</span>: path.basename(target)
        , <span class="string">'filename'</span>: target
        , <span class="string">'parents'</span>: [parent.filename]
        , <span class="string">'module'</span>: <span class="literal">false</span>
        , <span class="string">'native'</span>: <span class="literal">false</span>
        , <span class="string">'mgroup'</span>: parent.mgroup || <span class="literal">false</span>
    }
};

<span class="comment">/**
 * Finds a file that is required as a module,
 * i.e. require('detective') as opposed to require('./lib/app')
 * 
 * @param  {String} request   The string supplied to require()
 * @param  {Object} parent    id, filename, etc. of the file calling require()
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">findModule</span><span class="params">(request, parent)</span> {</span>
    <span class="keyword">var</span> directory
      , filename
      , paths
      , id

    directory = path.resolve(parent.filename)
    directory = path.dirname(directory)

    paths = lookupPaths(request, {
          id: parent.id || request
        , paths: nodeModules(directory)
    })

    <span class="keyword">if</span> (paths &amp;&amp; paths[<span class="number">0</span>] &amp;&amp; !paths[<span class="number">1</span>].length) {
        <span class="keyword">return</span> {
              <span class="string">'id'</span>: request
            , <span class="string">'module'</span>: <span class="literal">true</span>
            , <span class="string">'native'</span>: <span class="literal">true</span>
            , <span class="string">'parents'</span>: [parent.filename]
            , <span class="string">'mgroup'</span>: request
        };
    } <span class="keyword">else</span>
    <span class="keyword">if</span> (!paths || !paths.length) {
        <span class="keyword">return</span> <span class="literal">false</span>
    }

    id = paths[<span class="number">0</span>]
    paths = [directory].concat(paths[<span class="number">1</span>])
    filename = findPath(id, paths)

    <span class="keyword">return</span> {
          <span class="string">'id'</span>: id
        , <span class="string">'filename'</span>: filename
        , <span class="string">'parents'</span>: [parent.filename]
        , <span class="string">'module'</span>: <span class="literal">true</span>
        , <span class="string">'native'</span>: <span class="literal">false</span>
        , <span class="string">'mgroup'</span>: id
    };
};

<span class="function"><span class="keyword">function</span> <span class="title">entryObject</span><span class="params">(filename)</span> {</span>
    <span class="keyword">return</span> {
          id: path.basename(filename)
        , parents: []
        , module: <span class="literal">false</span>
        , mgroup: <span class="literal">false</span>
        , filename: filename
    };
};

<span class="comment">/**
 * Get a file's child scripts: the files pulled
 * in using require().
 *
 * @param  {String}   parent   The file to query
 * @param  {Function} callback
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">getChildren</span><span class="params">(parent, callback)</span> {</span>
    <span class="keyword">if</span> (<span class="keyword">typeof</span> parent === <span class="string">'string'</span>) {
        parent = { filename: parent }
    }

    <span class="keyword">var</span> filename = parent.filename

    fs.readFile(filename, <span class="string">'utf8'</span>, <span class="keyword">function</span>(err, body) {
        <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(<span class="literal">null</span>, [])

        <span class="comment">// Save Esprima from freaking out about</span>
        <span class="comment">// hashbangs</span>
        body = body.split(<span class="string">'\n'</span>)
        <span class="keyword">if</span> (<span class="regexp">/^\#!\//</span>.test(body[<span class="number">0</span>])) {
            body = body.slice(<span class="number">1</span>)
        }
        body = body.join(<span class="string">'\n'</span>)

        <span class="keyword">try</span> {
            <span class="keyword">var</span> modules = detective(body);
        } <span class="keyword">catch</span>(e) {
            <span class="keyword">return</span> callback(e)
        }

        modules = modules.map(<span class="keyword">function</span>(id) {
            <span class="keyword">if</span> (id.match(<span class="regexp">/^[\.\/]/</span>)) {
                <span class="keyword">return</span> findRelative(id
                    , path.resolve(path.dirname(filename))
                    , parent
                );
            } <span class="keyword">else</span> {
                <span class="keyword">return</span> findModule(id, parent);
            }
        }).filter(<span class="keyword">function</span>(script) {
            <span class="keyword">return</span> script &amp;&amp; script.id
        })

        modules = nub.by(modules, <span class="keyword">function</span>(one, two) {
            <span class="keyword">if</span> (one.module &amp;&amp; two.module) {
                <span class="keyword">return</span> one.id === two.id
            }
            <span class="keyword">return</span> one.filename === two.filename
        })

        callback(<span class="literal">null</span>, modules)
    })
};

<span class="comment">/**
 * Pulls in a list of all the files required,
 * recursively, starting from a single file.
 *
 * For now there's only one option: "traverseModules".
 * This is enabled by default, but setting it to false
 * will ignore the contents of other modules.
 * 
 * @param  {String}   entry    The initial filename
 * @param  {Object}   options  (optional)
 * @param  {Function} callback (optional)
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">getChildrenRecursive</span><span class="params">(entry, options, callback)</span> {</span>
    <span class="keyword">var</span> results = {}
      , entry = Array.isArray(entry) ? entry : [entry]
      , first = <span class="literal">true</span>
      , queue

    <span class="keyword">if</span> (<span class="keyword">typeof</span> options === <span class="string">'function'</span>) {
        callback = options
        options = {}
    }

    callback = callback || <span class="keyword">function</span>(){}

    options = options || {}
    options.traverseModules = !!options.traverseModules

    entry = entry.map(<span class="keyword">function</span>(filename) {
        filename = path.resolve(filename)
        results[filename] = entryObject(filename)
        <span class="keyword">return</span> filename
    })
    queue = [].concat(entry)

    async.whilst(<span class="keyword">function</span>() {
        <span class="keyword">return</span> queue.length > <span class="number">0</span>
    }, iteration
     , finished)

    <span class="function"><span class="keyword">function</span> <span class="title">iteration</span><span class="params">(next)</span> {</span>
        <span class="keyword">var</span> absolute = path.resolve(queue.shift())

        getChildren(results[absolute] || absolute, <span class="keyword">function</span>(err, children) {
            <span class="keyword">if</span> (err &amp;&amp; first) {
                <span class="keyword">return</span> next(err)
            } <span class="keyword">else</span>
            <span class="keyword">if</span> (err) {
                results[absolute].error = err
                <span class="keyword">return</span> next()
            }

            first = <span class="literal">false</span>

            children.forEach(<span class="keyword">function</span>(child) {
                <span class="keyword">if</span> (results[child.filename]) {
                    results[child.filename].parents.push(absolute)
                    <span class="keyword">return</span>
                }

                results[
                    child.native ? <span class="string">'native::'</span> + child.id :
                    child.filename
                ] = child
                
                <span class="keyword">if</span> (child.native) <span class="keyword">return</span>;

                <span class="keyword">if</span> (!child.module || options.traverseModules) {
                    queue.push(child.filename)
                }
            })

            next()
        });
    };

    <span class="function"><span class="keyword">function</span> <span class="title">finished</span><span class="params">(err)</span> {</span>
        <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);

        <span class="keyword">var</span> response = []

        Object.keys(results).forEach(<span class="keyword">function</span>(key) {
            <span class="keyword">var</span> dirname = path.dirname(entry[<span class="number">0</span>])
              , relative = path.relative(dirname, key)

            results[key].parents = nub(
                results[key].parents || []
            ).map(<span class="keyword">function</span>(script) {
                <span class="keyword">return</span> options.absolute ? script : path.relative(dirname, script)
            })

            <span class="keyword">if</span> (results[key].filename &amp;&amp; !options.absolute) {
                results[key].filename = path.relative(dirname, results[key].filename)
            }

            response.push(results[key])
        });

        callback(<span class="literal">null</span>, response)
    };
};

module.exports = getChildrenRecursive

module.exports.children = <span class="function"><span class="keyword">function</span> <span class="title">children</span><span class="params">(filename, callback)</span> {</span>
    <span class="keyword">var</span> absolute = path.resolve(filename)

    getChildren(filename, <span class="keyword">function</span>(err, children) {
        <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err)

        children.unshift(entryObject(absolute))
        callback(<span class="literal">null</span>, children)
    })
};
</code></pre>