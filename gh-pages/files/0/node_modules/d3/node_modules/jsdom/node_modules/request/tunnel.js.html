<h1>tunnel.js</h1>
<pre><code class="lang-js"><span class="string">'use strict'</span>;

<span class="keyword">var</span> net = require(<span class="string">'net'</span>);
<span class="keyword">var</span> tls = require(<span class="string">'tls'</span>);
<span class="keyword">var</span> http = require(<span class="string">'http'</span>);
<span class="keyword">var</span> https = require(<span class="string">'https'</span>);
<span class="keyword">var</span> events = require(<span class="string">'events'</span>);
<span class="keyword">var</span> assert = require(<span class="string">'assert'</span>);
<span class="keyword">var</span> util = require(<span class="string">'util'</span>);


exports.httpOverHttp = httpOverHttp;
exports.httpsOverHttp = httpsOverHttp;
exports.httpOverHttps = httpOverHttps;
exports.httpsOverHttps = httpsOverHttps;


<span class="function"><span class="keyword">function</span> <span class="title">httpOverHttp</span><span class="params">(options)</span> {</span>
  <span class="keyword">var</span> agent = <span class="keyword">new</span> TunnelingAgent(options);
  agent.request = http.request;
  <span class="keyword">return</span> agent;
}

<span class="function"><span class="keyword">function</span> <span class="title">httpsOverHttp</span><span class="params">(options)</span> {</span>
  <span class="keyword">var</span> agent = <span class="keyword">new</span> TunnelingAgent(options);
  agent.request = http.request;
  agent.createSocket = createSecureSocket;
  <span class="keyword">return</span> agent;
}

<span class="function"><span class="keyword">function</span> <span class="title">httpOverHttps</span><span class="params">(options)</span> {</span>
  <span class="keyword">var</span> agent = <span class="keyword">new</span> TunnelingAgent(options);
  agent.request = https.request;
  <span class="keyword">return</span> agent;
}

<span class="function"><span class="keyword">function</span> <span class="title">httpsOverHttps</span><span class="params">(options)</span> {</span>
  <span class="keyword">var</span> agent = <span class="keyword">new</span> TunnelingAgent(options);
  agent.request = https.request;
  agent.createSocket = createSecureSocket;
  <span class="keyword">return</span> agent;
}


<span class="function"><span class="keyword">function</span> <span class="title">TunnelingAgent</span><span class="params">(options)</span> {</span>
  <span class="keyword">var</span> self = <span class="keyword">this</span>;
  self.options = options || {};
  self.proxyOptions = self.options.proxy || {};
  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;
  self.requests = [];
  self.sockets = [];

  self.on(<span class="string">'free'</span>, <span class="function"><span class="keyword">function</span> <span class="title">onFree</span><span class="params">(socket, host, port)</span> {</span>
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = self.requests.length; i &lt; len; ++i) {
      <span class="keyword">var</span> pending = self.requests[i];
      <span class="keyword">if</span> (pending.host === host &amp;&amp; pending.port === port) {
        <span class="comment">// Detect the request to connect same origin server,</span>
        <span class="comment">// reuse the connection.</span>
        self.requests.splice(i, <span class="number">1</span>);
        pending.request.onSocket(socket);
        <span class="keyword">return</span>;
      }
    }
    socket.destroy();
    self.removeSocket(socket);
  });
}
util.inherits(TunnelingAgent, events.EventEmitter);

TunnelingAgent.prototype.addRequest = <span class="function"><span class="keyword">function</span> <span class="title">addRequest</span><span class="params">(req, host, port)</span> {</span>
  <span class="keyword">var</span> self = <span class="keyword">this</span>;

  <span class="keyword">if</span> (self.sockets.length >= <span class="keyword">this</span>.maxSockets) {
    <span class="comment">// We are over limit so we'll add it to the queue.</span>
    self.requests.push({host: host, port: port, request: req});
    <span class="keyword">return</span>;
  }

  <span class="comment">// If we are under maxSockets create a new one.</span>
  self.createSocket({host: host, port: port, request: req}, <span class="keyword">function</span>(socket) {
    socket.on(<span class="string">'free'</span>, onFree);
    socket.on(<span class="string">'close'</span>, onCloseOrRemove);
    socket.on(<span class="string">'agentRemove'</span>, onCloseOrRemove);
    req.onSocket(socket);

    <span class="function"><span class="keyword">function</span> <span class="title">onFree</span><span class="params">()</span> {</span>
      self.emit(<span class="string">'free'</span>, socket, host, port);
    }

    <span class="function"><span class="keyword">function</span> <span class="title">onCloseOrRemove</span><span class="params">(err)</span> {</span>
      self.removeSocket();
      socket.removeListener(<span class="string">'free'</span>, onFree);
      socket.removeListener(<span class="string">'close'</span>, onCloseOrRemove);
      socket.removeListener(<span class="string">'agentRemove'</span>, onCloseOrRemove);
    }
  });
};

TunnelingAgent.prototype.createSocket = <span class="function"><span class="keyword">function</span> <span class="title">createSocket</span><span class="params">(options, cb)</span> {</span>
  <span class="keyword">var</span> self = <span class="keyword">this</span>;
  <span class="keyword">var</span> placeholder = {};
  self.sockets.push(placeholder);

  <span class="keyword">var</span> connectOptions = mergeOptions({}, self.proxyOptions, {
    method: <span class="string">'CONNECT'</span>,
    path: options.host + <span class="string">':'</span> + options.port,
    agent: <span class="literal">false</span>
  });
  <span class="keyword">if</span> (connectOptions.proxyAuth) {
    connectOptions.headers = connectOptions.headers || {};
    connectOptions.headers[<span class="string">'Proxy-Authorization'</span>] = <span class="string">'Basic '</span> +
        <span class="keyword">new</span> Buffer(connectOptions.proxyAuth).toString(<span class="string">'base64'</span>);
  }

  debug(<span class="string">'making CONNECT request'</span>);
  <span class="keyword">var</span> connectReq = self.request(connectOptions);
  connectReq.useChunkedEncodingByDefault = <span class="literal">false</span>; <span class="comment">// for v0.6</span>
  connectReq.once(<span class="string">'response'</span>, onResponse); <span class="comment">// for v0.6</span>
  connectReq.once(<span class="string">'upgrade'</span>, onUpgrade);   <span class="comment">// for v0.6</span>
  connectReq.once(<span class="string">'connect'</span>, onConnect);   <span class="comment">// for v0.7 or later</span>
  connectReq.once(<span class="string">'error'</span>, onError);
  connectReq.end();

  <span class="function"><span class="keyword">function</span> <span class="title">onResponse</span><span class="params">(res)</span> {</span>
    <span class="comment">// Very hacky. This is necessary to avoid http-parser leaks.</span>
    res.upgrade = <span class="literal">true</span>;
  }

  <span class="function"><span class="keyword">function</span> <span class="title">onUpgrade</span><span class="params">(res, socket, head)</span> {</span>
    <span class="comment">// Hacky.</span>
    process.nextTick(<span class="keyword">function</span>() {
      onConnect(res, socket, head);
    });
  }

  <span class="function"><span class="keyword">function</span> <span class="title">onConnect</span><span class="params">(res, socket, head)</span> {</span>
    connectReq.removeAllListeners();
    socket.removeAllListeners();

    <span class="keyword">if</span> (res.statusCode === <span class="number">200</span>) {
      assert.equal(head.length, <span class="number">0</span>);
      debug(<span class="string">'tunneling connection has established'</span>);
      self.sockets[self.sockets.indexOf(placeholder)] = socket;
      cb(socket);
    } <span class="keyword">else</span> {
      debug(<span class="string">'tunneling socket could not be established, statusCode=%d'</span>,
            res.statusCode);
      <span class="keyword">var</span> error = <span class="keyword">new</span> Error(<span class="string">'tunneling socket could not be established, '</span> +
                            <span class="string">'sutatusCode='</span> + res.statusCode);
      error.code = <span class="string">'ECONNRESET'</span>;
      options.request.emit(<span class="string">'error'</span>, error);
      self.removeSocket(placeholder);
    }
  }

  <span class="function"><span class="keyword">function</span> <span class="title">onError</span><span class="params">(cause)</span> {</span>
    connectReq.removeAllListeners();

    debug(<span class="string">'tunneling socket could not be established, cause=%s\n'</span>,
          cause.message, cause.stack);
    <span class="keyword">var</span> error = <span class="keyword">new</span> Error(<span class="string">'tunneling socket could not be established, '</span> +
                          <span class="string">'cause='</span> + cause.message);
    error.code = <span class="string">'ECONNRESET'</span>;
    options.request.emit(<span class="string">'error'</span>, error);
    self.removeSocket(placeholder);
  }
};

TunnelingAgent.prototype.removeSocket = <span class="function"><span class="keyword">function</span> <span class="title">removeSocket</span><span class="params">(socket)</span> {</span>
  <span class="keyword">var</span> pos = <span class="keyword">this</span>.sockets.indexOf(socket)
  <span class="keyword">if</span> (pos === -<span class="number">1</span>) {
    <span class="keyword">return</span>;
  }
  <span class="keyword">this</span>.sockets.splice(pos, <span class="number">1</span>);

  <span class="keyword">var</span> pending = <span class="keyword">this</span>.requests.shift();
  <span class="keyword">if</span> (pending) {
    <span class="comment">// If we have pending requests and a socket gets closed a new one</span>
    <span class="comment">// needs to be created to take over in the pool for the one that closed.</span>
    <span class="keyword">this</span>.createSocket(pending, <span class="keyword">function</span>(socket) {
      pending.request.onSocket(socket);
    });
  }
};

<span class="function"><span class="keyword">function</span> <span class="title">createSecureSocket</span><span class="params">(options, cb)</span> {</span>
  <span class="keyword">var</span> self = <span class="keyword">this</span>;
  TunnelingAgent.prototype.createSocket.call(self, options, <span class="keyword">function</span>(socket) {
    <span class="comment">// 0 is dummy port for v0.6</span>
    <span class="keyword">var</span> secureSocket = tls.connect(<span class="number">0</span>, mergeOptions({}, self.options, {
      servername: options.host,
      socket: socket
    }));
    cb(secureSocket);
  });
}


<span class="function"><span class="keyword">function</span> <span class="title">mergeOptions</span><span class="params">(target)</span> {</span>
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>, len = arguments.length; i &lt; len; ++i) {
    <span class="keyword">var</span> overrides = arguments[i];
    <span class="keyword">if</span> (<span class="keyword">typeof</span> overrides === <span class="string">'object'</span>) {
      <span class="keyword">var</span> keys = Object.keys(overrides);
      <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>, keyLen = keys.length; j &lt; keyLen; ++j) {
        <span class="keyword">var</span> k = keys[j];
        <span class="keyword">if</span> (overrides[k] !== <span class="literal">undefined</span>) {
          target[k] = overrides[k];
        }
      }
    }
  }
  <span class="keyword">return</span> target;
}


<span class="keyword">var</span> debug;
<span class="keyword">if</span> (process.env.NODE_DEBUG &amp;&amp; <span class="regexp">/\btunnel\b/</span>.test(process.env.NODE_DEBUG)) {
  debug = <span class="keyword">function</span>() {
    <span class="keyword">var</span> args = Array.prototype.slice.call(arguments);
    <span class="keyword">if</span> (<span class="keyword">typeof</span> args[<span class="number">0</span>] === <span class="string">'string'</span>) {
      args[<span class="number">0</span>] = <span class="string">'TUNNEL: '</span> + args[<span class="number">0</span>];
    } <span class="keyword">else</span> {
      args.unshift(<span class="string">'TUNNEL:'</span>);
    }
    console.error.apply(console, args);
  }
} <span class="keyword">else</span> {
  debug = <span class="keyword">function</span>() {};
}
exports.debug = debug; <span class="comment">// for test</span>
</code></pre>