<h1>html.js</h1>
<pre><code class="lang-js"><span class="keyword">var</span> core                  = require(<span class="string">"./core"</span>).dom.level2.core,
    events                = require(<span class="string">"./core"</span>).dom.level2.events,
    applyDocumentFeatures = require(<span class="string">'../browser/documentfeatures'</span>).applyDocumentFeatures,
    URL                   = require(<span class="string">"url"</span>),
    Path                  = require(<span class="string">'path'</span>),
    fs                    = require(<span class="string">"fs"</span>),
    http                  = require(<span class="string">'http'</span>),
    https                 = require(<span class="string">'https'</span>);

<span class="comment">// modify cloned instance for more info check: https://github.com/tmpvar/jsdom/issues/325</span>
core = Object.create(core);

<span class="comment">// Setup the javascript language processor</span>
core.languageProcessors = {
  javascript : require(<span class="string">"./languages/javascript"</span>).javascript
};

core.resourceLoader = {
  load: <span class="keyword">function</span>(element, href, callback) {
    <span class="keyword">var</span> ownerImplementation = element._ownerDocument.implementation;

    <span class="keyword">if</span> (ownerImplementation.hasFeature(<span class="string">'FetchExternalResources'</span>, element.tagName.toLowerCase())) {
      <span class="keyword">var</span> full = <span class="keyword">this</span>.resolve(element._ownerDocument, href);
      <span class="keyword">var</span> url = URL.parse(full);
      <span class="keyword">if</span> (url.hostname) {
        <span class="keyword">this</span>.download(url, <span class="keyword">this</span>.baseUrl(element._ownerDocument), <span class="keyword">this</span>.enqueue(element, callback, full));
      }
      <span class="keyword">else</span> {
        <span class="keyword">this</span>.readFile(url.pathname, <span class="keyword">this</span>.enqueue(element, callback, full));
      }
    }
  },
  enqueue: <span class="keyword">function</span>(element, callback, filename) {
    <span class="keyword">var</span> loader = <span class="keyword">this</span>,
        doc    = element.nodeType === core.Node.DOCUMENT_NODE ?
                 element                :
                 element._ownerDocument;

    <span class="keyword">if</span> (!doc._queue) {
      <span class="keyword">return</span> <span class="keyword">function</span>() {};
    }

    <span class="keyword">return</span> doc._queue.push(<span class="keyword">function</span>(err, data) {
      <span class="keyword">var</span> ev = doc.createEvent(<span class="string">'HTMLEvents'</span>);

      <span class="keyword">if</span> (!err) {
        <span class="keyword">try</span> {
          callback.call(element, data, filename || doc.URL);
          ev.initEvent(<span class="string">'load'</span>, <span class="literal">false</span>, <span class="literal">false</span>);
        }
        <span class="keyword">catch</span>(e) {
          err = e;
        }
      }

      <span class="keyword">if</span> (err) {
        ev.initEvent(<span class="string">'error'</span>, <span class="literal">false</span>, <span class="literal">false</span>);
        ev.error = err;
      }

      element.dispatchEvent(ev);
    });
  },

  baseUrl: <span class="keyword">function</span>(document) {
    <span class="keyword">var</span> baseElements = document.getElementsByTagName(<span class="string">'base'</span>),
        baseUrl      = document.URL;

    <span class="keyword">if</span> (baseElements.length > <span class="number">0</span>) {
      baseUrl = baseElements.item(<span class="number">0</span>).href;
    }

    <span class="keyword">return</span> baseUrl;
  },
  resolve: <span class="keyword">function</span>(document, href) {
    <span class="keyword">if</span> (href.match(<span class="regexp">/^\w+:\/\//</span>)) {
      <span class="keyword">return</span> href;
    }

    <span class="keyword">var</span> baseUrl = <span class="keyword">this</span>.baseUrl(document);

    <span class="comment">// See RFC 2396 section 3 for this weirdness. URLs without protocol</span>
    <span class="comment">// have their protocol default to the current one.</span>
    <span class="comment">// http://www.ietf.org/rfc/rfc2396.txt</span>
    <span class="keyword">if</span> (href.match(<span class="regexp">/^\/\//</span>)) {
      <span class="keyword">return</span> baseUrl ? baseUrl.match(<span class="regexp">/^(\w+:)\/\//</span>)[<span class="number">1</span>] + href : <span class="literal">null</span>;
    } <span class="keyword">else</span> <span class="keyword">if</span> (!href.match(<span class="regexp">/^\/[^\/]/</span>)) {
      href = href.replace(<span class="regexp">/^\//</span>, <span class="string">""</span>);
    }

    <span class="keyword">return</span> URL.resolve(baseUrl, href);
  },
  download: <span class="keyword">function</span>(url, referrer, callback) {
    <span class="keyword">var</span> path    = url.pathname + (url.search || <span class="string">''</span>),
        options = {<span class="string">'method'</span>: <span class="string">'GET'</span>, <span class="string">'host'</span>: url.hostname, <span class="string">'path'</span>: path},
        request;
    <span class="keyword">if</span> (url.protocol === <span class="string">'https:'</span>) {
      options.port = url.port || <span class="number">443</span>;
      request = https.request(options);
    } <span class="keyword">else</span> {
      options.port = url.port || <span class="number">80</span>;
      request = http.request(options);
    }

    <span class="comment">// set header.</span>
    <span class="keyword">if</span> (referrer) {
        request.setHeader(<span class="string">'Referer'</span>, referrer);
    }

    request.on(<span class="string">'response'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(response)</span> {</span>
      <span class="keyword">var</span> data = <span class="string">''</span>;
      <span class="function"><span class="keyword">function</span> <span class="title">success</span> <span class="params">()</span> {</span>
        <span class="keyword">if</span> ([<span class="number">301</span>, <span class="number">302</span>, <span class="number">303</span>, <span class="number">307</span>].indexOf(response.statusCode) > -<span class="number">1</span>) {
          <span class="keyword">var</span> redirect = URL.resolve(url, response.headers[<span class="string">"location"</span>]);
          core.resourceLoader.download(URL.parse(redirect), referrer, callback);
        } <span class="keyword">else</span> {
          callback(<span class="literal">null</span>, data);
        }
      }
      response.setEncoding(<span class="string">'utf8'</span>);
      response.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(chunk)</span> {</span>
        data += chunk.toString();
      });
      response.on(<span class="string">'end'</span>, <span class="keyword">function</span>() {
        <span class="comment">// According to node docs, 'close' can fire after 'end', but not</span>
        <span class="comment">// vice versa.  Remove 'close' listener so we don't call success twice.</span>
        response.removeAllListeners(<span class="string">'close'</span>);
        success();
      });
      response.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
        <span class="keyword">if</span> (err) {
          callback(err);
        } <span class="keyword">else</span> {
          success();
        }
      });
    });

    request.on(<span class="string">'error'</span>, callback);
    request.end();
  },
  readFile: <span class="keyword">function</span>(url, callback) {
    fs.readFile(url.replace(<span class="regexp">/^file:\/\//</span>, <span class="string">""</span>), <span class="string">'utf8'</span>, callback);
  }
};

<span class="function"><span class="keyword">function</span> <span class="title">define</span><span class="params">(elementClass, def)</span> {</span>
  <span class="keyword">var</span> tagName = def.tagName,
    tagNames = def.tagNames || (tagName? [tagName] : []),
    parentClass = def.parentClass || core.HTMLElement,
    attrs = def.attributes || [],
    proto = def.proto || {};

  <span class="keyword">var</span> elem = core[elementClass] = <span class="keyword">function</span>(document, name) {
    parentClass.call(<span class="keyword">this</span>, document, name || tagName.toUpperCase());
    <span class="keyword">if</span> (elem._init) {
      elem._init.call(<span class="keyword">this</span>);
    }
  };
  elem._init = def.init;

  elem.prototype = proto;
  elem.prototype.__proto__ = parentClass.prototype;

  attrs.forEach(<span class="keyword">function</span>(n) {
      <span class="keyword">var</span> prop = n.prop || n,
        attr = n.attr || prop.toLowerCase();

      <span class="keyword">if</span> (!n.prop || n.read !== <span class="literal">false</span>) {
        elem.prototype.__defineGetter__(prop, <span class="keyword">function</span>() {
          <span class="keyword">var</span> s = <span class="keyword">this</span>.getAttribute(attr);
          <span class="keyword">if</span> (n.type &amp;&amp; n.type === <span class="string">'boolean'</span>) {
            <span class="keyword">return</span> !!s;
          }
          <span class="keyword">if</span> (n.type &amp;&amp; n.type === <span class="string">'long'</span>) {
            <span class="keyword">return</span> +s;
          }
          <span class="keyword">if</span> (n.normalize) {
            <span class="keyword">return</span> n.normalize(s);
          }
          <span class="keyword">return</span> s;
        });
      }

      <span class="keyword">if</span> (!n.prop || n.write !== <span class="literal">false</span>) {
        elem.prototype.__defineSetter__(prop, <span class="keyword">function</span>(val) {
          <span class="keyword">if</span> (!val) {
            <span class="keyword">this</span>.removeAttribute(attr);
          }
          <span class="keyword">else</span> {
            <span class="keyword">var</span> s = val.toString();
            <span class="keyword">if</span> (n.normalize) {
              s = n.normalize(s);
            }
            <span class="keyword">this</span>.setAttribute(attr, s);
          }
        });
      }
  });

  tagNames.forEach(<span class="keyword">function</span>(tag) {
    core.Document.prototype._elementBuilders[tag.toLowerCase()] = <span class="keyword">function</span>(doc, s) {
      <span class="keyword">var</span> el = <span class="keyword">new</span> elem(doc, s);
      <span class="keyword">return</span> el;
    };
  });
}



core.HTMLCollection = <span class="function"><span class="keyword">function</span> <span class="title">HTMLCollection</span><span class="params">(element, query)</span> {</span>
  core.NodeList.call(<span class="keyword">this</span>, element, query);
};
core.HTMLCollection.prototype = {
  namedItem : <span class="keyword">function</span>(name) {
    <span class="keyword">var</span> results = <span class="keyword">this</span>.toArray(),
        l       = results.length,
        node,
        matchingName = <span class="literal">null</span>;

    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;l; i++) {
      node = results[i];
      <span class="keyword">if</span> (node.getAttribute(<span class="string">'id'</span>) === name) {
        <span class="keyword">return</span> node;
      } <span class="keyword">else</span> <span class="keyword">if</span> (node.getAttribute(<span class="string">'name'</span>) === name) {
        matchingName = node;
      }
    }
    <span class="keyword">return</span> matchingName;
  },
  toString: <span class="keyword">function</span>() {
    <span class="keyword">return</span> <span class="string">'[ jsdom HTMLCollection ]: contains '</span> + <span class="keyword">this</span>.length + <span class="string">' items'</span>;
  }
};
core.HTMLCollection.prototype.__proto__ = core.NodeList.prototype;

core.HTMLOptionsCollection = core.HTMLCollection;

<span class="function"><span class="keyword">function</span> <span class="title">closest</span><span class="params">(e, tagName)</span> {</span>
  tagName = tagName.toUpperCase();
  <span class="keyword">while</span> (e) {
    <span class="keyword">if</span> (e.nodeName.toUpperCase() === tagName ||
        (e.tagName &amp;&amp; e.tagName.toUpperCase() === tagName))
    {
      <span class="keyword">return</span> e;
    }
    e = e._parentNode;
  }
  <span class="keyword">return</span> <span class="literal">null</span>;
}

<span class="function"><span class="keyword">function</span> <span class="title">descendants</span><span class="params">(e, tagName, recursive)</span> {</span>
  <span class="keyword">var</span> owner = recursive ? e._ownerDocument || e : e;
  <span class="keyword">return</span> <span class="keyword">new</span> core.HTMLCollection(owner, core.mapper(e, <span class="keyword">function</span>(n) {
    <span class="keyword">return</span> n.nodeName === tagName;
  }, recursive));
}

<span class="function"><span class="keyword">function</span> <span class="title">firstChild</span><span class="params">(e, tagName)</span> {</span>
  <span class="keyword">if</span> (!e) {
    <span class="keyword">return</span> <span class="literal">null</span>;
  }
  <span class="keyword">var</span> c = descendants(e, tagName, <span class="literal">false</span>);
  <span class="keyword">return</span> c.length > <span class="number">0</span> ? c[<span class="number">0</span>] : <span class="literal">null</span>;
}

<span class="function"><span class="keyword">function</span> <span class="title">ResourceQueue</span><span class="params">(paused)</span> {</span>
  <span class="keyword">this</span>.paused = !!paused;
}
ResourceQueue.prototype = {
  push: <span class="keyword">function</span>(callback) {
    <span class="keyword">var</span> q = <span class="keyword">this</span>;
    <span class="keyword">var</span> item = {
      prev: q.tail,
      check: <span class="keyword">function</span>() {
        <span class="keyword">if</span> (!q.paused &amp;&amp; !<span class="keyword">this</span>.prev &amp;&amp; <span class="keyword">this</span>.fired){
          callback(<span class="keyword">this</span>.err, <span class="keyword">this</span>.data);
          <span class="keyword">if</span> (<span class="keyword">this</span>.next) {
            <span class="keyword">this</span>.next.prev = <span class="literal">null</span>;
            <span class="keyword">this</span>.next.check();
          }<span class="keyword">else</span>{<span class="comment">//q.tail===this</span>
	    q.tail = <span class="literal">null</span>;
	  }
        }
      }
    };
    <span class="keyword">if</span> (q.tail) {
      q.tail.next = item;
    }
    q.tail = item;
    <span class="keyword">return</span> <span class="keyword">function</span>(err, data) {
      item.fired = <span class="number">1</span>;
      item.err = err;
      item.data = data;
      item.check();
    };
  },
  resume: <span class="keyword">function</span>() {
    <span class="keyword">if</span>(!<span class="keyword">this</span>.paused){
      <span class="keyword">return</span>;
    }
    <span class="keyword">this</span>.paused = <span class="literal">false</span>;
    <span class="keyword">var</span> head = <span class="keyword">this</span>.tail;
    <span class="keyword">while</span>(head &amp;&amp; head.prev){
      head = head.prev;
    }
    <span class="keyword">if</span>(head){
      head.check();
    }
  }
};

core.HTMLDocument = <span class="function"><span class="keyword">function</span> <span class="title">HTMLDocument</span><span class="params">(options)</span> {</span>
  options = options || {};
  <span class="keyword">if</span> (!options.contentType) {
    options.contentType = <span class="string">'text/html'</span>;
  }
  core.Document.call(<span class="keyword">this</span>, options);
  <span class="keyword">this</span>._referrer = options.referrer;
  <span class="keyword">this</span>._cookie = options.cookie;
  <span class="keyword">this</span>._URL = options.url || <span class="string">'/'</span>;
  <span class="keyword">this</span>._documentRoot = options.documentRoot || Path.dirname(<span class="keyword">this</span>._URL);
  <span class="keyword">this</span>._queue = <span class="keyword">new</span> ResourceQueue(options.deferClose);
  <span class="keyword">this</span>.readyState = <span class="string">'loading'</span>;

  <span class="comment">// Add level2 features</span>
  <span class="keyword">this</span>.implementation.addFeature(<span class="string">'core'</span>  , <span class="string">'2.0'</span>);
  <span class="keyword">this</span>.implementation.addFeature(<span class="string">'html'</span>  , <span class="string">'2.0'</span>);
  <span class="keyword">this</span>.implementation.addFeature(<span class="string">'xhtml'</span> , <span class="string">'2.0'</span>);
  <span class="keyword">this</span>.implementation.addFeature(<span class="string">'xml'</span>   , <span class="string">'2.0'</span>);
};

core.HTMLDocument.prototype = {
  _referrer : <span class="string">""</span>,
  get referrer() {
    <span class="keyword">return</span> <span class="keyword">this</span>._referrer || <span class="string">''</span>;
  },
  get domain() {
    <span class="keyword">return</span> <span class="string">""</span>;
  },
  _URL : <span class="string">""</span>,
  get URL() {
    <span class="keyword">return</span> <span class="keyword">this</span>._URL;
  },
  get images() {
    <span class="keyword">return</span> <span class="keyword">this</span>.getElementsByTagName(<span class="string">'IMG'</span>);
  },
  get applets() {
    <span class="keyword">return</span> <span class="keyword">new</span> core.HTMLCollection(<span class="keyword">this</span>, core.mapper(<span class="keyword">this</span>, <span class="keyword">function</span>(el) {
      <span class="keyword">if</span> (el &amp;&amp; el.tagName) {
        <span class="keyword">var</span> upper = el.tagName.toUpperCase();
        <span class="keyword">if</span> (upper === <span class="string">"APPLET"</span>) {
          <span class="keyword">return</span> <span class="literal">true</span>;
        } <span class="keyword">else</span> <span class="keyword">if</span> (upper === <span class="string">"OBJECT"</span> &amp;&amp;
          el.getElementsByTagName(<span class="string">'APPLET'</span>).length > <span class="number">0</span>)
        {
          <span class="keyword">return</span> <span class="literal">true</span>;
        }
      }
    }));
  },
  get links() {
    <span class="keyword">return</span> <span class="keyword">new</span> core.HTMLCollection(<span class="keyword">this</span>, core.mapper(<span class="keyword">this</span>, <span class="keyword">function</span>(el) {
      <span class="keyword">if</span> (el &amp;&amp; el.tagName) {
        <span class="keyword">var</span> upper = el.tagName.toUpperCase();
        <span class="keyword">if</span> (upper === <span class="string">"AREA"</span> || (upper === <span class="string">"A"</span> &amp;&amp; el.href)) {
          <span class="keyword">return</span> <span class="literal">true</span>;
        }
      }
    }));
  },
  get forms() {
    <span class="keyword">return</span> <span class="keyword">this</span>.getElementsByTagName(<span class="string">'FORM'</span>);
  },
  get anchors() {
    <span class="keyword">return</span> <span class="keyword">this</span>.getElementsByTagName(<span class="string">'A'</span>);
  },
  open  : <span class="keyword">function</span>() {
    <span class="keyword">this</span>._childNodes = [];
    <span class="keyword">this</span>._documentElement = <span class="literal">null</span>;
    <span class="keyword">this</span>._modified();
  },
  close : <span class="keyword">function</span>() {
    <span class="keyword">this</span>._queue.resume();
    <span class="comment">// Set the readyState to 'complete' once all resources are loaded.</span>
    <span class="comment">// As a side-effect the document's load-event will be dispatched.</span>
    core.resourceLoader.enqueue(<span class="keyword">this</span>, <span class="keyword">function</span>() {
      <span class="keyword">this</span>.readyState = <span class="string">'complete'</span>;
      <span class="keyword">var</span> ev = <span class="keyword">this</span>.createEvent(<span class="string">'HTMLEvents'</span>);
      ev.initEvent(<span class="string">'DOMContentLoaded'</span>, <span class="literal">false</span>, <span class="literal">false</span>);
      <span class="keyword">this</span>.dispatchEvent(ev);
    })(<span class="literal">null</span>, <span class="literal">true</span>);
  },

  write : <span class="keyword">function</span>(text) {
    <span class="keyword">if</span> (<span class="keyword">this</span>.readyState === <span class="string">"loading"</span>) {
      <span class="comment">// During page loading, document.write appends to the current element</span>
      <span class="comment">// Find the last child that has been added to the document.</span>
      <span class="keyword">var</span> node = <span class="keyword">this</span>;
      <span class="keyword">while</span> (node.lastChild &amp;&amp; node.lastChild.nodeType === <span class="keyword">this</span>.ELEMENT_NODE) {
        node = node.lastChild;
      }
      node.innerHTML = text;
    } <span class="keyword">else</span> {
      <span class="keyword">this</span>.innerHTML = text;
    }
  },

  writeln : <span class="keyword">function</span>(text) {
    <span class="keyword">this</span>.write(text + <span class="string">'\n'</span>);
  },

  getElementsByName : <span class="keyword">function</span>(elementName) {
    <span class="keyword">return</span> <span class="keyword">new</span> core.HTMLCollection(<span class="keyword">this</span>, core.mapper(<span class="keyword">this</span>, <span class="keyword">function</span>(el) {
      <span class="keyword">return</span> (el.getAttribute &amp;&amp; el.getAttribute(<span class="string">"name"</span>) === elementName);
    }));
  },

  get title() {
    <span class="keyword">var</span> head = <span class="keyword">this</span>.head,
      title = head ? firstChild(head, <span class="string">'TITLE'</span>) : <span class="literal">null</span>;
    <span class="keyword">return</span> title ? title.textContent : <span class="string">''</span>;
  },

  set title(val) {
    <span class="keyword">var</span> title = firstChild(<span class="keyword">this</span>.head, <span class="string">'TITLE'</span>);
    <span class="keyword">if</span> (!title) {
      title = <span class="keyword">this</span>.createElement(<span class="string">'TITLE'</span>);
      <span class="keyword">var</span> head = <span class="keyword">this</span>.head;
      <span class="keyword">if</span> (!head) {
        head = <span class="keyword">this</span>.createElement(<span class="string">'HEAD'</span>);
        <span class="keyword">this</span>.documentElement.insertBefore(head, <span class="keyword">this</span>.documentElement.firstChild);
      }
      head.appendChild(title);
    }
    title.textContent = val;
  },

  get head() {
    <span class="keyword">return</span> firstChild(<span class="keyword">this</span>.documentElement, <span class="string">'HEAD'</span>);
  },

  set head() { <span class="comment">/* noop */</span> },

  get body() {
    <span class="keyword">var</span> body = firstChild(<span class="keyword">this</span>.documentElement, <span class="string">'BODY'</span>);
    <span class="keyword">if</span> (!body) {
      body = firstChild(<span class="keyword">this</span>.documentElement, <span class="string">'FRAMESET'</span>);
    }
    <span class="keyword">return</span> body;
  },

  get documentElement() {
    <span class="keyword">if</span> (!<span class="keyword">this</span>._documentElement) {
      <span class="keyword">this</span>._documentElement = firstChild(<span class="keyword">this</span>, <span class="string">'HTML'</span>);
    }
    <span class="keyword">return</span> <span class="keyword">this</span>._documentElement;
  },

  _cookie : <span class="string">""</span>,
  get cookie() { <span class="keyword">return</span> <span class="keyword">this</span>._cookie || <span class="string">''</span>; },
  set cookie(val) { <span class="keyword">this</span>._cookie = val; }
};
core.HTMLDocument.prototype.__proto__ = core.Document.prototype;

define(<span class="string">'HTMLElement'</span>, {
  parentClass: core.Element,
  proto : {
    <span class="comment">// Add default event behavior (click link to navigate, click button to submit</span>
    <span class="comment">// form, etc). We start by wrapping dispatchEvent so we can forward events to</span>
    <span class="comment">// the element's _eventDefault function (only events that did not incur</span>
    <span class="comment">// preventDefault).</span>
    dispatchEvent : <span class="function"><span class="keyword">function</span> <span class="params">(event)</span> {</span>
      <span class="keyword">var</span> outcome = core.Node.prototype.dispatchEvent.call(<span class="keyword">this</span>, event)

      <span class="keyword">if</span> (!event._preventDefault     &amp;&amp;
          event.target._eventDefaults[event.type] &amp;&amp;
          <span class="keyword">typeof</span> event.target._eventDefaults[event.type] === <span class="string">'function'</span>)
      {
        event.target._eventDefaults[event.type](event)
      }
      <span class="keyword">return</span> outcome;
    },
    _eventDefaults : {}
  },
  attributes: [
    <span class="string">'id'</span>,
    <span class="string">'title'</span>,
    <span class="string">'lang'</span>,
    <span class="string">'dir'</span>,
    {prop: <span class="string">'className'</span>, attr: <span class="string">'class'</span>, normalize: <span class="keyword">function</span>(s) { <span class="keyword">return</span> s || <span class="string">''</span>; }}
  ]
});

core.Document.prototype._defaultElementBuilder = <span class="keyword">function</span>(document, tagName) {
  <span class="keyword">return</span> <span class="keyword">new</span> core.HTMLElement(document, tagName);
};

<span class="comment">//http://www.w3.org/TR/html5/forms.html#category-listed</span>
<span class="keyword">var</span> listedElements = <span class="regexp">/button|fieldset|input|keygen|object|select|textarea/i</span>;

define(<span class="string">'HTMLFormElement'</span>, {
  tagName: <span class="string">'FORM'</span>,
  proto: {
    get elements() {
      <span class="keyword">return</span> <span class="keyword">new</span> core.HTMLCollection(<span class="keyword">this</span>._ownerDocument, core.mapper(<span class="keyword">this</span>, <span class="keyword">function</span>(e) {
        <span class="keyword">return</span> listedElements.test(e.nodeName) ; <span class="comment">// TODO exclude &lt;input type="image"></span>
      }));
    },
    get length() {
      <span class="keyword">return</span> <span class="keyword">this</span>.elements.length;
    },
    _dispatchSubmitEvent: <span class="keyword">function</span>() {
      <span class="keyword">var</span> ev = <span class="keyword">this</span>._ownerDocument.createEvent(<span class="string">'HTMLEvents'</span>);
      ev.initEvent(<span class="string">'submit'</span>, <span class="literal">true</span>, <span class="literal">true</span>);
      <span class="keyword">if</span> (!<span class="keyword">this</span>.dispatchEvent(ev)) {
        <span class="keyword">this</span>.submit();
      };
    },
    submit: <span class="keyword">function</span>() {
    },
    reset: <span class="keyword">function</span>() {
      <span class="keyword">this</span>.elements.toArray().forEach(<span class="keyword">function</span>(el) {
        el.value = el.defaultValue;
      });
    }
  },
  attributes: [
    <span class="string">'name'</span>,
    {prop: <span class="string">'acceptCharset'</span>, attr: <span class="string">'accept-charset'</span>},
    <span class="string">'action'</span>,
    <span class="string">'enctype'</span>,
    <span class="string">'method'</span>,
    <span class="string">'target'</span>
  ]
});

define(<span class="string">'HTMLLinkElement'</span>, {
  tagName: <span class="string">'LINK'</span>,
  proto: {
    get href() {
      <span class="keyword">return</span> core.resourceLoader.resolve(<span class="keyword">this</span>._ownerDocument, <span class="keyword">this</span>.getAttribute(<span class="string">'href'</span>));
    }
  },
  attributes: [
    {prop: <span class="string">'disabled'</span>, type: <span class="string">'boolean'</span>},
    <span class="string">'charset'</span>,
    <span class="string">'href'</span>,
    <span class="string">'hreflang'</span>,
    <span class="string">'media'</span>,
    <span class="string">'rel'</span>,
    <span class="string">'rev'</span>,
    <span class="string">'target'</span>,
    <span class="string">'type'</span>
  ]
});

define(<span class="string">'HTMLMetaElement'</span>, {
  tagName: <span class="string">'META'</span>,
  attributes: [
    <span class="string">'content'</span>,
    {prop: <span class="string">'httpEquiv'</span>, attr: <span class="string">'http-equiv'</span>},
    <span class="string">'name'</span>,
    <span class="string">'scheme'</span>
  ]
});

define(<span class="string">'HTMLHtmlElement'</span>, {
  tagName: <span class="string">'HTML'</span>,
  attributes: [
    <span class="string">'version'</span>
  ]
});

define(<span class="string">'HTMLHeadElement'</span>, {
  tagName: <span class="string">'HEAD'</span>,
  attributes: [
    <span class="string">'profile'</span>
  ]
});

define(<span class="string">'HTMLTitleElement'</span>, {
  tagName: <span class="string">'TITLE'</span>,
  proto: {
    get text() {
      <span class="keyword">return</span> <span class="keyword">this</span>.innerHTML;
    },
    set text(s) {
      <span class="keyword">this</span>.innerHTML = s;
    }
  }
});

define(<span class="string">'HTMLBaseElement'</span>, {
  tagName: <span class="string">'BASE'</span>,
  attributes: [
    <span class="string">'href'</span>,
    <span class="string">'target'</span>
  ]
});


<span class="comment">//**Deprecated**</span>
define(<span class="string">'HTMLIsIndexElement'</span>, {
  tagName : <span class="string">'ISINDEX'</span>,
  parentClass : core.Element,
  proto : {
    get form() {
      <span class="keyword">return</span> closest(<span class="keyword">this</span>, <span class="string">'FORM'</span>);
    }
  },
  attributes : [
    <span class="string">'prompt'</span>
  ]
});


define(<span class="string">'HTMLStyleElement'</span>, {
  tagName: <span class="string">'STYLE'</span>,
  attributes: [
    {prop: <span class="string">'disabled'</span>, type: <span class="string">'boolean'</span>},
    <span class="string">'media'</span>,
    <span class="string">'type'</span>,
  ]
});

define(<span class="string">'HTMLBodyElement'</span>, {
  proto: (<span class="keyword">function</span>() {
    <span class="keyword">var</span> proto = {};
    <span class="comment">// The body element's "traditional" event handlers are proxied to the</span>
    <span class="comment">// window object.</span>
    <span class="comment">// See: http://dev.w3.org/html5/spec/Overview.html#the-body-element</span>
    [<span class="string">'onafterprint'</span>, <span class="string">'onbeforeprint'</span>, <span class="string">'onbeforeunload'</span>, <span class="string">'onblur'</span>, <span class="string">'onerror'</span>,
     <span class="string">'onfocus'</span>, <span class="string">'onhashchange'</span>, <span class="string">'onload'</span>, <span class="string">'onmessage'</span>, <span class="string">'onoffline'</span>, <span class="string">'ononline'</span>,
     <span class="string">'onpagehide'</span>, <span class="string">'onpageshow'</span>, <span class="string">'onpopstate'</span>, <span class="string">'onresize'</span>, <span class="string">'onscroll'</span>,
     <span class="string">'onstorage'</span>, <span class="string">'onunload'</span>].forEach(<span class="function"><span class="keyword">function</span> <span class="params">(name)</span> {</span>
      proto.__defineSetter__(name, <span class="function"><span class="keyword">function</span> <span class="params">(handler)</span> {</span>
        <span class="keyword">this</span>._ownerDocument.parentWindow[name] = handler;
      });
      proto.__defineGetter__(name, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">return</span> <span class="keyword">this</span>._ownerDocument.parentWindow[name];
      });
    });
    <span class="keyword">return</span> proto;
  })(),
  tagName: <span class="string">'BODY'</span>,
  attributes: [
    <span class="string">'aLink'</span>,
    <span class="string">'background'</span>,
    <span class="string">'bgColor'</span>,
    <span class="string">'link'</span>,
    <span class="string">'text'</span>,
    <span class="string">'vLink'</span>
  ]
});

define(<span class="string">'HTMLSelectElement'</span>, {
  tagName: <span class="string">'SELECT'</span>,
  proto: {
    get options() {
      <span class="keyword">return</span> <span class="keyword">new</span> core.HTMLOptionsCollection(<span class="keyword">this</span>, core.mapper(<span class="keyword">this</span>, <span class="keyword">function</span>(n) {
        <span class="keyword">return</span> n.nodeName === <span class="string">'OPTION'</span>;
      }));
    },

    get length() {
      <span class="keyword">return</span> <span class="keyword">this</span>.options.length;
    },

    get selectedIndex() {
      <span class="keyword">return</span> <span class="keyword">this</span>.options.toArray().reduceRight(<span class="keyword">function</span>(prev, option, i) {
        <span class="keyword">return</span> option.selected ? i : prev;
      }, -<span class="number">1</span>);
    },

    set selectedIndex(index) {
      <span class="keyword">this</span>.options.toArray().forEach(<span class="keyword">function</span>(option, i) {
        option.selected = i === index;
      });
    },

    get value() {
      <span class="keyword">var</span> i = <span class="keyword">this</span>.selectedIndex;
      <span class="keyword">if</span> (<span class="keyword">this</span>.options.length &amp;&amp; (i === -<span class="number">1</span>)) {
        i = <span class="number">0</span>;
      }
      <span class="keyword">if</span> (i === -<span class="number">1</span>) {
        <span class="keyword">return</span> <span class="string">''</span>;
      }
      <span class="keyword">return</span> <span class="keyword">this</span>.options[i].value;
    },

    set value(val) {
      <span class="keyword">var</span> self = <span class="keyword">this</span>;
      <span class="keyword">this</span>.options.toArray().forEach(<span class="keyword">function</span>(option) {
        <span class="keyword">if</span> (option.value === val) {
          option.selected = <span class="literal">true</span>;
        } <span class="keyword">else</span> {
          <span class="keyword">if</span> (!self.hasAttribute(<span class="string">'multiple'</span>)) {
            <span class="comment">// Remove the selected bit from all other options in this group</span>
            <span class="comment">// if the multiple attr is not present on the select</span>
            option.selected = <span class="literal">false</span>;
          }
        }
      });
    },

    get form() {
      <span class="keyword">return</span> closest(<span class="keyword">this</span>, <span class="string">'FORM'</span>);
    },

    get type() {
      <span class="keyword">return</span> <span class="keyword">this</span>.multiple ? <span class="string">'select-multiple'</span> : <span class="string">'select'</span>;
    },

    add: <span class="keyword">function</span>(opt, before) {
      <span class="keyword">if</span> (before) {
        <span class="keyword">this</span>.insertBefore(opt, before);
      }
      <span class="keyword">else</span> {
        <span class="keyword">this</span>.appendChild(opt);
      }
    },

    remove: <span class="keyword">function</span>(index) {
      <span class="keyword">var</span> opts = <span class="keyword">this</span>.options.toArray();
      <span class="keyword">if</span> (index >= <span class="number">0</span> &amp;&amp; index &lt; opts.length) {
        <span class="keyword">var</span> el = opts[index];
        el._parentNode.removeChild(el);
      }
    },

    blur: <span class="keyword">function</span>() {
      <span class="comment">//TODO</span>
    },

    focus: <span class="keyword">function</span>() {
      <span class="comment">//TODO</span>
    }
  },
  attributes: [
    {prop: <span class="string">'disabled'</span>, type: <span class="string">'boolean'</span>},
    {prop: <span class="string">'multiple'</span>, type: <span class="string">'boolean'</span>},
    <span class="string">'name'</span>,
    {prop: <span class="string">'size'</span>, type: <span class="string">'long'</span>},
    {prop: <span class="string">'tabIndex'</span>, type: <span class="string">'long'</span>},
  ]
});

define(<span class="string">'HTMLOptGroupElement'</span>, {
  tagName: <span class="string">'OPTGROUP'</span>,
  attributes: [
    {prop: <span class="string">'disabled'</span>, type: <span class="string">'boolean'</span>},
    <span class="string">'label'</span>
  ]
});

define(<span class="string">'HTMLOptionElement'</span>, {
  tagName: <span class="string">'OPTION'</span>,
  proto: {
    _attrModified: <span class="keyword">function</span>(name, value) {
      <span class="keyword">if</span> (name === <span class="string">'selected'</span>) {
        <span class="keyword">this</span>.selected = <span class="keyword">this</span>.defaultSelected;
      }
      core.HTMLElement.prototype._attrModified.call(<span class="keyword">this</span>, arguments);
    },
    get form() {
      <span class="keyword">return</span> closest(<span class="keyword">this</span>, <span class="string">'FORM'</span>);
    },
    get defaultSelected() {
      <span class="keyword">return</span> !!<span class="keyword">this</span>.getAttribute(<span class="string">'selected'</span>);
    },
    set defaultSelected(s) {
      <span class="keyword">if</span> (s) <span class="keyword">this</span>.setAttribute(<span class="string">'selected'</span>, <span class="string">'selected'</span>);
      <span class="keyword">else</span> <span class="keyword">this</span>.removeAttribute(<span class="string">'selected'</span>);
    },
    get text() {
        <span class="keyword">return</span> (<span class="keyword">this</span>.hasAttribute(<span class="string">'value'</span>)) ? <span class="keyword">this</span>.getAttribute(<span class="string">'value'</span>) : <span class="keyword">this</span>.innerHTML;
    },
    get value() {
        <span class="keyword">return</span> (<span class="keyword">this</span>.hasAttribute(<span class="string">'value'</span>)) ? <span class="keyword">this</span>.getAttribute(<span class="string">'value'</span>) : <span class="keyword">this</span>.innerHTML;
    },
    set value(val) {
      <span class="keyword">this</span>.setAttribute(<span class="string">'value'</span>, val);
    },
    get index() {
      <span class="keyword">return</span> closest(<span class="keyword">this</span>, <span class="string">'SELECT'</span>).options.toArray().indexOf(<span class="keyword">this</span>);
    },
    get selected() {
      <span class="keyword">if</span> (<span class="keyword">this</span>._selected === <span class="literal">undefined</span>) {
        <span class="keyword">this</span>._selected = <span class="keyword">this</span>.defaultSelected;
      }
      <span class="keyword">return</span> <span class="keyword">this</span>._selected;
    },
    set selected(s) {
      <span class="comment">// TODO: The 'selected' content attribute is the initial value of the</span>
      <span class="comment">// IDL attribute, but the IDL attribute should not relfect the content</span>
      <span class="keyword">this</span>._selected = !!s;
      <span class="keyword">if</span> (s) {
        <span class="comment">//Remove the selected bit from all other options in this select</span>
        <span class="keyword">var</span> select = <span class="keyword">this</span>._parentNode;
        <span class="keyword">if</span> (!select) <span class="keyword">return</span>;
        <span class="keyword">if</span> (select.nodeName !== <span class="string">'SELECT'</span>) {
          select = select._parentNode;
          <span class="keyword">if</span> (!select) <span class="keyword">return</span>;
          <span class="keyword">if</span> (select.nodeName !== <span class="string">'SELECT'</span>) <span class="keyword">return</span>;
        }
        <span class="keyword">if</span> (!select.multiple) {
          <span class="keyword">var</span> o = select.options;
          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; o.length; i++) {
            <span class="keyword">if</span> (o[i] !== <span class="keyword">this</span>) {
                o[i].selected = <span class="literal">false</span>;
            }
          }
        }
      }
    }
  },
  attributes: [
    {prop: <span class="string">'disabled'</span>, type: <span class="string">'boolean'</span>},
    <span class="string">'label'</span>
  ]
});

define(<span class="string">'HTMLInputElement'</span>, {
  tagName: <span class="string">'INPUT'</span>,
  proto: {
    _initDefaultValue: <span class="keyword">function</span>() {
      <span class="keyword">if</span> (<span class="keyword">this</span>._defaultValue === <span class="literal">undefined</span>) {
        <span class="keyword">var</span> attr = <span class="keyword">this</span>.getAttributeNode(<span class="string">'value'</span>);
        <span class="keyword">this</span>._defaultValue = attr ? attr.value : <span class="literal">null</span>;
      }
      <span class="keyword">return</span> <span class="keyword">this</span>._defaultValue;
    },
    _initDefaultChecked: <span class="keyword">function</span>() {
      <span class="keyword">if</span> (<span class="keyword">this</span>._defaultChecked === <span class="literal">undefined</span>) {
        <span class="keyword">this</span>._defaultChecked = !!<span class="keyword">this</span>.getAttribute(<span class="string">'checked'</span>);
      }
      <span class="keyword">return</span> <span class="keyword">this</span>._defaultChecked;
    },
    get form() {
      <span class="keyword">return</span> closest(<span class="keyword">this</span>, <span class="string">'FORM'</span>);
    },
    get defaultValue() {
      <span class="keyword">return</span> <span class="keyword">this</span>._initDefaultValue();
    },
    get defaultChecked() {
      <span class="keyword">return</span> <span class="keyword">this</span>._initDefaultChecked();
    },
    get checked() {
      <span class="keyword">return</span> !!<span class="keyword">this</span>.getAttribute(<span class="string">'checked'</span>);
    },
    set checked(checked) {
      <span class="keyword">this</span>._initDefaultChecked();
      <span class="keyword">this</span>.setAttribute(<span class="string">'checked'</span>, checked);
    },
    get value() {
      <span class="keyword">return</span> <span class="keyword">this</span>.getAttribute(<span class="string">'value'</span>);
    },
    set value(val) {
      <span class="keyword">this</span>._initDefaultValue();
      <span class="keyword">if</span> (val === <span class="literal">null</span>) {
        <span class="keyword">this</span>.removeAttribute(<span class="string">'value'</span>);
      }
      <span class="keyword">else</span> {
        <span class="keyword">this</span>.setAttribute(<span class="string">'value'</span>, val);
      }
    },
    blur: <span class="keyword">function</span>() {
    },
    focus: <span class="keyword">function</span>() {
    },
    select: <span class="keyword">function</span>() {
    },
    click: <span class="keyword">function</span>() {
      <span class="keyword">if</span> (<span class="keyword">this</span>.type === <span class="string">'checkbox'</span> || <span class="keyword">this</span>.type === <span class="string">'radio'</span>) {
        <span class="keyword">this</span>.checked = !<span class="keyword">this</span>.checked;
      }
      <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.type === <span class="string">'submit'</span>) {
        <span class="keyword">var</span> form = <span class="keyword">this</span>.form;
        <span class="keyword">if</span> (form) {
          form._dispatchSubmitEvent();
        }
      }
    }
  },
  attributes: [
    <span class="string">'accept'</span>,
    <span class="string">'accessKey'</span>,
    <span class="string">'align'</span>,
    <span class="string">'alt'</span>,
    {prop: <span class="string">'disabled'</span>, type: <span class="string">'boolean'</span>},
    {prop: <span class="string">'maxLength'</span>, type: <span class="string">'long'</span>},
    <span class="string">'name'</span>,
    {prop: <span class="string">'readOnly'</span>, type: <span class="string">'boolean'</span>},
    {prop: <span class="string">'size'</span>, type: <span class="string">'long'</span>},
    <span class="string">'src'</span>,
    {prop: <span class="string">'tabIndex'</span>, type: <span class="string">'long'</span>},
    {prop: <span class="string">'type'</span>, normalize: <span class="keyword">function</span>(val) {
        <span class="keyword">return</span> val ? val.toLowerCase() : <span class="string">'text'</span>;
    }},
    <span class="string">'useMap'</span>
  ]
});

define(<span class="string">'HTMLTextAreaElement'</span>, {
  tagName: <span class="string">'TEXTAREA'</span>,
  proto: {
    _initDefaultValue: <span class="keyword">function</span>() {
      <span class="keyword">if</span> (<span class="keyword">this</span>._defaultValue === <span class="literal">undefined</span>) {
        <span class="keyword">this</span>._defaultValue = <span class="keyword">this</span>.textContent;
      }
      <span class="keyword">return</span> <span class="keyword">this</span>._defaultValue;
    },
    get form() {
      <span class="keyword">return</span> closest(<span class="keyword">this</span>, <span class="string">'FORM'</span>);
    },
    get defaultValue() {
      <span class="keyword">return</span> <span class="keyword">this</span>._initDefaultValue();
    },
    get value() {
      <span class="keyword">return</span> <span class="keyword">this</span>.textContent;
    },
    set value(val) {
      <span class="keyword">this</span>._initDefaultValue();
      <span class="keyword">this</span>.textContent = val;
    },
    get type() {
      <span class="keyword">return</span> <span class="string">'textarea'</span>;
    },
    blur: <span class="keyword">function</span>() {
    },
    focus: <span class="keyword">function</span>() {
    },
    select: <span class="keyword">function</span>() {
    }
  },
  attributes: [
    <span class="string">'accessKey'</span>,
    {prop: <span class="string">'cols'</span>, type: <span class="string">'long'</span>},
    {prop: <span class="string">'disabled'</span>, type: <span class="string">'boolean'</span>},
    {prop: <span class="string">'maxLength'</span>, type: <span class="string">'long'</span>},
    <span class="string">'name'</span>,
    {prop: <span class="string">'readOnly'</span>, type: <span class="string">'boolean'</span>},
    {prop: <span class="string">'rows'</span>, type: <span class="string">'long'</span>},
    {prop: <span class="string">'tabIndex'</span>, type: <span class="string">'long'</span>}
  ]
});

define(<span class="string">'HTMLButtonElement'</span>, {
  tagName: <span class="string">'BUTTON'</span>,
  proto: {
    get form() {
      <span class="keyword">return</span> closest(<span class="keyword">this</span>, <span class="string">'FORM'</span>);
    }
  },
  attributes: [
    <span class="string">'accessKey'</span>,
    {prop: <span class="string">'disabled'</span>, type: <span class="string">'boolean'</span>},
    <span class="string">'name'</span>,
    {prop: <span class="string">'tabIndex'</span>, type: <span class="string">'long'</span>},
    <span class="string">'type'</span>,
    <span class="string">'value'</span>
  ]
});

define(<span class="string">'HTMLLabelElement'</span>, {
  tagName: <span class="string">'LABEL'</span>,
  proto: {
    get form() {
      <span class="keyword">return</span> closest(<span class="keyword">this</span>, <span class="string">'FORM'</span>);
    }
  },
  attributes: [
    <span class="string">'accessKey'</span>,
    {prop: <span class="string">'htmlFor'</span>, attr: <span class="string">'for'</span>}
  ]
});

define(<span class="string">'HTMLFieldSetElement'</span>, {
  tagName: <span class="string">'FIELDSET'</span>,
  proto: {
    get form() {
      <span class="keyword">return</span> closest(<span class="keyword">this</span>, <span class="string">'FORM'</span>);
    }
  }
});

define(<span class="string">'HTMLLegendElement'</span>, {
  tagName: <span class="string">'LEGEND'</span>,
  proto: {
    get form() {
      <span class="keyword">return</span> closest(<span class="keyword">this</span>, <span class="string">'FORM'</span>);
    }
  },
  attributes: [
    <span class="string">'accessKey'</span>,
    <span class="string">'align'</span>
  ]
});

define(<span class="string">'HTMLUListElement'</span>, {
  tagName: <span class="string">'UL'</span>,
  attributes: [
    {prop: <span class="string">'compact'</span>, type: <span class="string">'boolean'</span>},
    <span class="string">'type'</span>
  ]
});

define(<span class="string">'HTMLOListElement'</span>, {
  tagName: <span class="string">'OL'</span>,
  attributes: [
    {prop: <span class="string">'compact'</span>, type: <span class="string">'boolean'</span>},
    {prop: <span class="string">'start'</span>, type: <span class="string">'long'</span>},
    <span class="string">'type'</span>
  ]
});

define(<span class="string">'HTMLDListElement'</span>, {
  tagName: <span class="string">'DL'</span>,
  attributes: [
    {prop: <span class="string">'compact'</span>, type: <span class="string">'boolean'</span>}
  ]
});

define(<span class="string">'HTMLDirectoryElement'</span>, {
  tagName: <span class="string">'DIR'</span>,
  attributes: [
    {prop: <span class="string">'compact'</span>, type: <span class="string">'boolean'</span>}
  ]
});

define(<span class="string">'HTMLMenuElement'</span>, {
  tagName: <span class="string">'MENU'</span>,
  attributes: [
    {prop: <span class="string">'compact'</span>, type: <span class="string">'boolean'</span>}
  ]
});

define(<span class="string">'HTMLLIElement'</span>, {
  tagName: <span class="string">'LI'</span>,
  attributes: [
    <span class="string">'type'</span>,
    {prop: <span class="string">'value'</span>, type: <span class="string">'long'</span>}
  ]
});

define(<span class="string">'HTMLDivElement'</span>, {
  tagName: <span class="string">'DIV'</span>,
  attributes: [
    <span class="string">'align'</span>
  ]
});

define(<span class="string">'HTMLParagraphElement'</span>, {
  tagName: <span class="string">'P'</span>,
  attributes: [
    <span class="string">'align'</span>
  ]
});

define(<span class="string">'HTMLHeadingElement'</span>, {
  tagNames: [<span class="string">'H1'</span>,<span class="string">'H2'</span>,<span class="string">'H3'</span>,<span class="string">'H4'</span>,<span class="string">'H5'</span>,<span class="string">'H6'</span>],
  attributes: [
    <span class="string">'align'</span>
  ]
});

define(<span class="string">'HTMLQuoteElement'</span>, {
  tagNames: [<span class="string">'Q'</span>,<span class="string">'BLOCKQUOTE'</span>],
  attributes: [
    <span class="string">'cite'</span>
  ]
});

define(<span class="string">'HTMLPreElement'</span>, {
  tagName: <span class="string">'PRE'</span>,
  attributes: [
    {prop: <span class="string">'width'</span>, type: <span class="string">'long'</span>}
  ]
});

define(<span class="string">'HTMLBRElement'</span>, {
  tagName: <span class="string">'BR'</span>,
  attributes: [
    <span class="string">'clear'</span>
  ]
});

define(<span class="string">'HTMLBaseFontElement'</span>, {
  tagName: <span class="string">'BASEFONT'</span>,
  attributes: [
    <span class="string">'color'</span>,
    <span class="string">'face'</span>,
    {prop: <span class="string">'size'</span>, type: <span class="string">'long'</span>}
  ]
});

define(<span class="string">'HTMLFontElement'</span>, {
  tagName: <span class="string">'FONT'</span>,
  attributes: [
    <span class="string">'color'</span>,
    <span class="string">'face'</span>,
    <span class="string">'size'</span>
  ]
});

define(<span class="string">'HTMLHRElement'</span>, {
  tagName: <span class="string">'HR'</span>,
  attributes: [
    <span class="string">'align'</span>,
    {prop: <span class="string">'noShade'</span>, type: <span class="string">'boolean'</span>},
    <span class="string">'size'</span>,
    <span class="string">'width'</span>
  ]
});

define(<span class="string">'HTMLModElement'</span>, {
  tagNames: [<span class="string">'INS'</span>, <span class="string">'DEL'</span>],
  attributes: [
    <span class="string">'cite'</span>,
    <span class="string">'dateTime'</span>
  ]
});

define(<span class="string">'HTMLAnchorElement'</span>, {
  tagName: <span class="string">'A'</span>,

  proto: {
    blur: <span class="keyword">function</span>() {
    },
    focus: <span class="keyword">function</span>() {
    },
    get href() {
      <span class="keyword">return</span> core.resourceLoader.resolve(<span class="keyword">this</span>._ownerDocument, <span class="keyword">this</span>.getAttribute(<span class="string">'href'</span>));
    }
  },
  attributes: [
    <span class="string">'accessKey'</span>,
    <span class="string">'charset'</span>,
    <span class="string">'coords'</span>,
    {prop: <span class="string">'href'</span>, type: <span class="string">'string'</span>, read: <span class="literal">false</span>},
    <span class="string">'hreflang'</span>,
    <span class="string">'name'</span>,
    <span class="string">'rel'</span>,
    <span class="string">'rev'</span>,
    <span class="string">'shape'</span>,
    {prop: <span class="string">'tabIndex'</span>, type: <span class="string">'long'</span>},
    <span class="string">'target'</span>,
    <span class="string">'type'</span>
  ]
});

define(<span class="string">'HTMLImageElement'</span>, {
  tagName: <span class="string">'IMG'</span>,
  attributes: [
    <span class="string">'name'</span>,
    <span class="string">'align'</span>,
    <span class="string">'alt'</span>,
    <span class="string">'border'</span>,
    {prop: <span class="string">'height'</span>, type: <span class="string">'long'</span>},
    {prop: <span class="string">'hspace'</span>, type: <span class="string">'long'</span>},
    {prop: <span class="string">'isMap'</span>, type: <span class="string">'boolean'</span>},
    <span class="string">'longDesc'</span>,
    <span class="string">'src'</span>,
    <span class="string">'useMap'</span>,
    {prop: <span class="string">'vspace'</span>, type: <span class="string">'long'</span>},
    {prop: <span class="string">'width'</span>, type: <span class="string">'long'</span>}
  ]
});

define(<span class="string">'HTMLObjectElement'</span>, {
  tagName: <span class="string">'OBJECT'</span>,
  proto: {
    get form() {
      <span class="keyword">return</span> closest(<span class="keyword">this</span>, <span class="string">'FORM'</span>);
    },
    get contentDocument() {
      <span class="keyword">return</span> <span class="literal">null</span>;
    }
  },
  attributes: [
    <span class="string">'code'</span>,
    <span class="string">'align'</span>,
    <span class="string">'archive'</span>,
    <span class="string">'border'</span>,
    <span class="string">'codeBase'</span>,
    <span class="string">'codeType'</span>,
    <span class="string">'data'</span>,
    {prop: <span class="string">'declare'</span>, type: <span class="string">'boolean'</span>},
    {prop: <span class="string">'height'</span>,  type: <span class="string">'long'</span>},
    {prop: <span class="string">'hspace'</span>,  type: <span class="string">'long'</span>},
    <span class="string">'name'</span>,
    <span class="string">'standby'</span>,
    {prop: <span class="string">'tabIndex'</span>, type: <span class="string">'long'</span>},
    <span class="string">'type'</span>,
    <span class="string">'useMap'</span>,
    {prop: <span class="string">'vspace'</span>, type: <span class="string">'long'</span>},
    {prop: <span class="string">'width'</span>, type: <span class="string">'long'</span>}
  ]
});

define(<span class="string">'HTMLParamElement'</span>, {
  tagName: <span class="string">'PARAM'</span>,
  attributes: [
    <span class="string">'name'</span>,
    <span class="string">'type'</span>,
    <span class="string">'value'</span>,
    <span class="string">'valueType'</span>
  ]
});

define(<span class="string">'HTMLAppletElement'</span>, {
  tagName: <span class="string">'APPLET'</span>,
  attributes: [
    <span class="string">'align'</span>,
    <span class="string">'alt'</span>,
    <span class="string">'archive'</span>,
    <span class="string">'code'</span>,
    <span class="string">'codeBase'</span>,
    <span class="string">'height'</span>,
    {prop: <span class="string">'hspace'</span>, type: <span class="string">'long'</span>},
    <span class="string">'name'</span>,
    <span class="string">'object'</span>,
    {prop: <span class="string">'vspace'</span>, type: <span class="string">'long'</span>},
    <span class="string">'width'</span>
  ]
});

define(<span class="string">'HTMLMapElement'</span>, {
  tagName: <span class="string">'MAP'</span>,
  proto: {
    get areas() {
      <span class="keyword">return</span> <span class="keyword">this</span>.getElementsByTagName(<span class="string">"AREA"</span>);
    }
  },
  attributes: [
    <span class="string">'name'</span>
  ]
});

define(<span class="string">'HTMLAreaElement'</span>, {
  tagName: <span class="string">'AREA'</span>,
  attributes: [
    <span class="string">'accessKey'</span>,
    <span class="string">'alt'</span>,
    <span class="string">'coords'</span>,
    <span class="string">'href'</span>,
    {prop: <span class="string">'noHref'</span>, type: <span class="string">'boolean'</span>},
    <span class="string">'shape'</span>,
    {prop: <span class="string">'tabIndex'</span>, type: <span class="string">'long'</span>},
    <span class="string">'target'</span>
  ]
});

define(<span class="string">'HTMLScriptElement'</span>, {
  tagName: <span class="string">'SCRIPT'</span>,
  init: <span class="keyword">function</span>() {
    <span class="keyword">this</span>.addEventListener(<span class="string">'DOMNodeInsertedIntoDocument'</span>, <span class="keyword">function</span>() {
      <span class="keyword">if</span> (<span class="keyword">this</span>.src) {
        core.resourceLoader.load(<span class="keyword">this</span>, <span class="keyword">this</span>.src, <span class="keyword">this</span>._eval);
      }
      <span class="keyword">else</span> {
        <span class="keyword">var</span> src = <span class="keyword">this</span>.sourceLocation || {},
            filename = src.file || <span class="keyword">this</span>._ownerDocument.URL;

        <span class="keyword">if</span> (src) {
          filename += <span class="string">':'</span> + src.line + <span class="string">':'</span> + src.col;
        }
        filename += <span class="string">'&lt;script>'</span>;

        core.resourceLoader.enqueue(<span class="keyword">this</span>, <span class="keyword">this</span>._eval, filename)(<span class="literal">null</span>, <span class="keyword">this</span>.text);
      }
    });
  },
  proto: {
    _eval: <span class="keyword">function</span>(text, filename) {
      <span class="keyword">if</span> (<span class="keyword">this</span>._ownerDocument.implementation.hasFeature(<span class="string">"ProcessExternalResources"</span>, <span class="string">"script"</span>) &amp;&amp;
          <span class="keyword">this</span>.language                                                                      &amp;&amp;
          core.languageProcessors[<span class="keyword">this</span>.language])
      {
        core.languageProcessors[<span class="keyword">this</span>.language](<span class="keyword">this</span>, text, filename);
      }
    },
    get language() {
      <span class="keyword">var</span> type = <span class="keyword">this</span>.type || <span class="string">"text/javascript"</span>;
      <span class="keyword">return</span> type.split(<span class="string">"/"</span>).pop().toLowerCase();
    },
    get text() {
      <span class="keyword">var</span> i=<span class="number">0</span>, children = <span class="keyword">this</span>.childNodes, l = children.length, ret = [];

      <span class="keyword">for</span> (i; i&lt;l; i++) {
        ret.push(children.item(i).value);
      }

      <span class="keyword">return</span> ret.join(<span class="string">""</span>);
    },
    set text(text) {
      <span class="keyword">while</span> (<span class="keyword">this</span>.childNodes.length) {
        <span class="keyword">this</span>.removeChild(<span class="keyword">this</span>.childNodes[<span class="number">0</span>]);
      }
      <span class="keyword">this</span>.appendChild(<span class="keyword">this</span>._ownerDocument.createTextNode(text));
    }
  },
  attributes : [
    {prop: <span class="string">'defer'</span>, <span class="string">'type'</span>: <span class="string">'boolean'</span>},
    <span class="string">'htmlFor'</span>,
    <span class="string">'event'</span>,
    <span class="string">'charset'</span>,
    <span class="string">'type'</span>,
    <span class="string">'src'</span>
  ]
})

define(<span class="string">'HTMLTableElement'</span>, {
  tagName: <span class="string">'TABLE'</span>,
  proto: {
    get caption() {
      <span class="keyword">return</span> firstChild(<span class="keyword">this</span>, <span class="string">'CAPTION'</span>);
    },
    get tHead() {
      <span class="keyword">return</span> firstChild(<span class="keyword">this</span>, <span class="string">'THEAD'</span>);
    },
    get tFoot() {
      <span class="keyword">return</span> firstChild(<span class="keyword">this</span>, <span class="string">'TFOOT'</span>);
    },
    get rows() {
      <span class="keyword">if</span> (!<span class="keyword">this</span>._rows) {
        <span class="keyword">var</span> table = <span class="keyword">this</span>;
        <span class="keyword">this</span>._rows = <span class="keyword">new</span> core.HTMLCollection(<span class="keyword">this</span>._ownerDocument, <span class="keyword">function</span>() {
          <span class="keyword">var</span> sections = [table.tHead].concat(table.tBodies.toArray(), table.tFoot).filter(<span class="keyword">function</span>(s) { <span class="keyword">return</span> !!s });

          <span class="keyword">if</span> (sections.length === <span class="number">0</span>) {
            <span class="keyword">return</span> core.mapDOMNodes(table, <span class="literal">false</span>, <span class="keyword">function</span>(el) {
              <span class="keyword">return</span> el.tagName === <span class="string">'TR'</span>;
            });
          }

          <span class="keyword">return</span> sections.reduce(<span class="keyword">function</span>(prev, s) {
            <span class="keyword">return</span> prev.concat(s.rows.toArray());
          }, []);

        });
      }
      <span class="keyword">return</span> <span class="keyword">this</span>._rows;
    },
    get tBodies() {
      <span class="keyword">if</span> (!<span class="keyword">this</span>._tBodies) {
        <span class="keyword">this</span>._tBodies = descendants(<span class="keyword">this</span>, <span class="string">'TBODY'</span>, <span class="literal">false</span>);
      }
      <span class="keyword">return</span> <span class="keyword">this</span>._tBodies;
    },
    createTHead: <span class="keyword">function</span>() {
      <span class="keyword">var</span> el = <span class="keyword">this</span>.tHead;
      <span class="keyword">if</span> (!el) {
        el = <span class="keyword">this</span>._ownerDocument.createElement(<span class="string">'THEAD'</span>);
        <span class="keyword">this</span>.appendChild(el);
      }
      <span class="keyword">return</span> el;
    },
    deleteTHead: <span class="keyword">function</span>() {
      <span class="keyword">var</span> el = <span class="keyword">this</span>.tHead;
      <span class="keyword">if</span> (el) {
        el._parentNode.removeChild(el);
      }
    },
    createTFoot: <span class="keyword">function</span>() {
      <span class="keyword">var</span> el = <span class="keyword">this</span>.tFoot;
      <span class="keyword">if</span> (!el) {
        el = <span class="keyword">this</span>._ownerDocument.createElement(<span class="string">'TFOOT'</span>);
        <span class="keyword">this</span>.appendChild(el);
      }
      <span class="keyword">return</span> el;
    },
    deleteTFoot: <span class="keyword">function</span>() {
      <span class="keyword">var</span> el = <span class="keyword">this</span>.tFoot;
      <span class="keyword">if</span> (el) {
        el._parentNode.removeChild(el);
      }
    },
    createCaption: <span class="keyword">function</span>() {
      <span class="keyword">var</span> el = <span class="keyword">this</span>.caption;
      <span class="keyword">if</span> (!el) {
        el = <span class="keyword">this</span>._ownerDocument.createElement(<span class="string">'CAPTION'</span>);
        <span class="keyword">this</span>.appendChild(el);
      }
      <span class="keyword">return</span> el;
    },
    deleteCaption: <span class="keyword">function</span>() {
      <span class="keyword">var</span> c = <span class="keyword">this</span>.caption;
      <span class="keyword">if</span> (c) {
        c._parentNode.removeChild(c);
      }
    },
    insertRow: <span class="keyword">function</span>(index) {
      <span class="keyword">var</span> tr = <span class="keyword">this</span>._ownerDocument.createElement(<span class="string">'TR'</span>);
      <span class="keyword">if</span> (<span class="keyword">this</span>.childNodes.length === <span class="number">0</span>) {
        <span class="keyword">this</span>.appendChild(<span class="keyword">this</span>._ownerDocument.createElement(<span class="string">'TBODY'</span>));
      }
      <span class="keyword">var</span> rows = <span class="keyword">this</span>.rows.toArray();
      <span class="keyword">if</span> (index &lt; -<span class="number">1</span> || index > rows.length) {
        <span class="keyword">throw</span> <span class="keyword">new</span> core.DOMException(core.INDEX_SIZE_ERR);
      }
      <span class="keyword">if</span> (index === -<span class="number">1</span> || (index === <span class="number">0</span> &amp;&amp; rows.length === <span class="number">0</span>)) {
        <span class="keyword">this</span>.tBodies.item(<span class="number">0</span>).appendChild(tr);
      }
      <span class="keyword">else</span> <span class="keyword">if</span> (index === rows.length) {
        <span class="keyword">var</span> ref = rows[index-<span class="number">1</span>];
        ref._parentNode.appendChild(tr);
      }
      <span class="keyword">else</span> {
        <span class="keyword">var</span> ref = rows[index];
        ref._parentNode.insertBefore(tr, ref);
      }
      <span class="keyword">return</span> tr;
    },
    deleteRow: <span class="keyword">function</span>(index) {
      <span class="keyword">var</span> rows = <span class="keyword">this</span>.rows.toArray(), l = rows.length;
      <span class="keyword">if</span> (index === -<span class="number">1</span>) {
        index = l-<span class="number">1</span>;
      }
      <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index >= l) {
        <span class="keyword">throw</span> <span class="keyword">new</span> core.DOMException(core.INDEX_SIZE_ERR);
      }
      <span class="keyword">var</span> tr = rows[index];
      tr._parentNode.removeChild(tr);
    }
  },
  attributes: [
    <span class="string">'align'</span>,
    <span class="string">'bgColor'</span>,
    <span class="string">'border'</span>,
    <span class="string">'cellPadding'</span>,
    <span class="string">'cellSpacing'</span>,
    <span class="string">'frame'</span>,
    <span class="string">'rules'</span>,
    <span class="string">'summary'</span>,
    <span class="string">'width'</span>
  ]
});

define(<span class="string">'HTMLTableCaptionElement'</span>, {
  tagName: <span class="string">'CAPTION'</span>,
  attributes: [
    <span class="string">'align'</span>
  ]
});

define(<span class="string">'HTMLTableColElement'</span>, {
  tagNames: [<span class="string">'COL'</span>,<span class="string">'COLGROUP'</span>],
  attributes: [
    <span class="string">'align'</span>,
    {prop: <span class="string">'ch'</span>, attr: <span class="string">'char'</span>},
    {prop: <span class="string">'chOff'</span>, attr: <span class="string">'charoff'</span>},
    {prop: <span class="string">'span'</span>, type: <span class="string">'long'</span>},
    <span class="string">'vAlign'</span>,
    <span class="string">'width'</span>,
  ]
});

define(<span class="string">'HTMLTableSectionElement'</span>, {
  tagNames: [<span class="string">'THEAD'</span>,<span class="string">'TBODY'</span>,<span class="string">'TFOOT'</span>],
  proto: {
    get rows() {
      <span class="keyword">if</span> (!<span class="keyword">this</span>._rows) {
        <span class="keyword">this</span>._rows = descendants(<span class="keyword">this</span>, <span class="string">'TR'</span>, <span class="literal">false</span>);
      }
      <span class="keyword">return</span> <span class="keyword">this</span>._rows;
    },
    insertRow: <span class="keyword">function</span>(index) {
      <span class="keyword">var</span> tr = <span class="keyword">this</span>._ownerDocument.createElement(<span class="string">'TR'</span>);
      <span class="keyword">var</span> rows = <span class="keyword">this</span>.rows.toArray();
      <span class="keyword">if</span> (index &lt; -<span class="number">1</span> || index > rows.length) {
        <span class="keyword">throw</span> <span class="keyword">new</span> core.DOMException(core.INDEX_SIZE_ERR);
      }
      <span class="keyword">if</span> (index === -<span class="number">1</span> || index === rows.length) {
        <span class="keyword">this</span>.appendChild(tr);
      }
      <span class="keyword">else</span> {
        <span class="keyword">var</span> ref = rows[index];
        <span class="keyword">this</span>.insertBefore(tr, ref);
      }
      <span class="keyword">return</span> tr;
    },
    deleteRow: <span class="keyword">function</span>(index) {
      <span class="keyword">var</span> rows = <span class="keyword">this</span>.rows.toArray();
      <span class="keyword">if</span> (index === -<span class="number">1</span>) {
        index = rows.length-<span class="number">1</span>;
      }
      <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index >= rows.length) {
        <span class="keyword">throw</span> <span class="keyword">new</span> core.DOMException(core.INDEX_SIZE_ERR);
      }
      <span class="keyword">var</span> tr = <span class="keyword">this</span>.rows[index];
      <span class="keyword">this</span>.removeChild(tr);
    }
  },
  attributes: [
    <span class="string">'align'</span>,
    {prop: <span class="string">'ch'</span>, attr: <span class="string">'char'</span>},
    {prop: <span class="string">'chOff'</span>, attr: <span class="string">'charoff'</span>},
    {prop: <span class="string">'span'</span>, type: <span class="string">'long'</span>},
    <span class="string">'vAlign'</span>,
    <span class="string">'width'</span>,
  ]
});

define(<span class="string">'HTMLTableRowElement'</span>, {
  tagName: <span class="string">'TR'</span>,
  proto: {
    get cells() {
      <span class="keyword">if</span> (!<span class="keyword">this</span>._cells) {
        <span class="keyword">this</span>._cells = <span class="keyword">new</span> core.HTMLCollection(<span class="keyword">this</span>, core.mapper(<span class="keyword">this</span>, <span class="keyword">function</span>(n) {
          <span class="keyword">return</span> n.nodeName === <span class="string">'TD'</span> || n.nodeName === <span class="string">'TH'</span>;
        }, <span class="literal">false</span>));
      }
      <span class="keyword">return</span> <span class="keyword">this</span>._cells;
    },
    get rowIndex() {
      <span class="keyword">return</span> closest(<span class="keyword">this</span>, <span class="string">'TABLE'</span>).rows.toArray().indexOf(<span class="keyword">this</span>);
    },

    get sectionRowIndex() {
      <span class="keyword">return</span> <span class="keyword">this</span>._parentNode.rows.toArray().indexOf(<span class="keyword">this</span>);
    },
    insertCell: <span class="keyword">function</span>(index) {
      <span class="keyword">var</span> td = <span class="keyword">this</span>._ownerDocument.createElement(<span class="string">'TD'</span>);
      <span class="keyword">var</span> cells = <span class="keyword">this</span>.cells.toArray();
      <span class="keyword">if</span> (index &lt; -<span class="number">1</span> || index > cells.length) {
        <span class="keyword">throw</span> <span class="keyword">new</span> core.DOMException(core.INDEX_SIZE_ERR);
      }
      <span class="keyword">if</span> (index === -<span class="number">1</span> || index === cells.length) {
        <span class="keyword">this</span>.appendChild(td);
      }
      <span class="keyword">else</span> {
        <span class="keyword">var</span> ref = cells[index];
        <span class="keyword">this</span>.insertBefore(td, ref);
      }
      <span class="keyword">return</span> td;
    },
    deleteCell: <span class="keyword">function</span>(index) {
      <span class="keyword">var</span> cells = <span class="keyword">this</span>.cells.toArray();
      <span class="keyword">if</span> (index === -<span class="number">1</span>) {
        index = cells.length-<span class="number">1</span>;
      }
      <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index >= cells.length) {
        <span class="keyword">throw</span> <span class="keyword">new</span> core.DOMException(core.INDEX_SIZE_ERR);
      }
      <span class="keyword">var</span> td = <span class="keyword">this</span>.cells[index];
      <span class="keyword">this</span>.removeChild(td);
    }
  },
  attributes: [
    <span class="string">'align'</span>,
    <span class="string">'bgColor'</span>,
    {prop: <span class="string">'ch'</span>, attr: <span class="string">'char'</span>},
    {prop: <span class="string">'chOff'</span>, attr: <span class="string">'charoff'</span>},
    <span class="string">'vAlign'</span>
  ]
});

define(<span class="string">'HTMLTableCellElement'</span>, {
  tagNames: [<span class="string">'TH'</span>,<span class="string">'TD'</span>],
  proto: {
    _headers: <span class="literal">null</span>,
    set headers(h) {
      <span class="keyword">if</span> (h === <span class="string">''</span>) {
        <span class="comment">//Handle resetting headers so the dynamic getter returns a query</span>
        <span class="keyword">this</span>._headers = <span class="literal">null</span>;
        <span class="keyword">return</span>;
      }
      <span class="keyword">if</span> (!(h <span class="keyword">instanceof</span> Array)) {
        h = [h];
      }
      <span class="keyword">this</span>._headers = h;
    },
    get headers() {
      <span class="keyword">if</span> (<span class="keyword">this</span>._headers) {
        <span class="keyword">return</span> <span class="keyword">this</span>._headers.join(<span class="string">' '</span>);
      }
      <span class="keyword">var</span> cellIndex = <span class="keyword">this</span>.cellIndex,
          headings  = [],
          siblings  = <span class="keyword">this</span>._parentNode.getElementsByTagName(<span class="keyword">this</span>.tagName);

      <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;siblings.length; i++) {
        <span class="keyword">if</span> (siblings.item(i).cellIndex >= cellIndex) {
          <span class="keyword">break</span>;
        }
        headings.push(siblings.item(i).id);
      }
      <span class="keyword">this</span>._headers = headings;
      <span class="keyword">return</span> headings.join(<span class="string">' '</span>);
    },
    get cellIndex() {
      <span class="keyword">return</span> closest(<span class="keyword">this</span>, <span class="string">'TR'</span>).cells.toArray().indexOf(<span class="keyword">this</span>);
    }
  },
  attributes: [
    <span class="string">'abbr'</span>,
    <span class="string">'align'</span>,
    <span class="string">'axis'</span>,
    <span class="string">'bgColor'</span>,
    {prop: <span class="string">'ch'</span>, attr: <span class="string">'char'</span>},
    {prop: <span class="string">'chOff'</span>, attr: <span class="string">'charoff'</span>},
    {prop: <span class="string">'colSpan'</span>, type: <span class="string">'long'</span>},
    <span class="string">'height'</span>,
    {prop: <span class="string">'noWrap'</span>, type: <span class="string">'boolean'</span>},
    {prop: <span class="string">'rowSpan'</span>, type: <span class="string">'long'</span>},
    <span class="string">'scope'</span>,
    <span class="string">'vAlign'</span>,
    <span class="string">'width'</span>
  ]
});

define(<span class="string">'HTMLFrameSetElement'</span>, {
  tagName: <span class="string">'FRAMESET'</span>,
  attributes: [
    <span class="string">'cols'</span>,
    <span class="string">'rows'</span>
  ]
});

<span class="function"><span class="keyword">function</span> <span class="title">loadFrame</span> <span class="params">(frame)</span> {</span>
  <span class="keyword">if</span> (frame._contentDocument) {
    <span class="comment">// We don't want to access document.parentWindow, since the getter will</span>
    <span class="comment">// cause a new window to be allocated if it doesn't exist.  Probe the</span>
    <span class="comment">// private variable instead.</span>
    <span class="keyword">if</span> (frame._contentDocument._parentWindow) {
      <span class="comment">// close calls delete on its document.</span>
      frame._contentDocument.parentWindow.close();
    } <span class="keyword">else</span> {
      <span class="keyword">delete</span> frame._contentDocument;
    }
  }

  <span class="keyword">var</span> src = frame.src;
  <span class="keyword">var</span> parentDoc = frame._ownerDocument;
  <span class="keyword">var</span> url = core.resourceLoader.resolve(parentDoc, src);
  <span class="keyword">var</span> contentDoc = frame._contentDocument = <span class="keyword">new</span> core.HTMLDocument({
    url: url,
    documentRoot: Path.dirname(url)
  });
  applyDocumentFeatures(contentDoc, parentDoc.implementation._features);

  <span class="keyword">var</span> parent = parentDoc.parentWindow;
  <span class="keyword">var</span> contentWindow = contentDoc.parentWindow;
  contentWindow.parent = parent;
  contentWindow.top = parent.top;

  core.resourceLoader.load(frame, url, <span class="keyword">function</span>(html, filename) {
    contentDoc.write(html);
    contentDoc.close();
  });
}

define(<span class="string">'HTMLFrameElement'</span>, {
  tagName: <span class="string">'FRAME'</span>,
  init : <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="comment">// Set up the frames array.  window.frames really just returns a reference</span>
    <span class="comment">// to the window object, so the frames array is just implemented as indexes</span>
    <span class="comment">// on the window.</span>
    <span class="keyword">var</span> parent = <span class="keyword">this</span>._ownerDocument.parentWindow;
    <span class="keyword">var</span> frameID = parent._length++;
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    parent.__defineGetter__(frameID, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
      <span class="keyword">return</span> self.contentWindow;
    });

    <span class="comment">// The contentDocument/contentWindow shouldn't be created until the frame</span>
    <span class="comment">// is inserted:</span>
    <span class="comment">// "When an iframe element is first inserted into a document, the user</span>
    <span class="comment">//  agent must create a nested browsing context, and then process the</span>
    <span class="comment">//  iframe attributes for the first time."</span>
    <span class="comment">//  (http://dev.w3.org/html5/spec/Overview.html#the-iframe-element)</span>
    <span class="keyword">this</span>._initInsertListener = <span class="keyword">this</span>.addEventListener(<span class="string">'DOMNodeInsertedIntoDocument'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
      <span class="keyword">var</span> parentDoc = self._ownerDocument;
      <span class="comment">// Calling contentDocument creates the Document if it doesn't exist.</span>
      <span class="keyword">var</span> doc = self.contentDocument;
      applyDocumentFeatures(doc, parentDoc.implementation._features);
      <span class="keyword">var</span> window = self.contentWindow;
      window.parent = parent;
      window.top = parent.top;
    }, <span class="literal">false</span>);
  },
  proto: {
    setAttribute: <span class="keyword">function</span>(name, value) {
      core.HTMLElement.prototype.setAttribute.call(<span class="keyword">this</span>, name, value);
      <span class="keyword">var</span> self = <span class="keyword">this</span>;
      <span class="keyword">if</span> (name === <span class="string">'name'</span>) {
        <span class="comment">// Set up named frame access.</span>
        <span class="keyword">this</span>._ownerDocument.parentWindow.__defineGetter__(value, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
          <span class="keyword">return</span> self.contentWindow;
        });
      } <span class="keyword">else</span> <span class="keyword">if</span> (name === <span class="string">'src'</span>) {
        <span class="comment">// Page we don't fetch the page until the node is inserted. This at</span>
        <span class="comment">// least seems to be the way Chrome does it.</span>
        <span class="keyword">if</span> (!<span class="keyword">this</span>._attachedToDocument) {
          <span class="keyword">if</span> (!<span class="keyword">this</span>._waitingOnInsert) {
            <span class="comment">// First, remove the listener added in 'init'.</span>
            <span class="keyword">this</span>.removeEventListener(<span class="string">'DOMNodeInsertedIntoDocument'</span>,
                                     <span class="keyword">this</span>._initInsertListener, <span class="literal">false</span>)

            <span class="comment">// If we aren't already waiting on an insert, add a listener.</span>
            <span class="comment">// This guards against src being set multiple times before the frame</span>
            <span class="comment">// is inserted into the document - we don't want to register multiple</span>
            <span class="comment">// callbacks.</span>
            <span class="keyword">this</span>.addEventListener(<span class="string">'DOMNodeInsertedIntoDocument'</span>, <span class="function"><span class="keyword">function</span> <span class="title">loader</span> <span class="params">()</span> {</span>
              self.removeEventListener(<span class="string">'DOMNodeInsertedIntoDocument'</span>, loader, <span class="literal">false</span>);
              <span class="keyword">this</span>._waitingOnInsert = <span class="literal">false</span>;
              loadFrame(self);
            }, <span class="literal">false</span>);
            <span class="keyword">this</span>._waitingOnInsert = <span class="literal">true</span>;
          }
        } <span class="keyword">else</span> {
          loadFrame(self);
        }
      }
    },
    _contentDocument : <span class="literal">null</span>,
    get contentDocument() {
      <span class="keyword">if</span> (<span class="keyword">this</span>._contentDocument == <span class="literal">null</span>) {
        <span class="keyword">this</span>._contentDocument = <span class="keyword">new</span> core.HTMLDocument();
      }
      <span class="keyword">return</span> <span class="keyword">this</span>._contentDocument;
    },
    get contentWindow() {
      <span class="keyword">return</span> <span class="keyword">this</span>.contentDocument.parentWindow;
    }
  },
  attributes: [
    <span class="string">'frameBorder'</span>,
    <span class="string">'longDesc'</span>,
    <span class="string">'marginHeight'</span>,
    <span class="string">'marginWidth'</span>,
    <span class="string">'name'</span>,
    {prop: <span class="string">'noResize'</span>, type: <span class="string">'boolean'</span>},
    <span class="string">'scrolling'</span>,
    {prop: <span class="string">'src'</span>, type: <span class="string">'string'</span>, write: <span class="literal">false</span>}
  ]
});

define(<span class="string">'HTMLIFrameElement'</span>, {
  tagName: <span class="string">'IFRAME'</span>,
  parentClass: core.HTMLFrameElement,
  attributes: [
    <span class="string">'align'</span>,
    <span class="string">'frameBorder'</span>,
    <span class="string">'height'</span>,
    <span class="string">'longDesc'</span>,
    <span class="string">'marginHeight'</span>,
    <span class="string">'marginWidth'</span>,
    <span class="string">'name'</span>,
    <span class="string">'scrolling'</span>,
    <span class="string">'src'</span>,
    <span class="string">'width'</span>
  ]
});

exports.define = define;
exports.dom = {
  level2 : {
    html : core
  }
}

</code></pre>