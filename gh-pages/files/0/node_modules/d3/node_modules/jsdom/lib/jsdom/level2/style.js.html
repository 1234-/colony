<h1>style.js</h1>
<pre><code class="lang-js"><span class="keyword">var</span> core = require(<span class="string">"./core"</span>).dom.level2.core,
    html = require(<span class="string">"./html"</span>).dom.level2.html,
    utils = require(<span class="string">"../utils"</span>),
    cssom = require(<span class="string">"cssom"</span>),
    assert = require(<span class="string">'assert'</span>);

<span class="comment">// What works now:</span>
<span class="comment">// - Accessing the rules defined in individual stylesheets</span>
<span class="comment">// - Modifications to style content attribute are reflected in style property</span>
<span class="comment">// - Modifications to style property are reflected in style content attribute</span>
<span class="comment">// TODO</span>
<span class="comment">// - Modifications to style element's textContent are reflected in sheet property.</span>
<span class="comment">// - Modifications to style element's sheet property are reflected in textContent.</span>
<span class="comment">// - Modifications to link.href property are reflected in sheet property.</span>
<span class="comment">// - Less-used features of link: disabled</span>
<span class="comment">// - Less-used features of style: disabled, scoped, title</span>
<span class="comment">// - CSSOM-View</span>
<span class="comment">//   - getComputedStyle(): requires default stylesheet, cascading, inheritance,</span>
<span class="comment">//     filtering by @media (screen? print?), layout for widths/heights</span>
<span class="comment">// - Load events are not in the specs, but apparently some browsers</span>
<span class="comment">//   implement something. Should onload only fire after all @imports have been</span>
<span class="comment">//   loaded, or only the primary sheet?</span>

core.StyleSheet = cssom.StyleSheet;
core.MediaList = cssom.MediaList;
core.CSSStyleSheet = cssom.CSSStyleSheet;
core.CSSRule = cssom.CSSRule;
core.CSSStyleRule = cssom.CSSStyleRule;
core.CSSMediaRule = cssom.CSSMediaRule;
core.CSSImportRule = cssom.CSSImportRule;
core.CSSStyleDeclaration = cssom.CSSStyleDeclaration;

<span class="comment">// Relavant specs</span>
<span class="comment">// http://www.w3.org/TR/DOM-Level-2-Style (2000)</span>
<span class="comment">// http://www.w3.org/TR/cssom-view/ (2008)</span>
<span class="comment">// http://dev.w3.org/csswg/cssom/ (2010) Meant to replace DOM Level 2 Style</span>
<span class="comment">// http://www.whatwg.org/specs/web-apps/current-work/multipage/ HTML5, of course</span>
<span class="comment">// http://dev.w3.org/csswg/css-style-attr/  not sure what's new here</span>

<span class="comment">// Objects that aren't in cssom library but should be:</span>
<span class="comment">//   CSSRuleList  (cssom just uses array)</span>
<span class="comment">//   CSSFontFaceRule</span>
<span class="comment">//   CSSPageRule</span>

<span class="comment">// These rules don't really make sense to implement, so CSSOM draft makes them</span>
<span class="comment">// obsolete.</span>
<span class="comment">//   CSSCharsetRule</span>
<span class="comment">//   CSSUnknownRule</span>

<span class="comment">// These objects are considered obsolete by CSSOM draft, although modern</span>
<span class="comment">// browsers implement them.</span>
<span class="comment">//   CSSValue</span>
<span class="comment">//   CSSPrimitiveValue</span>
<span class="comment">//   CSSValueList</span>
<span class="comment">//   RGBColor</span>
<span class="comment">//   Rect</span>
<span class="comment">//   Counter</span>

<span class="comment">// StyleSheetList has the same interface as NodeList, so we'll use the same</span>
<span class="comment">// object.</span>
core.StyleSheetList = core.NodeList;

core.Document.prototype.__defineGetter__(<span class="string">'styleSheets'</span>, <span class="keyword">function</span>() {
  <span class="keyword">if</span> (!<span class="keyword">this</span>._styleSheets) {
    <span class="keyword">this</span>._styleSheets = <span class="keyword">new</span> core.StyleSheetList();
  }
  <span class="comment">// TODO: each style and link element should register its sheet on creation</span>
  <span class="comment">// nad remove it on removal.</span>
  <span class="keyword">return</span> <span class="keyword">this</span>._styleSheets;
});


<span class="comment">/**
 * @this {html.HTMLLinkElement|html.HTMLStyleElement}
 * @param {string} url
 * @param {cssom.CSSStyleSheet} sheet
 * @see http://dev.w3.org/csswg/cssom/#requirements-on-user-agents-implementing0
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">fetchStylesheet</span><span class="params">(url, sheet)</span> {</span>
  html.resourceLoader.load(<span class="keyword">this</span>, url, <span class="keyword">function</span>(data, filename) {
    <span class="comment">// TODO: abort if the content-type is not text/css, and the document is</span>
    <span class="comment">// in strict mode</span>
    evaluateStylesheet.call(<span class="keyword">this</span>, data, sheet, url);
  });
}
<span class="comment">/**
 * @this {html.HTMLLinkElement|html.HTMLStyleElement}
 * @param {string} data
 * @param {cssom.CSSStyleSheet} sheet
 * @param {string} baseUrl
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">evaluateStylesheet</span><span class="params">(data, sheet, baseUrl)</span> {</span>
  <span class="comment">// this is the element</span>
  <span class="keyword">var</span> newStyleSheet = cssom.parse(data);
  <span class="keyword">var</span> spliceArgs = newStyleSheet.cssRules;
  spliceArgs.unshift(<span class="number">0</span>, sheet.cssRules.length);
  Array.prototype.splice.apply(sheet.cssRules, spliceArgs);
  scanForImportRules.call(<span class="keyword">this</span>, sheet.cssRules, baseUrl);
}
<span class="comment">/**
 * @this {html.HTMLLinkElement|html.HTMLStyleElement}
 * @param {cssom.CSSStyleSheet} sheet
 * @param {string} baseUrl
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">scanForImportRules</span><span class="params">(cssRules, baseUrl)</span> {</span>
  <span class="keyword">if</span> (!cssRules) <span class="keyword">return</span>;
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; cssRules.length; ++i) {
    <span class="keyword">if</span> (cssRules[i].cssRules) {
      <span class="comment">// @media rule: keep searching inside it.</span>
      scanForImportRules.call(<span class="keyword">this</span>, cssRules[i].cssRules, baseUrl);
    } <span class="keyword">else</span> <span class="keyword">if</span> (cssRules[i].href) {
      <span class="comment">// @import rule: fetch the resource and evaluate it.</span>
      <span class="comment">// See http://dev.w3.org/csswg/cssom/#css-import-rule</span>
      <span class="comment">//     If loading of the style sheet fails its cssRules list is simply</span>
      <span class="comment">//     empty. I.e. an @import rule always has an associated style sheet.</span>
      fetchStylesheet.call(<span class="keyword">this</span>, cssRules[i].href, <span class="keyword">this</span>.sheet);
    }
  }
}

<span class="comment">/**
 * @param {string} data
 * @param {cssom.CSSStyleDeclaration} style
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">evaluateStyleAttribute</span><span class="params">(data)</span> {</span>
  <span class="comment">// this is the element.</span>

  <span class="comment">// currently, cssom's parse doesn't really work if you pass in</span>
  <span class="comment">// {state: 'name'}, so instead we just build a dummy sheet.</span>
  <span class="keyword">var</span> styleSheet = cssom.parse(<span class="string">'dummy{'</span> + data + <span class="string">'}'</span>);
  <span class="keyword">var</span> style = <span class="keyword">this</span>.style;
  <span class="keyword">while</span> (style.length) {
    style.removeProperty(style[<span class="number">0</span>]);
  }
  <span class="keyword">if</span> (styleSheet.cssRules.length > <span class="number">0</span> &amp;&amp; styleSheet.cssRules[<span class="number">0</span>].style) {
    <span class="keyword">var</span> newStyle = styleSheet.cssRules[<span class="number">0</span>].style;
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; newStyle.length; ++i) {
      <span class="keyword">var</span> prop = newStyle[i];
      style.setProperty(
          prop,
          newStyle.getPropertyValue(prop),
          newStyle.getPropertyPriority(prop));
    }
  }
}

<span class="comment">/**
 * Subclass of core.Attr that reflects the current cssText.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">StyleAttr</span><span class="params">(node, value)</span> {</span>
  <span class="keyword">this</span>._node = node;
  core.Attr.call(<span class="keyword">this</span>, node.ownerDocument, <span class="string">'style'</span>);
  <span class="keyword">this</span>.nodeValue = value;
}
StyleAttr.prototype = {
  get nodeValue() {
    <span class="keyword">return</span> <span class="keyword">this</span>._node.style.cssText;
  },
  set nodeValue(value) {
    evaluateStyleAttribute.call(<span class="keyword">this</span>._node, value);
  }
};
StyleAttr.prototype.__proto__ = core.Attr.prototype;

<span class="comment">/**
 * Overwrite core.AttrNodeMap#setNamedItem to create a StyleAttr instance
 * instead of a core.Attr if the name equals 'style'.
 */</span>
utils.intercept(core.AttrNodeMap, <span class="string">'setNamedItem'</span>, <span class="keyword">function</span>(_super, args, attr) {
  <span class="keyword">if</span> (attr.name == <span class="string">'style'</span>) {
    attr = <span class="keyword">new</span> StyleAttr(<span class="keyword">this</span>._parentNode, attr.nodeValue);
  }
  <span class="keyword">return</span> _super.call(<span class="keyword">this</span>, attr);
});

<span class="comment">/**
 * Lazily create a CSSStyleDeclaration.
 */</span>
html.HTMLElement.prototype.__defineGetter__(<span class="string">'style'</span>, <span class="keyword">function</span>() {
  <span class="keyword">var</span> style = <span class="keyword">this</span>._cssStyleDeclaration;
  <span class="keyword">if</span> (!style) {
    style = <span class="keyword">this</span>._cssStyleDeclaration = <span class="keyword">new</span> cssom.CSSStyleDeclaration();
    <span class="keyword">if</span> (!<span class="keyword">this</span>.getAttributeNode(<span class="string">'style'</span>)) {
      <span class="keyword">this</span>.setAttribute(<span class="string">'style'</span>, <span class="string">''</span>);
    }
  }
  <span class="keyword">return</span> style;
});

assert.equal(<span class="literal">undefined</span>, html.HTMLLinkElement._init);
html.HTMLLinkElement._init = <span class="keyword">function</span>() {
  <span class="keyword">this</span>.addEventListener(<span class="string">'DOMNodeInsertedIntoDocument'</span>, <span class="keyword">function</span>() {
    <span class="keyword">if</span> (!<span class="regexp">/(?:[ \t\n\r\f]|^)stylesheet(?:[ \t\n\r\f]|$)/i</span>.test(<span class="keyword">this</span>.rel)) {
      <span class="comment">// rel is a space-separated list of tokens, and the original rel types</span>
      <span class="comment">// are case-insensitive.</span>
      <span class="keyword">return</span>;
    }
    <span class="keyword">if</span> (<span class="keyword">this</span>.href) {
      fetchStylesheet.call(<span class="keyword">this</span>, <span class="keyword">this</span>.href, <span class="keyword">this</span>.sheet);
    }
  });
  <span class="keyword">this</span>.addEventListener(<span class="string">'DOMNodeRemovedFromDocument'</span>, <span class="keyword">function</span>() {
  });
};
<span class="comment">/**
 * @this {HTMLStyleElement|HTMLLinkElement}
 */</span>
<span class="keyword">var</span> getOrCreateSheet = <span class="keyword">function</span>() {
  <span class="keyword">if</span> (!<span class="keyword">this</span>._cssStyleSheet) {
    <span class="keyword">this</span>._cssStyleSheet = <span class="keyword">new</span> cssom.CSSStyleSheet();
  }
  <span class="keyword">return</span> <span class="keyword">this</span>._cssStyleSheet;
};
html.HTMLLinkElement.prototype.__defineGetter__(<span class="string">'sheet'</span>, getOrCreateSheet);

assert.equal(<span class="literal">undefined</span>, html.HTMLStyleElement._init);
html.HTMLStyleElement._init = <span class="keyword">function</span>() {
  <span class="comment">//console.log('init style')</span>
  <span class="keyword">this</span>.addEventListener(<span class="string">'DOMNodeInsertedIntoDocument'</span>, <span class="keyword">function</span>() {
    <span class="comment">//console.log('style inserted')</span>
    <span class="comment">//console.log('sheet: ', this.sheet);</span>
    <span class="keyword">if</span> (<span class="keyword">this</span>.type &amp;&amp; <span class="keyword">this</span>.type !== <span class="string">'text/css'</span>) {
      <span class="comment">//console.log('bad type: ' + this.type)</span>
      <span class="keyword">return</span>;
    }
    evaluateStylesheet.call(<span class="keyword">this</span>, <span class="keyword">this</span>.textContent, <span class="keyword">this</span>.sheet, <span class="keyword">this</span>._ownerDocument.URL);
  });
};
html.HTMLStyleElement.prototype.__defineGetter__(<span class="string">'sheet'</span>, getOrCreateSheet);

exports.dom = {
  level2 : {
    html : html,
    core : core
  }
};
</code></pre>