<h1>async.js</h1>
<pre><code class="lang-js"><span class="comment">/*global setTimeout: false, console: false */</span>
(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>

    <span class="keyword">var</span> async = {};

    <span class="comment">// global on the server, window in the browser</span>
    <span class="keyword">var</span> root = <span class="keyword">this</span>,
        previous_async = root.async;

    <span class="keyword">if</span> (<span class="keyword">typeof</span> module !== <span class="string">'undefined'</span> &amp;&amp; module.exports) {
        module.exports = async;
    }
    <span class="keyword">else</span> {
        root.async = async;
    }

    async.noConflict = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        root.async = previous_async;
        <span class="keyword">return</span> async;
    };

    <span class="comment">//// cross-browser compatiblity functions ////</span>

    <span class="keyword">var</span> _forEach = <span class="function"><span class="keyword">function</span> <span class="params">(arr, iterator)</span> {</span>
        <span class="keyword">if</span> (arr.forEach) {
            <span class="keyword">return</span> arr.forEach(iterator);
        }
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i += <span class="number">1</span>) {
            iterator(arr[i], i, arr);
        }
    };

    <span class="keyword">var</span> _map = <span class="function"><span class="keyword">function</span> <span class="params">(arr, iterator)</span> {</span>
        <span class="keyword">if</span> (arr.map) {
            <span class="keyword">return</span> arr.map(iterator);
        }
        <span class="keyword">var</span> results = [];
        _forEach(arr, <span class="function"><span class="keyword">function</span> <span class="params">(x, i, a)</span> {</span>
            results.push(iterator(x, i, a));
        });
        <span class="keyword">return</span> results;
    };

    <span class="keyword">var</span> _reduce = <span class="function"><span class="keyword">function</span> <span class="params">(arr, iterator, memo)</span> {</span>
        <span class="keyword">if</span> (arr.reduce) {
            <span class="keyword">return</span> arr.reduce(iterator, memo);
        }
        _forEach(arr, <span class="function"><span class="keyword">function</span> <span class="params">(x, i, a)</span> {</span>
            memo = iterator(memo, x, i, a);
        });
        <span class="keyword">return</span> memo;
    };

    <span class="keyword">var</span> _keys = <span class="function"><span class="keyword">function</span> <span class="params">(obj)</span> {</span>
        <span class="keyword">if</span> (Object.keys) {
            <span class="keyword">return</span> Object.keys(obj);
        }
        <span class="keyword">var</span> keys = [];
        <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> obj) {
            <span class="keyword">if</span> (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        <span class="keyword">return</span> keys;
    };

    <span class="comment">//// exported async module functions ////</span>

    <span class="comment">//// nextTick implementation with browser-compatible fallback ////</span>
    <span class="keyword">if</span> (<span class="keyword">typeof</span> process === <span class="string">'undefined'</span> || !(process.nextTick)) {
        async.nextTick = <span class="function"><span class="keyword">function</span> <span class="params">(fn)</span> {</span>
            setTimeout(fn, <span class="number">0</span>);
        };
    }
    <span class="keyword">else</span> {
        async.nextTick = process.nextTick;
    }

    async.forEach = <span class="function"><span class="keyword">function</span> <span class="params">(arr, iterator, callback)</span> {</span>
        callback = callback || <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};
        <span class="keyword">if</span> (!arr.length) {
            <span class="keyword">return</span> callback();
        }
        <span class="keyword">var</span> completed = <span class="number">0</span>;
        _forEach(arr, <span class="function"><span class="keyword">function</span> <span class="params">(x)</span> {</span>
            iterator(x, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
                <span class="keyword">if</span> (err) {
                    callback(err);
                    callback = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};
                }
                <span class="keyword">else</span> {
                    completed += <span class="number">1</span>;
                    <span class="keyword">if</span> (completed === arr.length) {
                        callback(<span class="literal">null</span>);
                    }
                }
            });
        });
    };

    async.forEachSeries = <span class="function"><span class="keyword">function</span> <span class="params">(arr, iterator, callback)</span> {</span>
        callback = callback || <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};
        <span class="keyword">if</span> (!arr.length) {
            <span class="keyword">return</span> callback();
        }
        <span class="keyword">var</span> completed = <span class="number">0</span>;
        <span class="keyword">var</span> iterate = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            iterator(arr[completed], <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
                <span class="keyword">if</span> (err) {
                    callback(err);
                    callback = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};
                }
                <span class="keyword">else</span> {
                    completed += <span class="number">1</span>;
                    <span class="keyword">if</span> (completed === arr.length) {
                        callback(<span class="literal">null</span>);
                    }
                    <span class="keyword">else</span> {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };

    async.forEachLimit = <span class="function"><span class="keyword">function</span> <span class="params">(arr, limit, iterator, callback)</span> {</span>
        callback = callback || <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};
        <span class="keyword">if</span> (!arr.length || limit &lt;= <span class="number">0</span>) {
            <span class="keyword">return</span> callback();
        }
        <span class="keyword">var</span> completed = <span class="number">0</span>;
        <span class="keyword">var</span> started = <span class="number">0</span>;
        <span class="keyword">var</span> running = <span class="number">0</span>;

        (<span class="function"><span class="keyword">function</span> <span class="title">replenish</span> <span class="params">()</span> {</span>
            <span class="keyword">if</span> (completed === arr.length) {
                <span class="keyword">return</span> callback();
            }

            <span class="keyword">while</span> (running &lt; limit &amp;&amp; started &lt; arr.length) {
                started += <span class="number">1</span>;
                running += <span class="number">1</span>;
                iterator(arr[started - <span class="number">1</span>], <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
                    <span class="keyword">if</span> (err) {
                        callback(err);
                        callback = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};
                    }
                    <span class="keyword">else</span> {
                        completed += <span class="number">1</span>;
                        running -= <span class="number">1</span>;
                        <span class="keyword">if</span> (completed === arr.length) {
                            callback();
                        }
                        <span class="keyword">else</span> {
                            replenish();
                        }
                    }
                });
            }
        })();
    };


    <span class="keyword">var</span> doParallel = <span class="function"><span class="keyword">function</span> <span class="params">(fn)</span> {</span>
        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            <span class="keyword">var</span> args = Array.prototype.slice.call(arguments);
            <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, [async.forEach].concat(args));
        };
    };
    <span class="keyword">var</span> doSeries = <span class="function"><span class="keyword">function</span> <span class="params">(fn)</span> {</span>
        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            <span class="keyword">var</span> args = Array.prototype.slice.call(arguments);
            <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, [async.forEachSeries].concat(args));
        };
    };


    <span class="keyword">var</span> _asyncMap = <span class="function"><span class="keyword">function</span> <span class="params">(eachfn, arr, iterator, callback)</span> {</span>
        <span class="keyword">var</span> results = [];
        arr = _map(arr, <span class="function"><span class="keyword">function</span> <span class="params">(x, i)</span> {</span>
            <span class="keyword">return</span> {index: i, value: x};
        });
        eachfn(arr, <span class="function"><span class="keyword">function</span> <span class="params">(x, callback)</span> {</span>
            iterator(x.value, <span class="function"><span class="keyword">function</span> <span class="params">(err, v)</span> {</span>
                results[x.index] = v;
                callback(err);
            });
        }, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
            callback(err, results);
        });
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);


    <span class="comment">// reduce only has a series version, as doing reduce in parallel won't</span>
    <span class="comment">// work in many situations.</span>
    async.reduce = <span class="function"><span class="keyword">function</span> <span class="params">(arr, memo, iterator, callback)</span> {</span>
        async.forEachSeries(arr, <span class="function"><span class="keyword">function</span> <span class="params">(x, callback)</span> {</span>
            iterator(memo, x, <span class="function"><span class="keyword">function</span> <span class="params">(err, v)</span> {</span>
                memo = v;
                callback(err);
            });
        }, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
            callback(err, memo);
        });
    };
    <span class="comment">// inject alias</span>
    async.inject = async.reduce;
    <span class="comment">// foldl alias</span>
    async.foldl = async.reduce;

    async.reduceRight = <span class="function"><span class="keyword">function</span> <span class="params">(arr, memo, iterator, callback)</span> {</span>
        <span class="keyword">var</span> reversed = _map(arr, <span class="function"><span class="keyword">function</span> <span class="params">(x)</span> {</span>
            <span class="keyword">return</span> x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    <span class="comment">// foldr alias</span>
    async.foldr = async.reduceRight;

    <span class="keyword">var</span> _filter = <span class="function"><span class="keyword">function</span> <span class="params">(eachfn, arr, iterator, callback)</span> {</span>
        <span class="keyword">var</span> results = [];
        arr = _map(arr, <span class="function"><span class="keyword">function</span> <span class="params">(x, i)</span> {</span>
            <span class="keyword">return</span> {index: i, value: x};
        });
        eachfn(arr, <span class="function"><span class="keyword">function</span> <span class="params">(x, callback)</span> {</span>
            iterator(x.value, <span class="function"><span class="keyword">function</span> <span class="params">(v)</span> {</span>
                <span class="keyword">if</span> (v) {
                    results.push(x);
                }
                callback();
            });
        }, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
            callback(_map(results.sort(<span class="function"><span class="keyword">function</span> <span class="params">(a, b)</span> {</span>
                <span class="keyword">return</span> a.index - b.index;
            }), <span class="function"><span class="keyword">function</span> <span class="params">(x)</span> {</span>
                <span class="keyword">return</span> x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    <span class="comment">// select alias</span>
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    <span class="keyword">var</span> _reject = <span class="function"><span class="keyword">function</span> <span class="params">(eachfn, arr, iterator, callback)</span> {</span>
        <span class="keyword">var</span> results = [];
        arr = _map(arr, <span class="function"><span class="keyword">function</span> <span class="params">(x, i)</span> {</span>
            <span class="keyword">return</span> {index: i, value: x};
        });
        eachfn(arr, <span class="function"><span class="keyword">function</span> <span class="params">(x, callback)</span> {</span>
            iterator(x.value, <span class="function"><span class="keyword">function</span> <span class="params">(v)</span> {</span>
                <span class="keyword">if</span> (!v) {
                    results.push(x);
                }
                callback();
            });
        }, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
            callback(_map(results.sort(<span class="function"><span class="keyword">function</span> <span class="params">(a, b)</span> {</span>
                <span class="keyword">return</span> a.index - b.index;
            }), <span class="function"><span class="keyword">function</span> <span class="params">(x)</span> {</span>
                <span class="keyword">return</span> x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    <span class="keyword">var</span> _detect = <span class="function"><span class="keyword">function</span> <span class="params">(eachfn, arr, iterator, main_callback)</span> {</span>
        eachfn(arr, <span class="function"><span class="keyword">function</span> <span class="params">(x, callback)</span> {</span>
            iterator(x, <span class="function"><span class="keyword">function</span> <span class="params">(result)</span> {</span>
                <span class="keyword">if</span> (result) {
                    main_callback(x);
                    main_callback = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};
                }
                <span class="keyword">else</span> {
                    callback();
                }
            });
        }, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = <span class="function"><span class="keyword">function</span> <span class="params">(arr, iterator, main_callback)</span> {</span>
        async.forEach(arr, <span class="function"><span class="keyword">function</span> <span class="params">(x, callback)</span> {</span>
            iterator(x, <span class="function"><span class="keyword">function</span> <span class="params">(v)</span> {</span>
                <span class="keyword">if</span> (v) {
                    main_callback(<span class="literal">true</span>);
                    main_callback = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};
                }
                callback();
            });
        }, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
            main_callback(<span class="literal">false</span>);
        });
    };
    <span class="comment">// any alias</span>
    async.any = async.some;

    async.every = <span class="function"><span class="keyword">function</span> <span class="params">(arr, iterator, main_callback)</span> {</span>
        async.forEach(arr, <span class="function"><span class="keyword">function</span> <span class="params">(x, callback)</span> {</span>
            iterator(x, <span class="function"><span class="keyword">function</span> <span class="params">(v)</span> {</span>
                <span class="keyword">if</span> (!v) {
                    main_callback(<span class="literal">false</span>);
                    main_callback = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};
                }
                callback();
            });
        }, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
            main_callback(<span class="literal">true</span>);
        });
    };
    <span class="comment">// all alias</span>
    async.all = async.every;

    async.sortBy = <span class="function"><span class="keyword">function</span> <span class="params">(arr, iterator, callback)</span> {</span>
        async.map(arr, <span class="function"><span class="keyword">function</span> <span class="params">(x, callback)</span> {</span>
            iterator(x, <span class="function"><span class="keyword">function</span> <span class="params">(err, criteria)</span> {</span>
                <span class="keyword">if</span> (err) {
                    callback(err);
                }
                <span class="keyword">else</span> {
                    callback(<span class="literal">null</span>, {value: x, criteria: criteria});
                }
            });
        }, <span class="function"><span class="keyword">function</span> <span class="params">(err, results)</span> {</span>
            <span class="keyword">if</span> (err) {
                <span class="keyword">return</span> callback(err);
            }
            <span class="keyword">else</span> {
                <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> <span class="params">(left, right)</span> {</span>
                    <span class="keyword">var</span> a = left.criteria, b = right.criteria;
                    <span class="keyword">return</span> a &lt; b ? -<span class="number">1</span> : a > b ? <span class="number">1</span> : <span class="number">0</span>;
                };
                callback(<span class="literal">null</span>, _map(results.sort(fn), <span class="function"><span class="keyword">function</span> <span class="params">(x)</span> {</span>
                    <span class="keyword">return</span> x.value;
                }));
            }
        });
    };

    async.auto = <span class="function"><span class="keyword">function</span> <span class="params">(tasks, callback)</span> {</span>
        callback = callback || <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};
        <span class="keyword">var</span> keys = _keys(tasks);
        <span class="keyword">if</span> (!keys.length) {
            <span class="keyword">return</span> callback(<span class="literal">null</span>);
        }

        <span class="keyword">var</span> results = {};

        <span class="keyword">var</span> listeners = [];
        <span class="keyword">var</span> addListener = <span class="function"><span class="keyword">function</span> <span class="params">(fn)</span> {</span>
            listeners.unshift(fn);
        };
        <span class="keyword">var</span> removeListener = <span class="function"><span class="keyword">function</span> <span class="params">(fn)</span> {</span>
            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; listeners.length; i += <span class="number">1</span>) {
                <span class="keyword">if</span> (listeners[i] === fn) {
                    listeners.splice(i, <span class="number">1</span>);
                    <span class="keyword">return</span>;
                }
            }
        };
        <span class="keyword">var</span> taskComplete = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            _forEach(listeners.slice(<span class="number">0</span>), <span class="function"><span class="keyword">function</span> <span class="params">(fn)</span> {</span>
                fn();
            });
        };

        addListener(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            <span class="keyword">if</span> (_keys(results).length === keys.length) {
                callback(<span class="literal">null</span>, results);
                callback = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};
            }
        });

        _forEach(keys, <span class="function"><span class="keyword">function</span> <span class="params">(k)</span> {</span>
            <span class="keyword">var</span> task = (tasks[k] <span class="keyword">instanceof</span> Function) ? [tasks[k]]: tasks[k];
            <span class="keyword">var</span> taskCallback = <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
                <span class="keyword">if</span> (err) {
                    callback(err);
                    <span class="comment">// stop subsequent errors hitting callback multiple times</span>
                    callback = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};
                }
                <span class="keyword">else</span> {
                    <span class="keyword">var</span> args = Array.prototype.slice.call(arguments, <span class="number">1</span>);
                    <span class="keyword">if</span> (args.length &lt;= <span class="number">1</span>) {
                        args = args[<span class="number">0</span>];
                    }
                    results[k] = args;
                    taskComplete();
                }
            };
            <span class="keyword">var</span> requires = task.slice(<span class="number">0</span>, Math.abs(task.length - <span class="number">1</span>)) || [];
            <span class="keyword">var</span> ready = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
                <span class="keyword">return</span> _reduce(requires, <span class="function"><span class="keyword">function</span> <span class="params">(a, x)</span> {</span>
                    <span class="keyword">return</span> (a &amp;&amp; results.hasOwnProperty(x));
                }, <span class="literal">true</span>) &amp;&amp; !results.hasOwnProperty(k);
            };
            <span class="keyword">if</span> (ready()) {
                task[task.length - <span class="number">1</span>](taskCallback, results);
            }
            <span class="keyword">else</span> {
                <span class="keyword">var</span> listener = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
                    <span class="keyword">if</span> (ready()) {
                        removeListener(listener);
                        task[task.length - <span class="number">1</span>](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.waterfall = <span class="function"><span class="keyword">function</span> <span class="params">(tasks, callback)</span> {</span>
        callback = callback || <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};
        <span class="keyword">if</span> (!tasks.length) {
            <span class="keyword">return</span> callback();
        }
        <span class="keyword">var</span> wrapIterator = <span class="function"><span class="keyword">function</span> <span class="params">(iterator)</span> {</span>
            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
                <span class="keyword">if</span> (err) {
                    callback(err);
                    callback = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};
                }
                <span class="keyword">else</span> {
                    <span class="keyword">var</span> args = Array.prototype.slice.call(arguments, <span class="number">1</span>);
                    <span class="keyword">var</span> next = iterator.next();
                    <span class="keyword">if</span> (next) {
                        args.push(wrapIterator(next));
                    }
                    <span class="keyword">else</span> {
                        args.push(callback);
                    }
                    async.nextTick(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
                        iterator.apply(<span class="literal">null</span>, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    async.parallel = <span class="function"><span class="keyword">function</span> <span class="params">(tasks, callback)</span> {</span>
        callback = callback || <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};
        <span class="keyword">if</span> (tasks.constructor === Array) {
            async.map(tasks, <span class="function"><span class="keyword">function</span> <span class="params">(fn, callback)</span> {</span>
                <span class="keyword">if</span> (fn) {
                    fn(<span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
                        <span class="keyword">var</span> args = Array.prototype.slice.call(arguments, <span class="number">1</span>);
                        <span class="keyword">if</span> (args.length &lt;= <span class="number">1</span>) {
                            args = args[<span class="number">0</span>];
                        }
                        callback.call(<span class="literal">null</span>, err, args);
                    });
                }
            }, callback);
        }
        <span class="keyword">else</span> {
            <span class="keyword">var</span> results = {};
            async.forEach(_keys(tasks), <span class="function"><span class="keyword">function</span> <span class="params">(k, callback)</span> {</span>
                tasks[k](<span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
                    <span class="keyword">var</span> args = Array.prototype.slice.call(arguments, <span class="number">1</span>);
                    <span class="keyword">if</span> (args.length &lt;= <span class="number">1</span>) {
                        args = args[<span class="number">0</span>];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
                callback(err, results);
            });
        }
    };

    async.series = <span class="function"><span class="keyword">function</span> <span class="params">(tasks, callback)</span> {</span>
        callback = callback || <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};
        <span class="keyword">if</span> (tasks.constructor === Array) {
            async.mapSeries(tasks, <span class="function"><span class="keyword">function</span> <span class="params">(fn, callback)</span> {</span>
                <span class="keyword">if</span> (fn) {
                    fn(<span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
                        <span class="keyword">var</span> args = Array.prototype.slice.call(arguments, <span class="number">1</span>);
                        <span class="keyword">if</span> (args.length &lt;= <span class="number">1</span>) {
                            args = args[<span class="number">0</span>];
                        }
                        callback.call(<span class="literal">null</span>, err, args);
                    });
                }
            }, callback);
        }
        <span class="keyword">else</span> {
            <span class="keyword">var</span> results = {};
            async.forEachSeries(_keys(tasks), <span class="function"><span class="keyword">function</span> <span class="params">(k, callback)</span> {</span>
                tasks[k](<span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
                    <span class="keyword">var</span> args = Array.prototype.slice.call(arguments, <span class="number">1</span>);
                    <span class="keyword">if</span> (args.length &lt;= <span class="number">1</span>) {
                        args = args[<span class="number">0</span>];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
                callback(err, results);
            });
        }
    };

    async.iterator = <span class="function"><span class="keyword">function</span> <span class="params">(tasks)</span> {</span>
        <span class="keyword">var</span> makeCallback = <span class="function"><span class="keyword">function</span> <span class="params">(index)</span> {</span>
            <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
                <span class="keyword">if</span> (tasks.length) {
                    tasks[index].apply(<span class="literal">null</span>, arguments);
                }
                <span class="keyword">return</span> fn.next();
            };
            fn.next = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
                <span class="keyword">return</span> (index &lt; tasks.length - <span class="number">1</span>) ? makeCallback(index + <span class="number">1</span>): <span class="literal">null</span>;
            };
            <span class="keyword">return</span> fn;
        };
        <span class="keyword">return</span> makeCallback(<span class="number">0</span>);
    };

    async.apply = <span class="function"><span class="keyword">function</span> <span class="params">(fn)</span> {</span>
        <span class="keyword">var</span> args = Array.prototype.slice.call(arguments, <span class="number">1</span>);
        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            <span class="keyword">return</span> fn.apply(
                <span class="literal">null</span>, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    <span class="keyword">var</span> _concat = <span class="function"><span class="keyword">function</span> <span class="params">(eachfn, arr, fn, callback)</span> {</span>
        <span class="keyword">var</span> r = [];
        eachfn(arr, <span class="function"><span class="keyword">function</span> <span class="params">(x, cb)</span> {</span>
            fn(x, <span class="function"><span class="keyword">function</span> <span class="params">(err, y)</span> {</span>
                r = r.concat(y || []);
                cb(err);
            });
        }, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = <span class="function"><span class="keyword">function</span> <span class="params">(test, iterator, callback)</span> {</span>
        <span class="keyword">if</span> (test()) {
            iterator(<span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
                <span class="keyword">if</span> (err) {
                    <span class="keyword">return</span> callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        <span class="keyword">else</span> {
            callback();
        }
    };

    async.until = <span class="function"><span class="keyword">function</span> <span class="params">(test, iterator, callback)</span> {</span>
        <span class="keyword">if</span> (!test()) {
            iterator(<span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
                <span class="keyword">if</span> (err) {
                    <span class="keyword">return</span> callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        <span class="keyword">else</span> {
            callback();
        }
    };

    async.queue = <span class="function"><span class="keyword">function</span> <span class="params">(worker, concurrency)</span> {</span>
        <span class="keyword">var</span> workers = <span class="number">0</span>;
        <span class="keyword">var</span> q = {
            tasks: [],
            concurrency: concurrency,
            saturated: <span class="literal">null</span>,
            empty: <span class="literal">null</span>,
            drain: <span class="literal">null</span>,
            push: <span class="function"><span class="keyword">function</span> <span class="params">(data, callback)</span> {</span>
                <span class="keyword">if</span>(data.constructor !== Array) {
                    data = [data];
                }
                _forEach(data, <span class="keyword">function</span>(task) {
                    q.tasks.push({
                        data: task,
                        callback: <span class="keyword">typeof</span> callback === <span class="string">'function'</span> ? callback : <span class="literal">null</span>
                    });
                    <span class="keyword">if</span> (q.saturated &amp;&amp; q.tasks.length == concurrency) {
                        q.saturated();
                    }
                    async.nextTick(q.process);
                });
            },
            process: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
                <span class="keyword">if</span> (workers &lt; q.concurrency &amp;&amp; q.tasks.length) {
                    <span class="keyword">var</span> task = q.tasks.shift();
                    <span class="keyword">if</span>(q.empty &amp;&amp; q.tasks.length == <span class="number">0</span>) q.empty();
                    workers += <span class="number">1</span>;
                    worker(task.data, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
                        workers -= <span class="number">1</span>;
                        <span class="keyword">if</span> (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        <span class="keyword">if</span>(q.drain &amp;&amp; q.tasks.length + workers == <span class="number">0</span>) q.drain();
                        q.process();
                    });
                }
            },
            length: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
                <span class="keyword">return</span> q.tasks.length;
            },
            running: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
                <span class="keyword">return</span> workers;
            }
        };
        <span class="keyword">return</span> q;
    };

    <span class="keyword">var</span> _console_fn = <span class="function"><span class="keyword">function</span> <span class="params">(name)</span> {</span>
        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(fn)</span> {</span>
            <span class="keyword">var</span> args = Array.prototype.slice.call(arguments, <span class="number">1</span>);
            fn.apply(<span class="literal">null</span>, args.concat([<span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
                <span class="keyword">var</span> args = Array.prototype.slice.call(arguments, <span class="number">1</span>);
                <span class="keyword">if</span> (<span class="keyword">typeof</span> console !== <span class="string">'undefined'</span>) {
                    <span class="keyword">if</span> (err) {
                        <span class="keyword">if</span> (console.error) {
                            console.error(err);
                        }
                    }
                    <span class="keyword">else</span> <span class="keyword">if</span> (console[name]) {
                        _forEach(args, <span class="function"><span class="keyword">function</span> <span class="params">(x)</span> {</span>
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn(<span class="string">'log'</span>);
    async.dir = _console_fn(<span class="string">'dir'</span>);
    <span class="comment">/*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/</span>

    async.memoize = <span class="function"><span class="keyword">function</span> <span class="params">(fn, hasher)</span> {</span>
        <span class="keyword">var</span> memo = {};
        <span class="keyword">var</span> queues = {};
        hasher = hasher || <span class="function"><span class="keyword">function</span> <span class="params">(x)</span> {</span>
            <span class="keyword">return</span> x;
        };
        <span class="keyword">var</span> memoized = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            <span class="keyword">var</span> args = Array.prototype.slice.call(arguments);
            <span class="keyword">var</span> callback = args.pop();
            <span class="keyword">var</span> key = hasher.apply(<span class="literal">null</span>, args);
            <span class="keyword">if</span> (key <span class="keyword">in</span> memo) {
                callback.apply(<span class="literal">null</span>, memo[key]);
            }
            <span class="keyword">else</span> <span class="keyword">if</span> (key <span class="keyword">in</span> queues) {
                queues[key].push(callback);
            }
            <span class="keyword">else</span> {
                queues[key] = [callback];
                fn.apply(<span class="literal">null</span>, args.concat([<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
                    memo[key] = arguments;
                    <span class="keyword">var</span> q = queues[key];
                    <span class="keyword">delete</span> queues[key];
                    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = q.length; i &lt; l; i++) {
                      q[i].apply(<span class="literal">null</span>, arguments);
                    }
                }]));
            }
        };
        memoized.unmemoized = fn;
        <span class="keyword">return</span> memoized;
    };

    async.unmemoize = <span class="function"><span class="keyword">function</span> <span class="params">(fn)</span> {</span>
      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">return</span> (fn.unmemoized || fn).apply(<span class="literal">null</span>, arguments);
      };
    };

}());
</code></pre>