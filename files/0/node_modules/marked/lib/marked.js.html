<h1>marked</h1>
<pre><code class="lang-js"><span class="comment">/**
 * marked - A markdown parser (https://github.com/chjj/marked)
 * Copyright (c) 2011-2012, Christopher Jeffrey. (MIT Licensed)
 */</span>

;(<span class="keyword">function</span>() {

<span class="comment">/**
 * Block-Level Grammar
 */</span>

<span class="keyword">var</span> block = {
  newline: <span class="regexp">/^\n+/</span>,
  code: <span class="regexp">/^( {4}[^\n]+\n*)+/</span>,
  fences: noop,
  hr: <span class="regexp">/^( *[-*_]){3,} *(?:\n+|$)/</span>,
  heading: <span class="regexp">/^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/</span>,
  lheading: <span class="regexp">/^([^\n]+)\n *(=|-){3,} *\n*/</span>,
  blockquote: <span class="regexp">/^( *>[^\n]+(\n[^\n]+)*\n*)+/</span>,
  list: <span class="regexp">/^( *)(bull) [^\0]+?(?:hr|\n{2,}(?! )(?!\1bull )\n*|\s*$)/</span>,
  html: <span class="regexp">/^ *(?:comment|closed|closing) *(?:\n{2,}|\s*$)/</span>,
  def: <span class="regexp">/^ *\[([^\]]+)\]: *([^\s]+)(?: +["(]([^\n]+)[")])? *(?:\n+|$)/</span>,
  paragraph: <span class="regexp">/^([^\n]+\n?(?!body))+\n*/</span>,
  text: <span class="regexp">/^[^\n]+/</span>
};

block.bullet = <span class="regexp">/(?:[*+-]|\d+\.)/</span>;
block.item = <span class="regexp">/^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/</span>;
block.item = replace(block.item, <span class="string">'gm'</span>)
  (<span class="regexp">/bull/g</span>, block.bullet)
  ();

block.list = replace(block.list)
  (<span class="regexp">/bull/g</span>, block.bullet)
  (<span class="string">'hr'</span>, <span class="regexp">/\n+(?=(?: *[-*_]){3,} *(?:\n+|$))/</span>)
  ();

block.html = replace(block.html)
  (<span class="string">'comment'</span>, <span class="regexp">/&lt;!--[^\0]*?-->/</span>)
  (<span class="string">'closed'</span>, <span class="regexp">/&lt;(tag)[^\0]+?&lt;\/\1>/</span>)
  (<span class="string">'closing'</span>, <span class="regexp">/&lt;tag(?!:\/|@)\b(?:"[^"]*"|'[^']*'|[^'">])*?>/</span>)
  (<span class="regexp">/tag/g</span>, tag())
  ();

block.paragraph = (<span class="keyword">function</span>() {
  <span class="keyword">var</span> paragraph = block.paragraph.source
    , body = [];

  (<span class="function"><span class="keyword">function</span> <span class="title">push</span><span class="params">(rule)</span> {</span>
    rule = block[rule] ? block[rule].source : rule;
    body.push(rule.replace(<span class="regexp">/(^|[^\[])\^/g</span>, <span class="string">'$1'</span>));
    <span class="keyword">return</span> push;
  })
  (<span class="string">'hr'</span>)
  (<span class="string">'heading'</span>)
  (<span class="string">'lheading'</span>)
  (<span class="string">'blockquote'</span>)
  (<span class="string">'&lt;'</span> + tag())
  (<span class="string">'def'</span>);

  <span class="keyword">return</span> <span class="keyword">new</span>
    RegExp(paragraph.replace(<span class="string">'body'</span>, body.join(<span class="string">'|'</span>)));
})();

block.normal = {
  fences: block.fences,
  paragraph: block.paragraph
};

block.gfm = {
  fences: <span class="regexp">/^ *``` *(\w+)? *\n([^\0]+?)\s*``` *(?:\n+|$)/</span>,
  paragraph: <span class="regexp">/^/</span>
};

block.gfm.paragraph = replace(block.paragraph)
  (<span class="string">'(?!'</span>, <span class="string">'(?!'</span> + block.gfm.fences.source.replace(<span class="regexp">/(^|[^\[])\^/g</span>, <span class="string">'$1'</span>) + <span class="string">'|'</span>)
  ();

<span class="comment">/**
 * Block Lexer
 */</span>

block.lexer = <span class="keyword">function</span>(src) {
  <span class="keyword">var</span> tokens = [];

  tokens.links = {};

  src = src
    .replace(<span class="regexp">/\r\n|\r/g</span>, <span class="string">'\n'</span>)
    .replace(<span class="regexp">/\t/g</span>, <span class="string">'    '</span>);

  <span class="keyword">return</span> block.token(src, tokens, <span class="literal">true</span>);
};

block.token = <span class="keyword">function</span>(src, tokens, top) {
  <span class="keyword">var</span> src = src.replace(<span class="regexp">/^ +$/gm</span>, <span class="string">''</span>)
    , next
    , loose
    , cap
    , item
    , space
    , i
    , l;

  <span class="keyword">while</span> (src) {
    <span class="comment">// newline</span>
    <span class="keyword">if</span> (cap = block.newline.exec(src)) {
      src = src.substring(cap[<span class="number">0</span>].length);
      <span class="keyword">if</span> (cap[<span class="number">0</span>].length > <span class="number">1</span>) {
        tokens.push({
          type: <span class="string">'space'</span>
        });
      }
    }

    <span class="comment">// code</span>
    <span class="keyword">if</span> (cap = block.code.exec(src)) {
      src = src.substring(cap[<span class="number">0</span>].length);
      cap = cap[<span class="number">0</span>].replace(<span class="regexp">/^ {4}/gm</span>, <span class="string">''</span>);
      tokens.push({
        type: <span class="string">'code'</span>,
        text: !options.pedantic
          ? cap.replace(<span class="regexp">/\n+$/</span>, <span class="string">''</span>)
          : cap
      });
      <span class="keyword">continue</span>;
    }

    <span class="comment">// fences (gfm)</span>
    <span class="keyword">if</span> (cap = block.fences.exec(src)) {
      src = src.substring(cap[<span class="number">0</span>].length);
      tokens.push({
        type: <span class="string">'code'</span>,
        lang: cap[<span class="number">1</span>],
        text: cap[<span class="number">2</span>]
      });
      <span class="keyword">continue</span>;
    }

    <span class="comment">// heading</span>
    <span class="keyword">if</span> (cap = block.heading.exec(src)) {
      src = src.substring(cap[<span class="number">0</span>].length);
      tokens.push({
        type: <span class="string">'heading'</span>,
        depth: cap[<span class="number">1</span>].length,
        text: cap[<span class="number">2</span>]
      });
      <span class="keyword">continue</span>;
    }

    <span class="comment">// lheading</span>
    <span class="keyword">if</span> (cap = block.lheading.exec(src)) {
      src = src.substring(cap[<span class="number">0</span>].length);
      tokens.push({
        type: <span class="string">'heading'</span>,
        depth: cap[<span class="number">2</span>] === <span class="string">'='</span> ? <span class="number">1</span> : <span class="number">2</span>,
        text: cap[<span class="number">1</span>]
      });
      <span class="keyword">continue</span>;
    }

    <span class="comment">// hr</span>
    <span class="keyword">if</span> (cap = block.hr.exec(src)) {
      src = src.substring(cap[<span class="number">0</span>].length);
      tokens.push({
        type: <span class="string">'hr'</span>
      });
      <span class="keyword">continue</span>;
    }

    <span class="comment">// blockquote</span>
    <span class="keyword">if</span> (cap = block.blockquote.exec(src)) {
      src = src.substring(cap[<span class="number">0</span>].length);

      tokens.push({
        type: <span class="string">'blockquote_start'</span>
      });

      cap = cap[<span class="number">0</span>].replace(<span class="regexp">/^ *> ?/gm</span>, <span class="string">''</span>);

      <span class="comment">// Pass `top` to keep the current</span>
      <span class="comment">// "toplevel" state. This is exactly</span>
      <span class="comment">// how markdown.pl works.</span>
      block.token(cap, tokens, top);

      tokens.push({
        type: <span class="string">'blockquote_end'</span>
      });

      <span class="keyword">continue</span>;
    }

    <span class="comment">// list</span>
    <span class="keyword">if</span> (cap = block.list.exec(src)) {
      src = src.substring(cap[<span class="number">0</span>].length);

      tokens.push({
        type: <span class="string">'list_start'</span>,
        ordered: isFinite(cap[<span class="number">2</span>])
      });

      <span class="comment">// Get each top-level item.</span>
      cap = cap[<span class="number">0</span>].match(block.item);

      next = <span class="literal">false</span>;
      l = cap.length;
      i = <span class="number">0</span>;

      <span class="keyword">for</span> (; i &lt; l; i++) {
        item = cap[i];

        <span class="comment">// Remove the list item's bullet</span>
        <span class="comment">// so it is seen as the next token.</span>
        space = item.length;
        item = item.replace(<span class="regexp">/^ *([*+-]|\d+\.) +/</span>, <span class="string">''</span>);

        <span class="comment">// Outdent whatever the</span>
        <span class="comment">// list item contains. Hacky.</span>
        <span class="keyword">if</span> (~item.indexOf(<span class="string">'\n '</span>)) {
          space -= item.length;
          item = !options.pedantic
            ? item.replace(<span class="keyword">new</span> RegExp(<span class="string">'^ {1,'</span> + space + <span class="string">'}'</span>, <span class="string">'gm'</span>), <span class="string">''</span>)
            : item.replace(<span class="regexp">/^ {1,4}/gm</span>, <span class="string">''</span>);
        }

        <span class="comment">// Determine whether item is loose or not.</span>
        <span class="comment">// Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/</span>
        <span class="comment">// for discount behavior.</span>
        loose = next || <span class="regexp">/\n\n(?!\s*$)/</span>.test(item);
        <span class="keyword">if</span> (i !== l - <span class="number">1</span>) {
          next = item[item.length-<span class="number">1</span>] === <span class="string">'\n'</span>;
          <span class="keyword">if</span> (!loose) loose = next;
        }

        tokens.push({
          type: loose
            ? <span class="string">'loose_item_start'</span>
            : <span class="string">'list_item_start'</span>
        });

        <span class="comment">// Recurse.</span>
        block.token(item, tokens);

        tokens.push({
          type: <span class="string">'list_item_end'</span>
        });
      }

      tokens.push({
        type: <span class="string">'list_end'</span>
      });

      <span class="keyword">continue</span>;
    }

    <span class="comment">// html</span>
    <span class="keyword">if</span> (cap = block.html.exec(src)) {
      src = src.substring(cap[<span class="number">0</span>].length);
      tokens.push({
        type: <span class="string">'html'</span>,
        pre: cap[<span class="number">1</span>] === <span class="string">'pre'</span>,
        text: cap[<span class="number">0</span>]
      });
      <span class="keyword">continue</span>;
    }

    <span class="comment">// def</span>
    <span class="keyword">if</span> (top &amp;&amp; (cap = block.def.exec(src))) {
      src = src.substring(cap[<span class="number">0</span>].length);
      tokens.links[cap[<span class="number">1</span>].toLowerCase()] = {
        href: cap[<span class="number">2</span>],
        title: cap[<span class="number">3</span>]
      };
      <span class="keyword">continue</span>;
    }

    <span class="comment">// top-level paragraph</span>
    <span class="keyword">if</span> (top &amp;&amp; (cap = block.paragraph.exec(src))) {
      src = src.substring(cap[<span class="number">0</span>].length);
      tokens.push({
        type: <span class="string">'paragraph'</span>,
        text: cap[<span class="number">0</span>]
      });
      <span class="keyword">continue</span>;
    }

    <span class="comment">// text</span>
    <span class="keyword">if</span> (cap = block.text.exec(src)) {
      <span class="comment">// Top-level should never reach here.</span>
      src = src.substring(cap[<span class="number">0</span>].length);
      tokens.push({
        type: <span class="string">'text'</span>,
        text: cap[<span class="number">0</span>]
      });
      <span class="keyword">continue</span>;
    }
  }

  <span class="keyword">return</span> tokens;
};

<span class="comment">/**
 * Inline Processing
 */</span>

<span class="keyword">var</span> inline = {
  escape: <span class="regexp">/^\\([\\`*{}\[\]()#+\-.!_>])/</span>,
  autolink: <span class="regexp">/^&lt;([^ >]+(@|:\/)[^ >]+)>/</span>,
  url: noop,
  tag: <span class="regexp">/^&lt;!--[^\0]*?-->|^&lt;\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/</span>,
  link: <span class="regexp">/^!?\[(inside)\]\(href\)/</span>,
  reflink: <span class="regexp">/^!?\[(inside)\]\s*\[([^\]]*)\]/</span>,
  nolink: <span class="regexp">/^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/</span>,
  strong: <span class="regexp">/^__([^\0]+?)__(?!_)|^\*\*([^\0]+?)\*\*(?!\*)/</span>,
  em: <span class="regexp">/^\b_((?:__|[^\0])+?)_\b|^\*((?:\*\*|[^\0])+?)\*(?!\*)/</span>,
  code: <span class="regexp">/^(`+)([^\0]*?[^`])\1(?!`)/</span>,
  br: <span class="regexp">/^ {2,}\n(?!\s*$)/</span>,
  text: <span class="regexp">/^[^\0]+?(?=[\\&lt;!\[_*`]| {2,}\n|$)/</span>
};

inline._linkInside = <span class="regexp">/(?:\[[^\]]*\]|[^\]]|\](?=[^\[]*\]))*/</span>;
inline._linkHref = <span class="regexp">/\s*&lt;?([^\s]*?)>?(?:\s+['"]([^\0]*?)['"])?\s*/</span>;

inline.link = replace(inline.link)
  (<span class="string">'inside'</span>, inline._linkInside)
  (<span class="string">'href'</span>, inline._linkHref)
  ();

inline.reflink = replace(inline.reflink)
  (<span class="string">'inside'</span>, inline._linkInside)
  ();

inline.normal = {
  url: inline.url,
  strong: inline.strong,
  em: inline.em,
  text: inline.text
};

inline.pedantic = {
  strong: <span class="regexp">/^__(?=\S)([^\0]*?\S)__(?!_)|^\*\*(?=\S)([^\0]*?\S)\*\*(?!\*)/</span>,
  em: <span class="regexp">/^_(?=\S)([^\0]*?\S)_(?!_)|^\*(?=\S)([^\0]*?\S)\*(?!\*)/</span>
};

inline.gfm = {
  url: <span class="regexp">/^(https?:\/\/[^\s]+[^.,:;"')\]\s])/</span>,
  text: <span class="regexp">/^[^\0]+?(?=[\\&lt;!\[_*`]|https?:\/\/| {2,}\n|$)/</span>
};

<span class="comment">/**
 * Inline Lexer
 */</span>

inline.lexer = <span class="keyword">function</span>(src) {
  <span class="keyword">var</span> out = <span class="string">''</span>
    , links = tokens.links
    , link
    , text
    , href
    , cap;

  <span class="keyword">while</span> (src) {
    <span class="comment">// escape</span>
    <span class="keyword">if</span> (cap = inline.escape.exec(src)) {
      src = src.substring(cap[<span class="number">0</span>].length);
      out += cap[<span class="number">1</span>];
      <span class="keyword">continue</span>;
    }

    <span class="comment">// autolink</span>
    <span class="keyword">if</span> (cap = inline.autolink.exec(src)) {
      src = src.substring(cap[<span class="number">0</span>].length);
      <span class="keyword">if</span> (cap[<span class="number">2</span>] === <span class="string">'@'</span>) {
        text = cap[<span class="number">1</span>][<span class="number">6</span>] === <span class="string">':'</span>
          ? mangle(cap[<span class="number">1</span>].substring(<span class="number">7</span>))
          : mangle(cap[<span class="number">1</span>]);
        href = mangle(<span class="string">'mailto:'</span>) + text;
      } <span class="keyword">else</span> {
        text = escape(cap[<span class="number">1</span>]);
        href = text;
      }
      out += <span class="string">'&lt;a href="'</span>
        + href
        + <span class="string">'">'</span>
        + text
        + <span class="string">'&lt;/a>'</span>;
      <span class="keyword">continue</span>;
    }

    <span class="comment">// url (gfm)</span>
    <span class="keyword">if</span> (cap = inline.url.exec(src)) {
      src = src.substring(cap[<span class="number">0</span>].length);
      text = escape(cap[<span class="number">1</span>]);
      href = text;
      out += <span class="string">'&lt;a href="'</span>
        + href
        + <span class="string">'">'</span>
        + text
        + <span class="string">'&lt;/a>'</span>;
      <span class="keyword">continue</span>;
    }

    <span class="comment">// tag</span>
    <span class="keyword">if</span> (cap = inline.tag.exec(src)) {
      src = src.substring(cap[<span class="number">0</span>].length);
      out += options.sanitize
        ? escape(cap[<span class="number">0</span>])
        : cap[<span class="number">0</span>];
      <span class="keyword">continue</span>;
    }

    <span class="comment">// link</span>
    <span class="keyword">if</span> (cap = inline.link.exec(src)) {
      src = src.substring(cap[<span class="number">0</span>].length);
      out += outputLink(cap, {
        href: cap[<span class="number">2</span>],
        title: cap[<span class="number">3</span>]
      });
      <span class="keyword">continue</span>;
    }

    <span class="comment">// reflink, nolink</span>
    <span class="keyword">if</span> ((cap = inline.reflink.exec(src))
        || (cap = inline.nolink.exec(src))) {
      src = src.substring(cap[<span class="number">0</span>].length);
      link = (cap[<span class="number">2</span>] || cap[<span class="number">1</span>]).replace(<span class="regexp">/\s+/g</span>, <span class="string">' '</span>);
      link = links[link.toLowerCase()];
      <span class="keyword">if</span> (!link || !link.href) {
        out += cap[<span class="number">0</span>][<span class="number">0</span>];
        src = cap[<span class="number">0</span>].substring(<span class="number">1</span>) + src;
        <span class="keyword">continue</span>;
      }
      out += outputLink(cap, link);
      <span class="keyword">continue</span>;
    }

    <span class="comment">// strong</span>
    <span class="keyword">if</span> (cap = inline.strong.exec(src)) {
      src = src.substring(cap[<span class="number">0</span>].length);
      out += <span class="string">'&lt;strong>'</span>
        + inline.lexer(cap[<span class="number">2</span>] || cap[<span class="number">1</span>])
        + <span class="string">'&lt;/strong>'</span>;
      <span class="keyword">continue</span>;
    }

    <span class="comment">// em</span>
    <span class="keyword">if</span> (cap = inline.em.exec(src)) {
      src = src.substring(cap[<span class="number">0</span>].length);
      out += <span class="string">'&lt;em>'</span>
        + inline.lexer(cap[<span class="number">2</span>] || cap[<span class="number">1</span>])
        + <span class="string">'&lt;/em>'</span>;
      <span class="keyword">continue</span>;
    }

    <span class="comment">// code</span>
    <span class="keyword">if</span> (cap = inline.code.exec(src)) {
      src = src.substring(cap[<span class="number">0</span>].length);
      out += <span class="string">'&lt;code>'</span>
        + escape(cap[<span class="number">2</span>], <span class="literal">true</span>)
        + <span class="string">'&lt;/code>'</span>;
      <span class="keyword">continue</span>;
    }

    <span class="comment">// br</span>
    <span class="keyword">if</span> (cap = inline.br.exec(src)) {
      src = src.substring(cap[<span class="number">0</span>].length);
      out += <span class="string">'&lt;br>'</span>;
      <span class="keyword">continue</span>;
    }

    <span class="comment">// text</span>
    <span class="keyword">if</span> (cap = inline.text.exec(src)) {
      src = src.substring(cap[<span class="number">0</span>].length);
      out += escape(cap[<span class="number">0</span>]);
      <span class="keyword">continue</span>;
    }
  }

  <span class="keyword">return</span> out;
};

<span class="function"><span class="keyword">function</span> <span class="title">outputLink</span><span class="params">(cap, link)</span> {</span>
  <span class="keyword">if</span> (cap[<span class="number">0</span>][<span class="number">0</span>] !== <span class="string">'!'</span>) {
    <span class="keyword">return</span> <span class="string">'&lt;a href="'</span>
      + escape(link.href)
      + <span class="string">'"'</span>
      + (link.title
      ? <span class="string">' title="'</span>
      + escape(link.title)
      + <span class="string">'"'</span>
      : <span class="string">''</span>)
      + <span class="string">'>'</span>
      + inline.lexer(cap[<span class="number">1</span>])
      + <span class="string">'&lt;/a>'</span>;
  } <span class="keyword">else</span> {
    <span class="keyword">return</span> <span class="string">'&lt;img src="'</span>
      + escape(link.href)
      + <span class="string">'" alt="'</span>
      + escape(cap[<span class="number">1</span>])
      + <span class="string">'"'</span>
      + (link.title
      ? <span class="string">' title="'</span>
      + escape(link.title)
      + <span class="string">'"'</span>
      : <span class="string">''</span>)
      + <span class="string">'>'</span>;
  }
}

<span class="comment">/**
 * Parsing
 */</span>

<span class="keyword">var</span> tokens
  , token;

<span class="function"><span class="keyword">function</span> <span class="title">next</span><span class="params">()</span> {</span>
  <span class="keyword">return</span> token = tokens.pop();
}

<span class="function"><span class="keyword">function</span> <span class="title">tok</span><span class="params">()</span> {</span>
  <span class="keyword">switch</span> (token.type) {
    <span class="keyword">case</span> <span class="string">'space'</span>: {
      <span class="keyword">return</span> <span class="string">''</span>;
    }
    <span class="keyword">case</span> <span class="string">'hr'</span>: {
      <span class="keyword">return</span> <span class="string">'&lt;hr>\n'</span>;
    }
    <span class="keyword">case</span> <span class="string">'heading'</span>: {
      <span class="keyword">return</span> <span class="string">'&lt;h'</span>
        + token.depth
        + <span class="string">'>'</span>
        + inline.lexer(token.text)
        + <span class="string">'&lt;/h'</span>
        + token.depth
        + <span class="string">'>\n'</span>;
    }
    <span class="keyword">case</span> <span class="string">'code'</span>: {
      <span class="keyword">if</span> (options.highlight) {
        token.code = options.highlight(token.text, token.lang);
        <span class="keyword">if</span> (token.code != <span class="literal">null</span> &amp;&amp; token.code !== token.text) {
          token.escaped = <span class="literal">true</span>;
          token.text = token.code;
        }
      }

      <span class="keyword">if</span> (!token.escaped) {
        token.text = escape(token.text, <span class="literal">true</span>);
      }

      <span class="keyword">return</span> <span class="string">'&lt;pre>&lt;code'</span>
        + (token.lang
        ? <span class="string">' class="lang-'</span>
        + token.lang
        + <span class="string">'"'</span>
        : <span class="string">''</span>)
        + <span class="string">'>'</span>
        + token.text
        + <span class="string">'&lt;/code>&lt;/pre>\n'</span>;
    }
    <span class="keyword">case</span> <span class="string">'blockquote_start'</span>: {
      <span class="keyword">var</span> body = <span class="string">''</span>;

      <span class="keyword">while</span> (next().type !== <span class="string">'blockquote_end'</span>) {
        body += tok();
      }

      <span class="keyword">return</span> <span class="string">'&lt;blockquote>\n'</span>
        + body
        + <span class="string">'&lt;/blockquote>\n'</span>;
    }
    <span class="keyword">case</span> <span class="string">'list_start'</span>: {
      <span class="keyword">var</span> type = token.ordered ? <span class="string">'ol'</span> : <span class="string">'ul'</span>
        , body = <span class="string">''</span>;

      <span class="keyword">while</span> (next().type !== <span class="string">'list_end'</span>) {
        body += tok();
      }

      <span class="keyword">return</span> <span class="string">'&lt;'</span>
        + type
        + <span class="string">'>\n'</span>
        + body
        + <span class="string">'&lt;/'</span>
        + type
        + <span class="string">'>\n'</span>;
    }
    <span class="keyword">case</span> <span class="string">'list_item_start'</span>: {
      <span class="keyword">var</span> body = <span class="string">''</span>;

      <span class="keyword">while</span> (next().type !== <span class="string">'list_item_end'</span>) {
        body += token.type === <span class="string">'text'</span>
          ? parseText()
          : tok();
      }

      <span class="keyword">return</span> <span class="string">'&lt;li>'</span>
        + body
        + <span class="string">'&lt;/li>\n'</span>;
    }
    <span class="keyword">case</span> <span class="string">'loose_item_start'</span>: {
      <span class="keyword">var</span> body = <span class="string">''</span>;

      <span class="keyword">while</span> (next().type !== <span class="string">'list_item_end'</span>) {
        body += tok();
      }

      <span class="keyword">return</span> <span class="string">'&lt;li>'</span>
        + body
        + <span class="string">'&lt;/li>\n'</span>;
    }
    <span class="keyword">case</span> <span class="string">'html'</span>: {
      <span class="keyword">if</span> (options.sanitize) {
        <span class="keyword">return</span> inline.lexer(token.text);
      }
      <span class="keyword">return</span> !token.pre &amp;&amp; !options.pedantic
        ? inline.lexer(token.text)
        : token.text;
    }
    <span class="keyword">case</span> <span class="string">'paragraph'</span>: {
      <span class="keyword">return</span> <span class="string">'&lt;p>'</span>
        + inline.lexer(token.text)
        + <span class="string">'&lt;/p>\n'</span>;
    }
    <span class="keyword">case</span> <span class="string">'text'</span>: {
      <span class="keyword">return</span> <span class="string">'&lt;p>'</span>
        + parseText()
        + <span class="string">'&lt;/p>\n'</span>;
    }
  }
}

<span class="function"><span class="keyword">function</span> <span class="title">parseText</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> body = token.text
    , top;

  <span class="keyword">while</span> ((top = tokens[tokens.length-<span class="number">1</span>])
         &amp;&amp; top.type === <span class="string">'text'</span>) {
    body += <span class="string">'\n'</span> + next().text;
  }

  <span class="keyword">return</span> inline.lexer(body);
}

<span class="function"><span class="keyword">function</span> <span class="title">parse</span><span class="params">(src)</span> {</span>
  tokens = src.reverse();

  <span class="keyword">var</span> out = <span class="string">''</span>;
  <span class="keyword">while</span> (next()) {
    out += tok();
  }

  tokens = <span class="literal">null</span>;
  token = <span class="literal">null</span>;

  <span class="keyword">return</span> out;
}

<span class="comment">/**
 * Helpers
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">escape</span><span class="params">(html, encode)</span> {</span>
  <span class="keyword">return</span> html
    .replace(!encode ? <span class="regexp">/&amp;(?!#?\w+;)/g</span> : <span class="regexp">/&amp;/g</span>, <span class="string">'&amp;amp;'</span>)
    .replace(<span class="regexp">/&lt;/g</span>, <span class="string">'&amp;lt;'</span>)
    .replace(<span class="regexp">/>/g</span>, <span class="string">'&amp;gt;'</span>)
    .replace(<span class="regexp">/"/g</span>, <span class="string">'&amp;quot;'</span>)
    .replace(<span class="regexp">/'/g</span>, <span class="string">'&amp;#39;'</span>);
}

<span class="function"><span class="keyword">function</span> <span class="title">mangle</span><span class="params">(text)</span> {</span>
  <span class="keyword">var</span> out = <span class="string">''</span>
    , l = text.length
    , i = <span class="number">0</span>
    , ch;

  <span class="keyword">for</span> (; i &lt; l; i++) {
    ch = text.charCodeAt(i);
    <span class="keyword">if</span> (Math.random() > <span class="number">0.5</span>) {
      ch = <span class="string">'x'</span> + ch.toString(<span class="number">16</span>);
    }
    out += <span class="string">'&amp;#'</span> + ch + <span class="string">';'</span>;
  }

  <span class="keyword">return</span> out;
}

<span class="function"><span class="keyword">function</span> <span class="title">tag</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> tag = <span class="string">'(?!(?:'</span>
    + <span class="string">'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'</span>
    + <span class="string">'|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'</span>
    + <span class="string">'|span|br|wbr|ins|del|img)\\b)\\w+'</span>;

  <span class="keyword">return</span> tag;
}

<span class="function"><span class="keyword">function</span> <span class="title">replace</span><span class="params">(regex, opt)</span> {</span>
  regex = regex.source;
  opt = opt || <span class="string">''</span>;
  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">self</span><span class="params">(name, val)</span> {</span>
    <span class="keyword">if</span> (!name) <span class="keyword">return</span> <span class="keyword">new</span> RegExp(regex, opt);
    regex = regex.replace(name, val.source || val);
    <span class="keyword">return</span> self;
  };
}

<span class="function"><span class="keyword">function</span> <span class="title">noop</span><span class="params">()</span> {</span>}
noop.exec = noop;

<span class="comment">/**
 * Marked
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">marked</span><span class="params">(src, opt)</span> {</span>
  setOptions(opt);
  <span class="keyword">return</span> parse(block.lexer(src));
}

<span class="comment">/**
 * Options
 */</span>

<span class="keyword">var</span> options
  , defaults;

<span class="function"><span class="keyword">function</span> <span class="title">setOptions</span><span class="params">(opt)</span> {</span>
  <span class="keyword">if</span> (!opt) opt = defaults;
  <span class="keyword">if</span> (options === opt) <span class="keyword">return</span>;
  options = opt;

  <span class="keyword">if</span> (options.gfm) {
    block.fences = block.gfm.fences;
    block.paragraph = block.gfm.paragraph;
    inline.text = inline.gfm.text;
    inline.url = inline.gfm.url;
  } <span class="keyword">else</span> {
    block.fences = block.normal.fences;
    block.paragraph = block.normal.paragraph;
    inline.text = inline.normal.text;
    inline.url = inline.normal.url;
  }

  <span class="keyword">if</span> (options.pedantic) {
    inline.em = inline.pedantic.em;
    inline.strong = inline.pedantic.strong;
  } <span class="keyword">else</span> {
    inline.em = inline.normal.em;
    inline.strong = inline.normal.strong;
  }
}

marked.options =
marked.setOptions = <span class="keyword">function</span>(opt) {
  defaults = opt;
  setOptions(opt);
  <span class="keyword">return</span> marked;
};

marked.setOptions({
  gfm: <span class="literal">true</span>,
  pedantic: <span class="literal">false</span>,
  sanitize: <span class="literal">false</span>,
  highlight: <span class="literal">null</span>
});

<span class="comment">/**
 * Expose
 */</span>

marked.parser = <span class="keyword">function</span>(src, opt) {
  setOptions(opt);
  <span class="keyword">return</span> parse(src);
};

marked.lexer = <span class="keyword">function</span>(src, opt) {
  setOptions(opt);
  <span class="keyword">return</span> block.lexer(src);
};

marked.parse = marked;

<span class="keyword">if</span> (<span class="keyword">typeof</span> module !== <span class="string">'undefined'</span>) {
  module.exports = marked;
} <span class="keyword">else</span> {
  <span class="keyword">this</span>.marked = marked;
}

}).call(<span class="keyword">function</span>() {
  <span class="keyword">return</span> <span class="keyword">this</span> || (<span class="keyword">typeof</span> window !== <span class="string">'undefined'</span> ? window : global);
}());
</code></pre>