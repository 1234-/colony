<h1>mousetrap</h1>
<pre><code class="lang-js"><span class="comment">/**
 * Copyright 2012 Craig Campbell
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Mousetrap is a simple keyboard shortcut library for Javascript with
 * no external dependencies
 *
 * @version 1.1.2
 * @url craig.is/killing/mice
 */</span>

  <span class="comment">/**
   * mapping of special keycodes to their corresponding keys
   *
   * everything in this dictionary cannot use keypress events
   * so it has to be here to map to the correct keycodes for
   * keyup/keydown events
   *
   * @type {Object}
   */</span>
  <span class="keyword">var</span> _MAP = {
          <span class="number">8</span>: <span class="string">'backspace'</span>,
          <span class="number">9</span>: <span class="string">'tab'</span>,
          <span class="number">13</span>: <span class="string">'enter'</span>,
          <span class="number">16</span>: <span class="string">'shift'</span>,
          <span class="number">17</span>: <span class="string">'ctrl'</span>,
          <span class="number">18</span>: <span class="string">'alt'</span>,
          <span class="number">20</span>: <span class="string">'capslock'</span>,
          <span class="number">27</span>: <span class="string">'esc'</span>,
          <span class="number">32</span>: <span class="string">'space'</span>,
          <span class="number">33</span>: <span class="string">'pageup'</span>,
          <span class="number">34</span>: <span class="string">'pagedown'</span>,
          <span class="number">35</span>: <span class="string">'end'</span>,
          <span class="number">36</span>: <span class="string">'home'</span>,
          <span class="number">37</span>: <span class="string">'left'</span>,
          <span class="number">38</span>: <span class="string">'up'</span>,
          <span class="number">39</span>: <span class="string">'right'</span>,
          <span class="number">40</span>: <span class="string">'down'</span>,
          <span class="number">45</span>: <span class="string">'ins'</span>,
          <span class="number">46</span>: <span class="string">'del'</span>,
          <span class="number">91</span>: <span class="string">'meta'</span>,
          <span class="number">93</span>: <span class="string">'meta'</span>,
          <span class="number">224</span>: <span class="string">'meta'</span>
      },

      <span class="comment">/**
       * mapping for special characters so they can support
       *
       * this dictionary is only used incase you want to bind a
       * keyup or keydown event to one of these keys
       *
       * @type {Object}
       */</span>
      _KEYCODE_MAP = {
          <span class="number">106</span>: <span class="string">'*'</span>,
          <span class="number">107</span>: <span class="string">'+'</span>,
          <span class="number">109</span>: <span class="string">'-'</span>,
          <span class="number">110</span>: <span class="string">'.'</span>,
          <span class="number">111</span> : <span class="string">'/'</span>,
          <span class="number">186</span>: <span class="string">';'</span>,
          <span class="number">187</span>: <span class="string">'='</span>,
          <span class="number">188</span>: <span class="string">','</span>,
          <span class="number">189</span>: <span class="string">'-'</span>,
          <span class="number">190</span>: <span class="string">'.'</span>,
          <span class="number">191</span>: <span class="string">'/'</span>,
          <span class="number">192</span>: <span class="string">'`'</span>,
          <span class="number">219</span>: <span class="string">'['</span>,
          <span class="number">220</span>: <span class="string">'\\'</span>,
          <span class="number">221</span>: <span class="string">']'</span>,
          <span class="number">222</span>: <span class="string">'\''</span>
      },

      <span class="comment">/**
       * this is a mapping of keys that require shift on a US keypad
       * back to the non shift equivelents
       *
       * this is so you can use keyup events with these keys
       *
       * note that this will only work reliably on US keyboards
       *
       * @type {Object}
       */</span>
      _SHIFT_MAP = {
          <span class="string">'~'</span>: <span class="string">'`'</span>,
          <span class="string">'!'</span>: <span class="string">'1'</span>,
          <span class="string">'@'</span>: <span class="string">'2'</span>,
          <span class="string">'#'</span>: <span class="string">'3'</span>,
          <span class="string">'$'</span>: <span class="string">'4'</span>,
          <span class="string">'%'</span>: <span class="string">'5'</span>,
          <span class="string">'^'</span>: <span class="string">'6'</span>,
          <span class="string">'&amp;'</span>: <span class="string">'7'</span>,
          <span class="string">'*'</span>: <span class="string">'8'</span>,
          <span class="string">'('</span>: <span class="string">'9'</span>,
          <span class="string">')'</span>: <span class="string">'0'</span>,
          <span class="string">'_'</span>: <span class="string">'-'</span>,
          <span class="string">'+'</span>: <span class="string">'='</span>,
          <span class="string">':'</span>: <span class="string">';'</span>,
          <span class="string">'\"'</span>: <span class="string">'\''</span>,
          <span class="string">'&lt;'</span>: <span class="string">','</span>,
          <span class="string">'>'</span>: <span class="string">'.'</span>,
          <span class="string">'?'</span>: <span class="string">'/'</span>,
          <span class="string">'|'</span>: <span class="string">'\\'</span>
      },

      <span class="comment">/**
       * this is a list of special strings you can use to map
       * to modifier keys when you specify your keyboard shortcuts
       *
       * @type {Object}
       */</span>
      _SPECIAL_ALIASES = {
          <span class="string">'option'</span>: <span class="string">'alt'</span>,
          <span class="string">'command'</span>: <span class="string">'meta'</span>,
          <span class="string">'return'</span>: <span class="string">'enter'</span>,
          <span class="string">'escape'</span>: <span class="string">'esc'</span>
      },

      <span class="comment">/**
       * variable to store the flipped version of _MAP from above
       * needed to check if we should use keypress or not when no action
       * is specified
       *
       * @type {Object|undefined}
       */</span>
      _REVERSE_MAP,

      <span class="comment">/**
       * a list of all the callbacks setup via Mousetrap.bind()
       *
       * @type {Object}
       */</span>
      _callbacks = {},

      <span class="comment">/**
       * direct map of string combinations to callbacks used for trigger()
       *
       * @type {Object}
       */</span>
      _direct_map = {},

      <span class="comment">/**
       * keeps track of what level each sequence is at since multiple
       * sequences can start out with the same sequence
       *
       * @type {Object}
       */</span>
      _sequence_levels = {},

      <span class="comment">/**
       * variable to store the setTimeout call
       *
       * @type {null|number}
       */</span>
      _reset_timer,

      <span class="comment">/**
       * temporary state where we will ignore the next keyup
       *
       * @type {boolean|string}
       */</span>
      _ignore_next_keyup = <span class="literal">false</span>,

      <span class="comment">/**
       * are we currently inside of a sequence?
       * type of action ("keyup" or "keydown" or "keypress") or false
       *
       * @type {boolean|string}
       */</span>
      _inside_sequence = <span class="literal">false</span>;

  <span class="comment">/**
   * loop through the f keys, f1 to f19 and add them to the map
   * programatically
   */</span>
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="number">20</span>; ++i) {
      _MAP[<span class="number">111</span> + i] = <span class="string">'f'</span> + i;
  }

  <span class="comment">/**
   * loop through to map numbers on the numeric keypad
   */</span>
  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i) {
      _MAP[i + <span class="number">96</span>] = i;
  }

  <span class="comment">/**
   * cross browser add event method
   *
   * @param {Element|HTMLDocument} object
   * @param {string} type
   * @param {Function} callback
   * @returns void
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">_addEvent</span><span class="params">(object, type, callback)</span> {</span>
      <span class="keyword">if</span> (object.addEventListener) {
          <span class="keyword">return</span> object.addEventListener(type, callback, <span class="literal">false</span>);
      }

      object.attachEvent(<span class="string">'on'</span> + type, callback);
  }

  <span class="comment">/**
   * takes the event and returns the key character
   *
   * @param {Event} e
   * @return {string}
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">_characterFromEvent</span><span class="params">(e)</span> {</span>

      <span class="comment">// for keypress events we should return the character as is</span>
      <span class="keyword">if</span> (e.type == <span class="string">'keypress'</span>) {
          <span class="keyword">return</span> String.fromCharCode(e.which);
      }

      <span class="comment">// for non keypress events the special maps are needed</span>
      <span class="keyword">if</span> (_MAP[e.which]) {
          <span class="keyword">return</span> _MAP[e.which];
      }

      <span class="keyword">if</span> (_KEYCODE_MAP[e.which]) {
          <span class="keyword">return</span> _KEYCODE_MAP[e.which];
      }

      <span class="comment">// if it is not in the special map</span>
      <span class="keyword">return</span> String.fromCharCode(e.which).toLowerCase();
  }

  <span class="comment">/**
   * should we stop this event before firing off callbacks
   *
   * @param {Event} e
   * @return {boolean}
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">_stop</span><span class="params">(e)</span> {</span>
      <span class="keyword">var</span> element = e.target || e.srcElement,
          tag_name = element.tagName;

      <span class="comment">// if the element has the class "mousetrap" then no need to stop</span>
      <span class="keyword">if</span> ((<span class="string">' '</span> + element.className + <span class="string">' '</span>).indexOf(<span class="string">' mousetrap '</span>) > -<span class="number">1</span>) {
          <span class="keyword">return</span> <span class="literal">false</span>;
      }

      <span class="comment">// stop for input, select, and textarea</span>
      <span class="keyword">return</span> tag_name == <span class="string">'INPUT'</span> || tag_name == <span class="string">'SELECT'</span> || tag_name == <span class="string">'TEXTAREA'</span> || (element.contentEditable &amp;&amp; element.contentEditable == <span class="string">'true'</span>);
  }

  <span class="comment">/**
   * checks if two arrays are equal
   *
   * @param {Array} modifiers1
   * @param {Array} modifiers2
   * @returns {boolean}
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">_modifiersMatch</span><span class="params">(modifiers1, modifiers2)</span> {</span>
      <span class="keyword">return</span> modifiers1.sort().join(<span class="string">','</span>) === modifiers2.sort().join(<span class="string">','</span>);
  }

  <span class="comment">/**
   * resets all sequence counters except for the ones passed in
   *
   * @param {Object} do_not_reset
   * @returns void
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">_resetSequences</span><span class="params">(do_not_reset)</span> {</span>
      do_not_reset = do_not_reset || {};

      <span class="keyword">var</span> active_sequences = <span class="literal">false</span>,
          key;

      <span class="keyword">for</span> (key <span class="keyword">in</span> _sequence_levels) {
          <span class="keyword">if</span> (do_not_reset[key]) {
              active_sequences = <span class="literal">true</span>;
              <span class="keyword">continue</span>;
          }
          _sequence_levels[key] = <span class="number">0</span>;
      }

      <span class="keyword">if</span> (!active_sequences) {
          _inside_sequence = <span class="literal">false</span>;
      }
  }

  <span class="comment">/**
   * finds all callbacks that match based on the keycode, modifiers,
   * and action
   *
   * @param {string} character
   * @param {Array} modifiers
   * @param {string} action
   * @param {boolean=} remove - should we remove any matches
   * @param {string=} combination
   * @returns {Array}
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">_getMatches</span><span class="params">(character, modifiers, action, remove, combination)</span> {</span>
      <span class="keyword">var</span> i,
          callback,
          matches = [];

      <span class="comment">// if there are no events related to this keycode</span>
      <span class="keyword">if</span> (!_callbacks[character]) {
          <span class="keyword">return</span> [];
      }

      <span class="comment">// if a modifier key is coming up on its own we should allow it</span>
      <span class="keyword">if</span> (action == <span class="string">'keyup'</span> &amp;&amp; _isModifier(character)) {
          modifiers = [character];
      }

      <span class="comment">// loop through all callbacks for the key that was pressed</span>
      <span class="comment">// and see if any of them match</span>
      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; _callbacks[character].length; ++i) {
          callback = _callbacks[character][i];

          <span class="comment">// if this is a sequence but it is not at the right level</span>
          <span class="comment">// then move onto the next match</span>
          <span class="keyword">if</span> (callback.seq &amp;&amp; _sequence_levels[callback.seq] != callback.level) {
              <span class="keyword">continue</span>;
          }

          <span class="comment">// if the action we are looking for doesn't match the action we got</span>
          <span class="comment">// then we should keep going</span>
          <span class="keyword">if</span> (action != callback.action) {
              <span class="keyword">continue</span>;
          }

          <span class="comment">// if this is a keypress event that means that we need to only</span>
          <span class="comment">// look at the character, otherwise check the modifiers as</span>
          <span class="comment">// well</span>
          <span class="keyword">if</span> (action == <span class="string">'keypress'</span> || _modifiersMatch(modifiers, callback.modifiers)) {

              <span class="comment">// remove is used so if you change your mind and call bind a</span>
              <span class="comment">// second time with a new function the first one is overwritten</span>
              <span class="keyword">if</span> (remove &amp;&amp; callback.combo == combination) {
                  _callbacks[character].splice(i, <span class="number">1</span>);
              }

              matches.push(callback);
          }
      }

      <span class="keyword">return</span> matches;
  }

  <span class="comment">/**
   * takes a key event and figures out what the modifiers are
   *
   * @param {Event} e
   * @returns {Array}
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">_eventModifiers</span><span class="params">(e)</span> {</span>
      <span class="keyword">var</span> modifiers = [];

      <span class="keyword">if</span> (e.shiftKey) {
          modifiers.push(<span class="string">'shift'</span>);
      }

      <span class="keyword">if</span> (e.altKey) {
          modifiers.push(<span class="string">'alt'</span>);
      }

      <span class="keyword">if</span> (e.ctrlKey) {
          modifiers.push(<span class="string">'ctrl'</span>);
      }

      <span class="keyword">if</span> (e.metaKey) {
          modifiers.push(<span class="string">'meta'</span>);
      }

      <span class="keyword">return</span> modifiers;
  }

  <span class="comment">/**
   * actually calls the callback function
   *
   * if your callback function returns false this will use the jquery
   * convention - prevent default and stop propogation on the event
   *
   * @param {Function} callback
   * @param {Event} e
   * @returns void
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">_fireCallback</span><span class="params">(callback, e)</span> {</span>
      <span class="keyword">if</span> (callback(e) === <span class="literal">false</span>) {
          <span class="keyword">if</span> (e.preventDefault) {
              e.preventDefault();
          }

          <span class="keyword">if</span> (e.stopPropagation) {
              e.stopPropagation();
          }

          e.returnValue = <span class="literal">false</span>;
          e.cancelBubble = <span class="literal">true</span>;
      }
  }

  <span class="comment">/**
   * handles a character key event
   *
   * @param {string} character
   * @param {Event} e
   * @returns void
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">_handleCharacter</span><span class="params">(character, e)</span> {</span>

      <span class="comment">// if this event should not happen stop here</span>
      <span class="keyword">if</span> (_stop(e)) {
          <span class="keyword">return</span>;
      }

      <span class="keyword">var</span> callbacks = _getMatches(character, _eventModifiers(e), e.type),
          i,
          do_not_reset = {},
          processed_sequence_callback = <span class="literal">false</span>;

      <span class="comment">// loop through matching callbacks for this key event</span>
      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; callbacks.length; ++i) {

          <span class="comment">// fire for all sequence callbacks</span>
          <span class="comment">// this is because if for example you have multiple sequences</span>
          <span class="comment">// bound such as "g i" and "g t" they both need to fire the</span>
          <span class="comment">// callback for matching g cause otherwise you can only ever</span>
          <span class="comment">// match the first one</span>
          <span class="keyword">if</span> (callbacks[i].seq) {
              processed_sequence_callback = <span class="literal">true</span>;

              <span class="comment">// keep a list of which sequences were matches for later</span>
              do_not_reset[callbacks[i].seq] = <span class="number">1</span>;
              _fireCallback(callbacks[i].callback, e);
              <span class="keyword">continue</span>;
          }

          <span class="comment">// if there were no sequence matches but we are still here</span>
          <span class="comment">// that means this is a regular match so we should fire that</span>
          <span class="keyword">if</span> (!processed_sequence_callback &amp;&amp; !_inside_sequence) {
              _fireCallback(callbacks[i].callback, e);
          }
      }

      <span class="comment">// if you are inside of a sequence and the key you are pressing</span>
      <span class="comment">// is not a modifier key then we should reset all sequences</span>
      <span class="comment">// that were not matched by this key event</span>
      <span class="keyword">if</span> (e.type == _inside_sequence &amp;&amp; !_isModifier(character)) {
          _resetSequences(do_not_reset);
      }
  }

  <span class="comment">/**
   * handles a keydown event
   *
   * @param {Event} e
   * @returns void
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">_handleKey</span><span class="params">(e)</span> {</span>

      <span class="comment">// normalize e.which for key events</span>
      <span class="comment">// @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion</span>
      e.which = <span class="keyword">typeof</span> e.which == <span class="string">"number"</span> ? e.which : e.keyCode;

      <span class="keyword">var</span> character = _characterFromEvent(e);

      <span class="comment">// no character found then stop</span>
      <span class="keyword">if</span> (!character) {
          <span class="keyword">return</span>;
      }

      <span class="keyword">if</span> (e.type == <span class="string">'keyup'</span> &amp;&amp; _ignore_next_keyup == character) {
          _ignore_next_keyup = <span class="literal">false</span>;
          <span class="keyword">return</span>;
      }

      _handleCharacter(character, e);
  }

  <span class="comment">/**
   * determines if the keycode specified is a modifier key or not
   *
   * @param {string} key
   * @returns {boolean}
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">_isModifier</span><span class="params">(key)</span> {</span>
      <span class="keyword">return</span> key == <span class="string">'shift'</span> || key == <span class="string">'ctrl'</span> || key == <span class="string">'alt'</span> || key == <span class="string">'meta'</span>;
  }

  <span class="comment">/**
   * called to set a 1 second timeout on the specified sequence
   *
   * this is so after each key press in the sequence you have 1 second
   * to press the next key before you have to start over
   *
   * @returns void
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">_resetSequenceTimer</span><span class="params">()</span> {</span>
      clearTimeout(_reset_timer);
      _reset_timer = setTimeout(_resetSequences, <span class="number">1000</span>);
  }

  <span class="comment">/**
   * reverses the map lookup so that we can look for specific keys
   * to see what can and can't use keypress
   *
   * @return {Object}
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">_getReverseMap</span><span class="params">()</span> {</span>
      <span class="keyword">if</span> (!_REVERSE_MAP) {
          _REVERSE_MAP = {};
          <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> _MAP) {

              <span class="comment">// pull out the numeric keypad from here cause keypress should</span>
              <span class="comment">// be able to detect the keys from the character</span>
              <span class="keyword">if</span> (key > <span class="number">95</span> &amp;&amp; key &lt; <span class="number">112</span>) {
                  <span class="keyword">continue</span>;
              }

              <span class="keyword">if</span> (_MAP.hasOwnProperty(key)) {
                  _REVERSE_MAP[_MAP[key]] = key;
              }
          }
      }
      <span class="keyword">return</span> _REVERSE_MAP;
  }

  <span class="comment">/**
   * picks the best action based on the key combination
   *
   * @param {string} key - character for key
   * @param {Array} modifiers
   * @param {string=} action passed in
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">_pickBestAction</span><span class="params">(key, modifiers, action)</span> {</span>

      <span class="comment">// if no action was picked in we should try to pick the one</span>
      <span class="comment">// that we think would work best for this key</span>
      <span class="keyword">if</span> (!action) {
          action = _getReverseMap()[key] ? <span class="string">'keydown'</span> : <span class="string">'keypress'</span>;
      }

      <span class="comment">// modifier keys don't work as expected with keypress,</span>
      <span class="comment">// switch to keydown</span>
      <span class="keyword">if</span> (action == <span class="string">'keypress'</span> &amp;&amp; modifiers.length) {
          action = <span class="string">'keydown'</span>;
      }

      <span class="keyword">return</span> action;
  }

  <span class="comment">/**
   * binds a key sequence to an event
   *
   * @param {string} combo - combo specified in bind call
   * @param {Array} keys
   * @param {Function} callback
   * @param {string=} action
   * @returns void
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">_bindSequence</span><span class="params">(combo, keys, callback, action)</span> {</span>

      <span class="comment">// start off by adding a sequence level record for this combination</span>
      <span class="comment">// and setting the level to 0</span>
      _sequence_levels[combo] = <span class="number">0</span>;

      <span class="comment">// if there is no action pick the best one for the first key</span>
      <span class="comment">// in the sequence</span>
      <span class="keyword">if</span> (!action) {
          action = _pickBestAction(keys[<span class="number">0</span>], []);
      }

      <span class="comment">/**
       * callback to increase the sequence level for this sequence and reset
       * all other sequences that were active
       *
       * @param {Event} e
       * @returns void
       */</span>
      <span class="keyword">var</span> _increaseSequence = <span class="keyword">function</span>(e) {
              _inside_sequence = action;
              ++_sequence_levels[combo];
              _resetSequenceTimer();
          },

          <span class="comment">/**
           * wraps the specified callback inside of another function in order
           * to reset all sequence counters as soon as this sequence is done
           *
           * @param {Event} e
           * @returns void
           */</span>
          _callbackAndReset = <span class="keyword">function</span>(e) {
              _fireCallback(callback, e);

              <span class="comment">// we should ignore the next key up if the action is key down</span>
              <span class="comment">// or keypress.  this is so if you finish a sequence and</span>
              <span class="comment">// release the key the final key will not trigger a keyup</span>
              <span class="keyword">if</span> (action !== <span class="string">'keyup'</span>) {
                  _ignore_next_keyup = _characterFromEvent(e);
              }

              <span class="comment">// weird race condition if a sequence ends with the key</span>
              <span class="comment">// another sequence begins with</span>
              setTimeout(_resetSequences, <span class="number">10</span>);
          },
          i;

      <span class="comment">// loop through keys one at a time and bind the appropriate callback</span>
      <span class="comment">// function.  for any key leading up to the final one it should</span>
      <span class="comment">// increase the sequence. after the final, it should reset all sequences</span>
      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; keys.length; ++i) {
          _bindSingle(keys[i], i &lt; keys.length - <span class="number">1</span> ? _increaseSequence : _callbackAndReset, action, combo, i);
      }
  }

  <span class="comment">/**
   * binds a single keyboard combination
   *
   * @param {string} combination
   * @param {Function} callback
   * @param {string=} action
   * @param {string=} sequence_name - name of sequence if part of sequence
   * @param {number=} level - what part of the sequence the command is
   * @returns void
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">_bindSingle</span><span class="params">(combination, callback, action, sequence_name, level)</span> {</span>

      <span class="comment">// make sure multiple spaces in a row become a single space</span>
      combination = combination.replace(<span class="regexp">/\s+/g</span>, <span class="string">' '</span>);

      <span class="keyword">var</span> sequence = combination.split(<span class="string">' '</span>),
          i,
          key,
          keys,
          modifiers = [];

      <span class="comment">// if this pattern is a sequence of keys then run through this method</span>
      <span class="comment">// to reprocess each pattern one key at a time</span>
      <span class="keyword">if</span> (sequence.length > <span class="number">1</span>) {
          <span class="keyword">return</span> _bindSequence(combination, sequence, callback, action);
      }

      <span class="comment">// take the keys from this pattern and figure out what the actual</span>
      <span class="comment">// pattern is all about</span>
      keys = combination === <span class="string">'+'</span> ? [<span class="string">'+'</span>] : combination.split(<span class="string">'+'</span>);

      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; keys.length; ++i) {
          key = keys[i];

          <span class="comment">// normalize key names</span>
          <span class="keyword">if</span> (_SPECIAL_ALIASES[key]) {
              key = _SPECIAL_ALIASES[key];
          }

          <span class="comment">// if this is not a keypress event then we should</span>
          <span class="comment">// be smart about using shift keys</span>
          <span class="comment">// this will only work for US keyboards however</span>
          <span class="keyword">if</span> (action &amp;&amp; action != <span class="string">'keypress'</span> &amp;&amp; _SHIFT_MAP[key]) {
              key = _SHIFT_MAP[key];
              modifiers.push(<span class="string">'shift'</span>);
          }

          <span class="comment">// if this key is a modifier then add it to the list of modifiers</span>
          <span class="keyword">if</span> (_isModifier(key)) {
              modifiers.push(key);
          }
      }

      <span class="comment">// depending on what the key combination is</span>
      <span class="comment">// we will try to pick the best event for it</span>
      action = _pickBestAction(key, modifiers, action);

      <span class="comment">// make sure to initialize array if this is the first time</span>
      <span class="comment">// a callback is added for this key</span>
      <span class="keyword">if</span> (!_callbacks[key]) {
          _callbacks[key] = [];
      }

      <span class="comment">// remove an existing match if there is one</span>
      _getMatches(key, modifiers, action, !sequence_name, combination);

      <span class="comment">// add this call back to the array</span>
      <span class="comment">// if it is a sequence put it at the beginning</span>
      <span class="comment">// if not put it at the end</span>
      <span class="comment">//</span>
      <span class="comment">// this is important because the way these are processed expects</span>
      <span class="comment">// the sequence ones to come first</span>
      _callbacks[key][sequence_name ? <span class="string">'unshift'</span> : <span class="string">'push'</span>]({
          callback: callback,
          modifiers: modifiers,
          action: action,
          seq: sequence_name,
          level: level,
          combo: combination
      });
  }

  <span class="comment">/**
   * binds multiple combinations to the same callback
   *
   * @param {Array} combinations
   * @param {Function} callback
   * @param {string|undefined} action
   * @returns void
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">_bindMultiple</span><span class="params">(combinations, callback, action)</span> {</span>
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; combinations.length; ++i) {
          _bindSingle(combinations[i], callback, action);
      }
  }

  <span class="comment">// start!</span>
  _addEvent(document, <span class="string">'keypress'</span>, _handleKey);
  _addEvent(document, <span class="string">'keydown'</span>, _handleKey);
  _addEvent(document, <span class="string">'keyup'</span>, _handleKey);

  <span class="keyword">var</span> mousetrap = {

      <span class="comment">/**
       * binds an event to mousetrap
       *
       * can be a single key, a combination of keys separated with +,
       * a comma separated list of keys, an array of keys, or
       * a sequence of keys separated by spaces
       *
       * be sure to list the modifier keys first to make sure that the
       * correct key ends up getting bound (the last key in the pattern)
       *
       * @param {string|Array} keys
       * @param {Function} callback
       * @param {string=} action - 'keypress', 'keydown', or 'keyup'
       * @returns void
       */</span>
      bind: <span class="keyword">function</span>(keys, callback, action) {
          _bindMultiple(keys <span class="keyword">instanceof</span> Array ? keys : [keys], callback, action);
          _direct_map[keys + <span class="string">':'</span> + action] = callback;
          <span class="keyword">return</span> <span class="keyword">this</span>;
      },

      <span class="comment">/**
       * unbinds an event to mousetrap
       *
       * the unbinding sets the callback function of the specified key combo
       * to an empty function and deletes the corresponding key in the
       * _direct_map dict.
       *
       * the keycombo+action has to be exactly the same as
       * it was defined in the bind method
       *
       * TODO: actually remove this from the _callbacks dictionary instead
       * of binding an empty function
       *
       * @param {string|Array} keys
       * @param {string} action
       * @returns void
       */</span>
      unbind: <span class="keyword">function</span>(keys, action) {
          <span class="keyword">if</span> (_direct_map[keys + <span class="string">':'</span> + action]) {
              <span class="keyword">delete</span> _direct_map[keys + <span class="string">':'</span> + action];
              <span class="keyword">this</span>.bind(keys, <span class="keyword">function</span>() {}, action);
          }
          <span class="keyword">return</span> <span class="keyword">this</span>;
      },

      <span class="comment">/**
       * triggers an event that has already been bound
       *
       * @param {string} keys
       * @param {string=} action
       * @returns void
       */</span>
      trigger: <span class="keyword">function</span>(keys, action) {
          _direct_map[keys + <span class="string">':'</span> + action]();
          <span class="keyword">return</span> <span class="keyword">this</span>;
      },

      <span class="comment">/**
       * resets the library back to its initial state.  this is useful
       * if you want to clear out the current keyboard shortcuts and bind
       * new ones - for example if you switch to another page
       *
       * @returns void
       */</span>
      reset: <span class="keyword">function</span>() {
          _callbacks = {};
          _direct_map = {};
          <span class="keyword">return</span> <span class="keyword">this</span>;
      }
  };

module.exports = mousetrap;

</code></pre>