<h1>request</h1>
<pre><code class="lang-js"><span class="comment">// Copyright 2010-2012 Mikeal Rogers</span>
<span class="comment">//</span>
<span class="comment">//    Licensed under the Apache License, Version 2.0 (the "License");</span>
<span class="comment">//    you may not use this file except in compliance with the License.</span>
<span class="comment">//    You may obtain a copy of the License at</span>
<span class="comment">//</span>
<span class="comment">//        http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="comment">//</span>
<span class="comment">//    Unless required by applicable law or agreed to in writing, software</span>
<span class="comment">//    distributed under the License is distributed on an "AS IS" BASIS,</span>
<span class="comment">//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="comment">//    See the License for the specific language governing permissions and</span>
<span class="comment">//    limitations under the License.</span>

<span class="keyword">var</span> http = require(<span class="string">'http'</span>)
  , https = <span class="literal">false</span>
  , tls = <span class="literal">false</span>
  , url = require(<span class="string">'url'</span>)
  , util = require(<span class="string">'util'</span>)
  , stream = require(<span class="string">'stream'</span>)
  , qs = require(<span class="string">'querystring'</span>)
  , oauth = require(<span class="string">'./oauth'</span>)
  , uuid = require(<span class="string">'./uuid'</span>)
  , ForeverAgent = require(<span class="string">'./forever'</span>)
  , Cookie = require(<span class="string">'./vendor/cookie'</span>)
  , CookieJar = require(<span class="string">'./vendor/cookie/jar'</span>)
  , cookieJar = <span class="keyword">new</span> CookieJar
  , tunnel = require(<span class="string">'./tunnel'</span>)
  , aws = require(<span class="string">'./aws'</span>)
  
  , mime = require(<span class="string">'mime'</span>)
  , FormData = require(<span class="string">'form-data'</span>)
  ;
  
<span class="keyword">if</span> (process.logging) {
  <span class="keyword">var</span> log = process.logging(<span class="string">'request'</span>)
}

<span class="keyword">try</span> {
  https = require(<span class="string">'https'</span>)
} <span class="keyword">catch</span> (e) {}

<span class="keyword">try</span> {
  tls = require(<span class="string">'tls'</span>)
} <span class="keyword">catch</span> (e) {}

<span class="function"><span class="keyword">function</span> <span class="title">toBase64</span> <span class="params">(str)</span> {</span>
  <span class="keyword">return</span> (<span class="keyword">new</span> Buffer(str || <span class="string">""</span>, <span class="string">"ascii"</span>)).toString(<span class="string">"base64"</span>)
}

<span class="comment">// Hacky fix for pre-0.4.4 https</span>
<span class="keyword">if</span> (https &amp;&amp; !https.Agent) {
  https.Agent = <span class="function"><span class="keyword">function</span> <span class="params">(options)</span> {</span>
    http.Agent.call(<span class="keyword">this</span>, options)
  }
  util.inherits(https.Agent, http.Agent)
  https.Agent.prototype._getConnection = <span class="function"><span class="keyword">function</span> <span class="params">(host, port, cb)</span> {</span>
    <span class="keyword">var</span> s = tls.connect(port, host, <span class="keyword">this</span>.options, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
      <span class="comment">// do other checks here?</span>
      <span class="keyword">if</span> (cb) cb()
    })
    <span class="keyword">return</span> s
  }
}

<span class="function"><span class="keyword">function</span> <span class="title">isReadStream</span> <span class="params">(rs)</span> {</span>
  <span class="keyword">if</span> (rs.readable &amp;&amp; rs.path &amp;&amp; rs.mode) {
    <span class="keyword">return</span> <span class="literal">true</span>
  }
}

<span class="function"><span class="keyword">function</span> <span class="title">copy</span> <span class="params">(obj)</span> {</span>
  <span class="keyword">var</span> o = {}
  Object.keys(obj).forEach(<span class="function"><span class="keyword">function</span> <span class="params">(i)</span> {</span>
    o[i] = obj[i]
  })
  <span class="keyword">return</span> o
}

<span class="keyword">var</span> isUrl = <span class="regexp">/^https?:/</span>

<span class="keyword">var</span> globalPool = {}

<span class="function"><span class="keyword">function</span> <span class="title">Request</span> <span class="params">(options)</span> {</span>
  stream.Stream.call(<span class="keyword">this</span>)
  <span class="keyword">this</span>.readable = <span class="literal">true</span>
  <span class="keyword">this</span>.writable = <span class="literal">true</span>

  <span class="keyword">if</span> (<span class="keyword">typeof</span> options === <span class="string">'string'</span>) {
    options = {uri:options}
  }
  
  <span class="keyword">var</span> reserved = Object.keys(Request.prototype)
  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> options) {
    <span class="keyword">if</span> (reserved.indexOf(i) === -<span class="number">1</span>) {
      <span class="keyword">this</span>[i] = options[i]
    } <span class="keyword">else</span> {
      <span class="keyword">if</span> (<span class="keyword">typeof</span> options[i] === <span class="string">'function'</span>) {
        <span class="keyword">delete</span> options[i]
      }
    }
  }
  options = copy(options)
  
  <span class="keyword">this</span>.init(options)
}
util.inherits(Request, stream.Stream)
Request.prototype.init = <span class="function"><span class="keyword">function</span> <span class="params">(options)</span> {</span>
  <span class="keyword">var</span> self = <span class="keyword">this</span>
  
  <span class="keyword">if</span> (!options) options = {}
  <span class="keyword">if</span> (process.env.NODE_DEBUG &amp;&amp; <span class="regexp">/request/</span>.test(process.env.NODE_DEBUG)) console.error(<span class="string">'REQUEST'</span>, options)
  <span class="keyword">if</span> (!self.pool &amp;&amp; self.pool !== <span class="literal">false</span>) self.pool = globalPool
  self.dests = []
  self.__isRequestRequest = <span class="literal">true</span>
  
  <span class="comment">// Protect against double callback</span>
  <span class="keyword">if</span> (!self._callback &amp;&amp; self.callback) {
    self._callback = self.callback
    self.callback = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
      <span class="keyword">if</span> (self._callbackCalled) <span class="keyword">return</span> <span class="comment">// Print a warning maybe?</span>
      self._callback.apply(self, arguments)
      self._callbackCalled = <span class="literal">true</span>
    }
    self.on(<span class="string">'error'</span>, self.callback.bind())
    self.on(<span class="string">'complete'</span>, self.callback.bind(self, <span class="literal">null</span>))
  }

  <span class="keyword">if</span> (self.url) {
    <span class="comment">// People use this property instead all the time so why not just support it.</span>
    self.uri = self.url
    <span class="keyword">delete</span> self.url
  }

  <span class="keyword">if</span> (!self.uri) {
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"options.uri is a required argument"</span>)
  } <span class="keyword">else</span> {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> self.uri == <span class="string">"string"</span>) self.uri = url.parse(self.uri)
  }
  <span class="keyword">if</span> (self.proxy) {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> self.proxy == <span class="string">'string'</span>) self.proxy = url.parse(self.proxy)

    <span class="comment">// do the HTTP CONNECT dance using koichik/node-tunnel</span>
    <span class="keyword">if</span> (http.globalAgent &amp;&amp; self.uri.protocol === <span class="string">"https:"</span>) {
      <span class="keyword">var</span> tunnelFn = self.proxy.protocol === <span class="string">"http:"</span>
                   ? tunnel.httpsOverHttp : tunnel.httpsOverHttps

      <span class="keyword">var</span> tunnelOptions = { proxy: { host: self.proxy.hostname
                                   , port: +self.proxy.port
                                   , proxyAuth: self.proxy.auth }
                          , ca: <span class="keyword">this</span>.ca }

      self.agent = tunnelFn(tunnelOptions)
      self.tunnel = <span class="literal">true</span>
    }
  }

  <span class="keyword">if</span> (!self.uri.host || !self.uri.pathname) {
    <span class="comment">// Invalid URI: it may generate lot of bad errors, like "TypeError: Cannot call method 'indexOf' of undefined" in CookieJar</span>
    <span class="comment">// Detect and reject it as soon as possible</span>
    <span class="keyword">var</span> faultyUri = url.format(self.uri)
    <span class="keyword">var</span> message = <span class="string">'Invalid URI "'</span> + faultyUri + <span class="string">'"'</span>
    <span class="keyword">if</span> (Object.keys(options).length === <span class="number">0</span>) {
      <span class="comment">// No option ? This can be the sign of a redirect</span>
      <span class="comment">// As this is a case where the user cannot do anything (he didn't call request directly with this URL)</span>
      <span class="comment">// he should be warned that it can be caused by a redirection (can save some hair)</span>
      message += <span class="string">'. This can be caused by a crappy redirection.'</span>
    }
    self.emit(<span class="string">'error'</span>, <span class="keyword">new</span> Error(message))
    <span class="keyword">return</span> <span class="comment">// This error was fatal</span>
  }

  self._redirectsFollowed = self._redirectsFollowed || <span class="number">0</span>
  self.maxRedirects = (self.maxRedirects !== <span class="literal">undefined</span>) ? self.maxRedirects : <span class="number">10</span>
  self.followRedirect = (self.followRedirect !== <span class="literal">undefined</span>) ? self.followRedirect : <span class="literal">true</span>
  self.followAllRedirects = (self.followAllRedirects !== <span class="literal">undefined</span>) ? self.followAllRedirects : <span class="literal">false</span>;
  <span class="keyword">if</span> (self.followRedirect || self.followAllRedirects)
    self.redirects = self.redirects || []

  self.headers = self.headers ? copy(self.headers) : {}

  self.setHost = <span class="literal">false</span>
  <span class="keyword">if</span> (!self.headers.host) {
    self.headers.host = self.uri.hostname
    <span class="keyword">if</span> (self.uri.port) {
      <span class="keyword">if</span> ( !(self.uri.port === <span class="number">80</span> &amp;&amp; self.uri.protocol === <span class="string">'http:'</span>) &amp;&amp;
           !(self.uri.port === <span class="number">443</span> &amp;&amp; self.uri.protocol === <span class="string">'https:'</span>) )
      self.headers.host += (<span class="string">':'</span>+self.uri.port)
    }
    self.setHost = <span class="literal">true</span>
  }
  
  self.jar(self._jar || options.jar)

  <span class="keyword">if</span> (!self.uri.pathname) {self.uri.pathname = <span class="string">'/'</span>}
  <span class="keyword">if</span> (!self.uri.port) {
    <span class="keyword">if</span> (self.uri.protocol == <span class="string">'http:'</span>) {self.uri.port = <span class="number">80</span>}
    <span class="keyword">else</span> <span class="keyword">if</span> (self.uri.protocol == <span class="string">'https:'</span>) {self.uri.port = <span class="number">443</span>}
  }

  <span class="keyword">if</span> (self.proxy &amp;&amp; !self.tunnel) {
    self.port = self.proxy.port
    self.host = self.proxy.hostname
  } <span class="keyword">else</span> {
    self.port = self.uri.port
    self.host = self.uri.hostname
  }

  self.clientErrorHandler = <span class="function"><span class="keyword">function</span> <span class="params">(error)</span> {</span>
    <span class="keyword">if</span> (self._aborted) <span class="keyword">return</span>
    
    <span class="keyword">if</span> (self.setHost) <span class="keyword">delete</span> self.headers.host
    <span class="keyword">if</span> (self.req._reusedSocket &amp;&amp; error.code === <span class="string">'ECONNRESET'</span>
        &amp;&amp; self.agent.addRequestNoreuse) {
      self.agent = { addRequest: self.agent.addRequestNoreuse.bind(self.agent) }
      self.start()
      self.req.end()
      <span class="keyword">return</span>
    }
    <span class="keyword">if</span> (self.timeout &amp;&amp; self.timeoutTimer) {
      clearTimeout(self.timeoutTimer)
      self.timeoutTimer = <span class="literal">null</span>
    }
    self.emit(<span class="string">'error'</span>, error)
  }

  self._parserErrorHandler = <span class="function"><span class="keyword">function</span> <span class="params">(error)</span> {</span>
    <span class="keyword">if</span> (<span class="keyword">this</span>.res) {
      <span class="keyword">if</span> (<span class="keyword">this</span>.res.request) {
        <span class="keyword">this</span>.res.request.emit(<span class="string">'error'</span>, error)
      } <span class="keyword">else</span> {
        <span class="keyword">this</span>.res.emit(<span class="string">'error'</span>, error)
      }
    } <span class="keyword">else</span> {
      <span class="keyword">this</span>._httpMessage.emit(<span class="string">'error'</span>, error)
    }
  }

  <span class="keyword">if</span> (options.form) {
    self.form(options.form)
  }

  <span class="keyword">if</span> (options.oauth) {
    self.oauth(options.oauth)
  }
  
  <span class="keyword">if</span> (options.aws) {
    self.aws(options.aws)
  }

  <span class="keyword">if</span> (self.uri.auth &amp;&amp; !self.headers.authorization) {
    self.headers.authorization = <span class="string">"Basic "</span> + toBase64(self.uri.auth.split(<span class="string">':'</span>).map(<span class="keyword">function</span>(item){ <span class="keyword">return</span> qs.unescape(item)}).join(<span class="string">':'</span>))
  }
  <span class="keyword">if</span> (self.proxy &amp;&amp; self.proxy.auth &amp;&amp; !self.headers[<span class="string">'proxy-authorization'</span>] &amp;&amp; !self.tunnel) {
    self.headers[<span class="string">'proxy-authorization'</span>] = <span class="string">"Basic "</span> + toBase64(self.proxy.auth.split(<span class="string">':'</span>).map(<span class="keyword">function</span>(item){ <span class="keyword">return</span> qs.unescape(item)}).join(<span class="string">':'</span>))
  }

  <span class="keyword">if</span> (options.qs) self.qs(options.qs)

  <span class="keyword">if</span> (self.uri.path) {
    self.path = self.uri.path
  } <span class="keyword">else</span> {
    self.path = self.uri.pathname + (self.uri.search || <span class="string">""</span>)
  }

  <span class="keyword">if</span> (self.path.length === <span class="number">0</span>) self.path = <span class="string">'/'</span>

  <span class="keyword">if</span> (self.proxy &amp;&amp; !self.tunnel) self.path = (self.uri.protocol + <span class="string">'//'</span> + self.uri.host + self.path)

  <span class="keyword">if</span> (options.json) {
    self.json(options.json)
  } <span class="keyword">else</span> <span class="keyword">if</span> (options.multipart) {
    self.boundary = uuid()
    self.multipart(options.multipart)
  }

  <span class="keyword">if</span> (self.body) {
    <span class="keyword">var</span> length = <span class="number">0</span>
    <span class="keyword">if</span> (!Buffer.isBuffer(self.body)) {
      <span class="keyword">if</span> (Array.isArray(self.body)) {
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; self.body.length; i++) {
          length += self.body[i].length
        }
      } <span class="keyword">else</span> {
        self.body = <span class="keyword">new</span> Buffer(self.body)
        length = self.body.length
      }
    } <span class="keyword">else</span> {
      length = self.body.length
    }
    <span class="keyword">if</span> (length) {
      self.headers[<span class="string">'content-length'</span>] = length
    } <span class="keyword">else</span> {
      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Argument error, options.body.'</span>)
    }
  }

  <span class="keyword">var</span> protocol = self.proxy &amp;&amp; !self.tunnel ? self.proxy.protocol : self.uri.protocol
    , defaultModules = {<span class="string">'http:'</span>:http, <span class="string">'https:'</span>:https}
    , httpModules = self.httpModules || {}
    ;
  self.httpModule = httpModules[protocol] || defaultModules[protocol]

  <span class="keyword">if</span> (!self.httpModule) <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Invalid protocol"</span>)

  <span class="keyword">if</span> (options.ca) self.ca = options.ca

  <span class="keyword">if</span> (!self.agent) {
    <span class="keyword">if</span> (options.agentOptions) self.agentOptions = options.agentOptions

    <span class="keyword">if</span> (options.agentClass) {
      self.agentClass = options.agentClass
    } <span class="keyword">else</span> <span class="keyword">if</span> (options.forever) {
      self.agentClass = protocol === <span class="string">'http:'</span> ? ForeverAgent : ForeverAgent.SSL
    } <span class="keyword">else</span> {
      self.agentClass = self.httpModule.Agent
    }
  }

  <span class="keyword">if</span> (self.pool === <span class="literal">false</span>) {
    self.agent = <span class="literal">false</span>
  } <span class="keyword">else</span> {
    self.agent = self.agent || self.getAgent()
    <span class="keyword">if</span> (self.maxSockets) {
      <span class="comment">// Don't use our pooling if node has the refactored client</span>
      self.agent.maxSockets = self.maxSockets
    }
    <span class="keyword">if</span> (self.pool.maxSockets) {
      <span class="comment">// Don't use our pooling if node has the refactored client</span>
      self.agent.maxSockets = self.pool.maxSockets
    }
  }

  self.once(<span class="string">'pipe'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(src)</span> {</span>
    <span class="keyword">if</span> (self.ntick &amp;&amp; self._started) <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"You cannot pipe to this stream after the outbound request has started."</span>)
    self.src = src
    <span class="keyword">if</span> (isReadStream(src)) {
      <span class="keyword">if</span> (!self.headers[<span class="string">'content-type'</span>] &amp;&amp; !self.headers[<span class="string">'Content-Type'</span>])
        self.headers[<span class="string">'content-type'</span>] = mime.lookup(src.path)
    } <span class="keyword">else</span> {
      <span class="keyword">if</span> (src.headers) {
        <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> src.headers) {
          <span class="keyword">if</span> (!self.headers[i]) {
            self.headers[i] = src.headers[i]
          }
        }
      }
      <span class="keyword">if</span> (src.method &amp;&amp; !self.method) {
        self.method = src.method
      }
    }

    self.on(<span class="string">'pipe'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
      console.error(<span class="string">"You have already piped to this stream. Pipeing twice is likely to break the request."</span>)
    })
  })

  process.nextTick(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">if</span> (self._aborted) <span class="keyword">return</span>
    
    <span class="keyword">if</span> (self._form) {
      self.setHeaders(self._form.getHeaders())
      self._form.pipe(self)
    }
    <span class="keyword">if</span> (self.body) {
      <span class="keyword">if</span> (Array.isArray(self.body)) {
        self.body.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(part)</span> {</span>
          self.write(part)
        })
      } <span class="keyword">else</span> {
        self.write(self.body)
      }
      self.end()
    } <span class="keyword">else</span> <span class="keyword">if</span> (self.requestBodyStream) {
      console.warn(<span class="string">"options.requestBodyStream is deprecated, please pass the request object to stream.pipe."</span>)
      self.requestBodyStream.pipe(self)
    } <span class="keyword">else</span> <span class="keyword">if</span> (!self.src) {
      <span class="keyword">if</span> (self.method !== <span class="string">'GET'</span> &amp;&amp; <span class="keyword">typeof</span> self.method !== <span class="string">'undefined'</span>) {
        self.headers[<span class="string">'content-length'</span>] = <span class="number">0</span>;
      }
      self.end();
    }
    self.ntick = <span class="literal">true</span>
  })
}

<span class="comment">// Must call this when following a redirect from https to http or vice versa</span>
<span class="comment">// Attempts to keep everything as identical as possible, but update the</span>
<span class="comment">// httpModule, Tunneling agent, and/or Forever Agent in use.</span>
Request.prototype._updateProtocol = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> self = <span class="keyword">this</span>
  <span class="keyword">var</span> protocol = self.uri.protocol

  <span class="keyword">if</span> (protocol === <span class="string">'https:'</span>) {
    <span class="comment">// previously was doing http, now doing https</span>
    <span class="comment">// if it's https, then we might need to tunnel now.</span>
    <span class="keyword">if</span> (self.proxy) {
      self.tunnel = <span class="literal">true</span>
      <span class="keyword">var</span> tunnelFn = self.proxy.protocol === <span class="string">'http:'</span>
                   ? tunnel.httpsOverHttp : tunnel.httpsOverHttps
      <span class="keyword">var</span> tunnelOptions = { proxy: { host: self.proxy.hostname
                                   , post: +self.proxy.port
                                   , proxyAuth: self.proxy.auth }
                          , ca: self.ca }
      self.agent = tunnelFn(tunnelOptions)
      <span class="keyword">return</span>
    }

    self.httpModule = https
    <span class="keyword">switch</span> (self.agentClass) {
      <span class="keyword">case</span> ForeverAgent:
        self.agentClass = ForeverAgent.SSL
        <span class="keyword">break</span>
      <span class="keyword">case</span> http.Agent:
        self.agentClass = https.Agent
        <span class="keyword">break</span>
      <span class="keyword">default</span>:
        <span class="comment">// nothing we can do.  Just hope for the best.</span>
        <span class="keyword">return</span>
    }

    <span class="comment">// if there's an agent, we need to get a new one.</span>
    <span class="keyword">if</span> (self.agent) self.agent = self.getAgent()

  } <span class="keyword">else</span> {
    <span class="keyword">if</span> (log) log(<span class="string">'previously https, now http'</span>)
    <span class="comment">// previously was doing https, now doing http</span>
    <span class="comment">// stop any tunneling.</span>
    <span class="keyword">if</span> (self.tunnel) self.tunnel = <span class="literal">false</span>
    self.httpModule = http
    <span class="keyword">switch</span> (self.agentClass) {
      <span class="keyword">case</span> ForeverAgent.SSL:
        self.agentClass = ForeverAgent
        <span class="keyword">break</span>
      <span class="keyword">case</span> https.Agent:
        self.agentClass = http.Agent
        <span class="keyword">break</span>
      <span class="keyword">default</span>:
        <span class="comment">// nothing we can do.  just hope for the best</span>
        <span class="keyword">return</span>
    }

    <span class="comment">// if there's an agent, then get a new one.</span>
    <span class="keyword">if</span> (self.agent) {
      self.agent = <span class="literal">null</span>
      self.agent = self.getAgent()
    }
  }
}

Request.prototype.getAgent = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> Agent = <span class="keyword">this</span>.agentClass
  <span class="keyword">var</span> options = {}
  <span class="keyword">if</span> (<span class="keyword">this</span>.agentOptions) {
    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> <span class="keyword">this</span>.agentOptions) {
      options[i] = <span class="keyword">this</span>.agentOptions[i]
    }
  }
  <span class="keyword">if</span> (<span class="keyword">this</span>.ca) options.ca = <span class="keyword">this</span>.ca

  <span class="keyword">var</span> poolKey = <span class="string">''</span>

  <span class="comment">// different types of agents are in different pools</span>
  <span class="keyword">if</span> (Agent !== <span class="keyword">this</span>.httpModule.Agent) {
    poolKey += Agent.name
  }

  <span class="keyword">if</span> (!<span class="keyword">this</span>.httpModule.globalAgent) {
    <span class="comment">// node 0.4.x</span>
    options.host = <span class="keyword">this</span>.host
    options.port = <span class="keyword">this</span>.port
    <span class="keyword">if</span> (poolKey) poolKey += <span class="string">':'</span>
    poolKey += <span class="keyword">this</span>.host + <span class="string">':'</span> + <span class="keyword">this</span>.port
  }

  <span class="comment">// ca option is only relevant if proxy or destination are https</span>
  <span class="keyword">var</span> proxy = <span class="keyword">this</span>.proxy
  <span class="keyword">if</span> (<span class="keyword">typeof</span> proxy === <span class="string">'string'</span>) proxy = url.parse(proxy)
  <span class="keyword">var</span> caRelevant = (proxy &amp;&amp; proxy.protocol === <span class="string">'https:'</span>) || <span class="keyword">this</span>.uri.protocol === <span class="string">'https:'</span>
  <span class="keyword">if</span> (options.ca &amp;&amp; caRelevant) {
    <span class="keyword">if</span> (poolKey) poolKey += <span class="string">':'</span>
    poolKey += options.ca
  }

  <span class="keyword">if</span> (!poolKey &amp;&amp; Agent === <span class="keyword">this</span>.httpModule.Agent &amp;&amp; <span class="keyword">this</span>.httpModule.globalAgent) {
    <span class="comment">// not doing anything special.  Use the globalAgent</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.httpModule.globalAgent
  }

  <span class="comment">// we're using a stored agent.  Make sure it's protocol-specific</span>
  poolKey = <span class="keyword">this</span>.uri.protocol + poolKey

  <span class="comment">// already generated an agent for this setting</span>
  <span class="keyword">if</span> (<span class="keyword">this</span>.pool[poolKey]) <span class="keyword">return</span> <span class="keyword">this</span>.pool[poolKey]

  <span class="keyword">return</span> <span class="keyword">this</span>.pool[poolKey] = <span class="keyword">new</span> Agent(options)
}

Request.prototype.start = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> self = <span class="keyword">this</span>

  <span class="keyword">if</span> (self._aborted) <span class="keyword">return</span>

  self._started = <span class="literal">true</span>
  self.method = self.method || <span class="string">'GET'</span>
  self.href = self.uri.href
  <span class="keyword">if</span> (log) log(<span class="string">'%method %href'</span>, self)

  <span class="keyword">if</span> (self.src &amp;&amp; self.src.stat &amp;&amp; self.src.stat.size) {
    self.headers[<span class="string">'content-length'</span>] = self.src.stat.size
  }
  <span class="keyword">if</span> (self._aws) {
    self.aws(self._aws, <span class="literal">true</span>)
  }

  self.req = self.httpModule.request(self, <span class="function"><span class="keyword">function</span> <span class="params">(response)</span> {</span>
    <span class="keyword">if</span> (response.connection.listeners(<span class="string">'error'</span>).indexOf(self._parserErrorHandler) === -<span class="number">1</span>) {
      response.connection.once(<span class="string">'error'</span>, self._parserErrorHandler)
    }
    <span class="keyword">if</span> (self._aborted) <span class="keyword">return</span>
    <span class="keyword">if</span> (self._paused) response.pause()

    self.response = response
    response.request = self
    response.toJSON = toJSON

    <span class="keyword">if</span> (self.httpModule === https &amp;&amp;
        self.strictSSL &amp;&amp;
        !response.client.authorized) {
      <span class="keyword">var</span> sslErr = response.client.authorizationError
      self.emit(<span class="string">'error'</span>, <span class="keyword">new</span> Error(<span class="string">'SSL Error: '</span>+ sslErr))
      <span class="keyword">return</span>
    }

    <span class="keyword">if</span> (self.setHost) <span class="keyword">delete</span> self.headers.host
    <span class="keyword">if</span> (self.timeout &amp;&amp; self.timeoutTimer) {
      clearTimeout(self.timeoutTimer)
      self.timeoutTimer = <span class="literal">null</span>
    }  

    <span class="keyword">var</span> addCookie = <span class="function"><span class="keyword">function</span> <span class="params">(cookie)</span> {</span>
      <span class="keyword">if</span> (self._jar) self._jar.add(<span class="keyword">new</span> Cookie(cookie))
      <span class="keyword">else</span> cookieJar.add(<span class="keyword">new</span> Cookie(cookie))
    }

    <span class="keyword">if</span> (response.headers[<span class="string">'set-cookie'</span>] &amp;&amp; (!self._disableCookies)) {
      <span class="keyword">if</span> (Array.isArray(response.headers[<span class="string">'set-cookie'</span>])) response.headers[<span class="string">'set-cookie'</span>].forEach(addCookie)
      <span class="keyword">else</span> addCookie(response.headers[<span class="string">'set-cookie'</span>])
    }

    <span class="keyword">if</span> (response.statusCode >= <span class="number">300</span> &amp;&amp; response.statusCode &lt; <span class="number">400</span>  &amp;&amp;
        (self.followAllRedirects ||
         (self.followRedirect &amp;&amp; (self.method !== <span class="string">'PUT'</span> &amp;&amp; self.method !== <span class="string">'POST'</span> &amp;&amp; self.method !== <span class="string">'DELETE'</span>))) &amp;&amp;
        response.headers.location) {
      <span class="keyword">if</span> (self._redirectsFollowed >= self.maxRedirects) {
        self.emit(<span class="string">'error'</span>, <span class="keyword">new</span> Error(<span class="string">"Exceeded maxRedirects. Probably stuck in a redirect loop "</span>+self.uri.href))
        <span class="keyword">return</span>
      }
      self._redirectsFollowed += <span class="number">1</span>

      <span class="keyword">if</span> (!isUrl.test(response.headers.location)) {
        response.headers.location = url.resolve(self.uri.href, response.headers.location)
      }

      <span class="keyword">var</span> uriPrev = self.uri
      self.uri = url.parse(response.headers.location)

      <span class="comment">// handle the case where we change protocol from https to http or vice versa</span>
      <span class="keyword">if</span> (self.uri.protocol !== uriPrev.protocol) {
        self._updateProtocol()
      }

      self.redirects.push(
        { statusCode : response.statusCode
        , redirectUri: response.headers.location 
        }
      )
      <span class="keyword">if</span> (self.followAllRedirects) self.method = <span class="string">'GET'</span>
      <span class="comment">// self.method = 'GET'; // Force all redirects to use GET || commented out fixes #215</span>
      <span class="keyword">delete</span> self.src
      <span class="keyword">delete</span> self.req
      <span class="keyword">delete</span> self.agent
      <span class="keyword">delete</span> self._started
      <span class="keyword">delete</span> self.body
      <span class="keyword">if</span> (self.headers) {
        <span class="keyword">delete</span> self.headers.host
      }
      <span class="keyword">if</span> (log) log(<span class="string">'Redirect to %uri'</span>, self)
      self.init()
      <span class="keyword">return</span> <span class="comment">// Ignore the rest of the response</span>
    } <span class="keyword">else</span> {
      self._redirectsFollowed = self._redirectsFollowed || <span class="number">0</span>
      <span class="comment">// Be a good stream and emit end when the response is finished.</span>
      <span class="comment">// Hack to emit end on close because of a core bug that never fires end</span>
      response.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">if</span> (!self._ended) self.response.emit(<span class="string">'end'</span>)
      })

      <span class="keyword">if</span> (self.encoding) {
        <span class="keyword">if</span> (self.dests.length !== <span class="number">0</span>) {
          console.error(<span class="string">"Ingoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid."</span>)
        } <span class="keyword">else</span> {
          response.setEncoding(self.encoding)
        }
      }

      self.dests.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(dest)</span> {</span>
        self.pipeDest(dest)
      })

      response.on(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span> <span class="params">(chunk)</span> {</span>
        self._destdata = <span class="literal">true</span>
        self.emit(<span class="string">"data"</span>, chunk)
      })
      response.on(<span class="string">"end"</span>, <span class="function"><span class="keyword">function</span> <span class="params">(chunk)</span> {</span>
        self._ended = <span class="literal">true</span>
        self.emit(<span class="string">"end"</span>, chunk)
      })
      response.on(<span class="string">"close"</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>self.emit(<span class="string">"close"</span>)})

      self.emit(<span class="string">'response'</span>, response)

      <span class="keyword">if</span> (self.callback) {
        <span class="keyword">var</span> buffer = []
        <span class="keyword">var</span> bodyLen = <span class="number">0</span>
        self.on(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span> <span class="params">(chunk)</span> {</span>
          buffer.push(chunk)
          bodyLen += chunk.length
        })
        self.on(<span class="string">"end"</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
          <span class="keyword">if</span> (self._aborted) <span class="keyword">return</span>
          
          <span class="keyword">if</span> (buffer.length &amp;&amp; Buffer.isBuffer(buffer[<span class="number">0</span>])) {
            <span class="keyword">var</span> body = <span class="keyword">new</span> Buffer(bodyLen)
            <span class="keyword">var</span> i = <span class="number">0</span>
            buffer.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(chunk)</span> {</span>
              chunk.copy(body, i, <span class="number">0</span>, chunk.length)
              i += chunk.length
            })
            <span class="keyword">if</span> (self.encoding === <span class="literal">null</span>) {
              response.body = body
            } <span class="keyword">else</span> {
              response.body = body.toString(self.encoding)
            }
          } <span class="keyword">else</span> <span class="keyword">if</span> (buffer.length) {
            response.body = buffer.join(<span class="string">''</span>)
          }

          <span class="keyword">if</span> (self._json) {
            <span class="keyword">try</span> {
              response.body = JSON.parse(response.body)
            } <span class="keyword">catch</span> (e) {}
          }
          
          self.emit(<span class="string">'complete'</span>, response, response.body)
        })
      }
    }
  })

  <span class="keyword">if</span> (self.timeout &amp;&amp; !self.timeoutTimer) {
    self.timeoutTimer = setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
      self.req.abort()
      <span class="keyword">var</span> e = <span class="keyword">new</span> Error(<span class="string">"ETIMEDOUT"</span>)
      e.code = <span class="string">"ETIMEDOUT"</span>
      self.emit(<span class="string">"error"</span>, e)
    }, self.timeout)
    
    <span class="comment">// Set additional timeout on socket - in case if remote</span>
    <span class="comment">// server freeze after sending headers</span>
    <span class="keyword">if</span> (self.req.setTimeout) { <span class="comment">// only works on node 0.6+</span>
      self.req.setTimeout(self.timeout, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">if</span> (self.req) {
          self.req.abort()
          <span class="keyword">var</span> e = <span class="keyword">new</span> Error(<span class="string">"ESOCKETTIMEDOUT"</span>)
          e.code = <span class="string">"ESOCKETTIMEDOUT"</span>
          self.emit(<span class="string">"error"</span>, e)
        }
      })
    }
  }
  
  self.req.on(<span class="string">'error'</span>, self.clientErrorHandler)
  self.req.on(<span class="string">'drain'</span>, <span class="keyword">function</span>() {
    self.emit(<span class="string">'drain'</span>)
  })
  self.on(<span class="string">'end'</span>, <span class="keyword">function</span>() {
    <span class="keyword">if</span> ( self.req.connection ) self.req.connection.removeListener(<span class="string">'error'</span>, self._parserErrorHandler)
  })
  self.emit(<span class="string">'request'</span>, self.req)
}

Request.prototype.abort = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">this</span>._aborted = <span class="literal">true</span>;
  
  <span class="keyword">if</span> (<span class="keyword">this</span>.req) {
    <span class="keyword">this</span>.req.abort()
  }
  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.response) {
    <span class="keyword">this</span>.response.abort()
  }
  
  <span class="keyword">this</span>.emit(<span class="string">"abort"</span>)
}

Request.prototype.pipeDest = <span class="function"><span class="keyword">function</span> <span class="params">(dest)</span> {</span>
  <span class="keyword">var</span> response = <span class="keyword">this</span>.response
  <span class="comment">// Called after the response is received</span>
  <span class="keyword">if</span> (dest.headers) {
    dest.headers[<span class="string">'content-type'</span>] = response.headers[<span class="string">'content-type'</span>]
    <span class="keyword">if</span> (response.headers[<span class="string">'content-length'</span>]) {
      dest.headers[<span class="string">'content-length'</span>] = response.headers[<span class="string">'content-length'</span>]
    }
  }
  <span class="keyword">if</span> (dest.setHeader) {
    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> response.headers) {
      dest.setHeader(i, response.headers[i])
    }
    dest.statusCode = response.statusCode
  }
  <span class="keyword">if</span> (<span class="keyword">this</span>.pipefilter) <span class="keyword">this</span>.pipefilter(response, dest)
}

<span class="comment">// Composable API</span>
Request.prototype.setHeader = <span class="function"><span class="keyword">function</span> <span class="params">(name, value, clobber)</span> {</span>
  <span class="keyword">if</span> (clobber === <span class="literal">undefined</span>) clobber = <span class="literal">true</span>
  <span class="keyword">if</span> (clobber || !<span class="keyword">this</span>.headers.hasOwnProperty(name)) <span class="keyword">this</span>.headers[name] = value
  <span class="keyword">else</span> <span class="keyword">this</span>.headers[name] += <span class="string">','</span> + value
  <span class="keyword">return</span> <span class="keyword">this</span>
}
Request.prototype.setHeaders = <span class="function"><span class="keyword">function</span> <span class="params">(headers)</span> {</span>
  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> headers) {<span class="keyword">this</span>.setHeader(i, headers[i])}
  <span class="keyword">return</span> <span class="keyword">this</span>
}
Request.prototype.qs = <span class="function"><span class="keyword">function</span> <span class="params">(q, clobber)</span> {</span>
  <span class="keyword">var</span> base
  <span class="keyword">if</span> (!clobber &amp;&amp; <span class="keyword">this</span>.uri.query) base = qs.parse(<span class="keyword">this</span>.uri.query)
  <span class="keyword">else</span> base = {}
  
  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> q) {
    base[i] = q[i]
  }
  
  <span class="keyword">this</span>.uri = url.parse(<span class="keyword">this</span>.uri.href.split(<span class="string">'?'</span>)[<span class="number">0</span>] + <span class="string">'?'</span> + qs.stringify(base))
  <span class="keyword">this</span>.url = <span class="keyword">this</span>.uri
  
  <span class="keyword">return</span> <span class="keyword">this</span>
}
Request.prototype.form = <span class="function"><span class="keyword">function</span> <span class="params">(form)</span> {</span>
  <span class="keyword">if</span> (form) {
    <span class="keyword">this</span>.headers[<span class="string">'content-type'</span>] = <span class="string">'application/x-www-form-urlencoded; charset=utf-8'</span>
    <span class="keyword">this</span>.body = qs.stringify(form).toString(<span class="string">'utf8'</span>)
    <span class="keyword">return</span> <span class="keyword">this</span>
  } 
  <span class="comment">// create form-data object</span>
  <span class="keyword">this</span>._form = <span class="keyword">new</span> FormData()
  <span class="keyword">return</span> <span class="keyword">this</span>._form
}
Request.prototype.multipart = <span class="function"><span class="keyword">function</span> <span class="params">(multipart)</span> {</span>
  <span class="keyword">var</span> self = <span class="keyword">this</span>
  self.body = []

  <span class="keyword">if</span> (!self.headers[<span class="string">'content-type'</span>]) {
    self.headers[<span class="string">'content-type'</span>] = <span class="string">'multipart/related; boundary='</span> + self.boundary;
  } <span class="keyword">else</span> {
    self.headers[<span class="string">'content-type'</span>] = self.headers[<span class="string">'content-type'</span>].split(<span class="string">';'</span>)[<span class="number">0</span>] + <span class="string">'; boundary='</span> + self.boundary;
  }

  <span class="keyword">if</span> (!multipart.forEach) <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Argument error, options.multipart.'</span>)

  <span class="keyword">if</span> (self.preambleCRLF) {
    self.body.push(<span class="keyword">new</span> Buffer(<span class="string">'\r\n'</span>))
  }
  
  multipart.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(part)</span> {</span>
    <span class="keyword">var</span> body = part.body
    <span class="keyword">if</span>(body == <span class="literal">null</span>) <span class="keyword">throw</span> Error(<span class="string">'Body attribute missing in multipart.'</span>)
    <span class="keyword">delete</span> part.body
    <span class="keyword">var</span> preamble = <span class="string">'--'</span> + self.boundary + <span class="string">'\r\n'</span>
    Object.keys(part).forEach(<span class="function"><span class="keyword">function</span> <span class="params">(key)</span> {</span>
      preamble += key + <span class="string">': '</span> + part[key] + <span class="string">'\r\n'</span>
    })
    preamble += <span class="string">'\r\n'</span>
    self.body.push(<span class="keyword">new</span> Buffer(preamble))
    self.body.push(<span class="keyword">new</span> Buffer(body))
    self.body.push(<span class="keyword">new</span> Buffer(<span class="string">'\r\n'</span>))
  })
  self.body.push(<span class="keyword">new</span> Buffer(<span class="string">'--'</span> + self.boundary + <span class="string">'--'</span>))
  <span class="keyword">return</span> self
}
Request.prototype.json = <span class="function"><span class="keyword">function</span> <span class="params">(val)</span> {</span>
  <span class="keyword">this</span>.setHeader(<span class="string">'content-type'</span>, <span class="string">'application/json'</span>)
  <span class="keyword">this</span>.setHeader(<span class="string">'accept'</span>, <span class="string">'application/json'</span>)
  <span class="keyword">this</span>._json = <span class="literal">true</span>
  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'boolean'</span>) {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.body === <span class="string">'object'</span>) <span class="keyword">this</span>.body = JSON.stringify(<span class="keyword">this</span>.body)
  } <span class="keyword">else</span> {
    <span class="keyword">this</span>.body = JSON.stringify(val)
  }
  <span class="keyword">return</span> <span class="keyword">this</span>
}
Request.prototype.aws = <span class="function"><span class="keyword">function</span> <span class="params">(opts, now)</span> {</span>
  <span class="keyword">if</span> (!now) {
    <span class="keyword">this</span>._aws = opts
    <span class="keyword">return</span> <span class="keyword">this</span>
  }
  <span class="keyword">var</span> date = <span class="keyword">new</span> Date()
  <span class="keyword">this</span>.setHeader(<span class="string">'date'</span>, date.toUTCString())
  <span class="keyword">this</span>.setHeader(<span class="string">'authorization'</span>, aws.authorization(
    { key: opts.key
    , secret: opts.secret
    , verb: <span class="keyword">this</span>.method
    , date: date
    , resource: aws.canonicalizeResource(<span class="string">'/'</span> + opts.bucket + <span class="keyword">this</span>.path)
    , contentType: <span class="keyword">this</span>.headers[<span class="string">'content-type'</span>] || <span class="string">''</span>
    , md5: <span class="keyword">this</span>.headers[<span class="string">'content-md5'</span>] || <span class="string">''</span>
    , amazonHeaders: aws.canonicalizeHeaders(<span class="keyword">this</span>.headers)
    }
  ))
  
  <span class="keyword">return</span> <span class="keyword">this</span>
}

Request.prototype.oauth = <span class="function"><span class="keyword">function</span> <span class="params">(_oauth)</span> {</span>
  <span class="keyword">var</span> form
  <span class="keyword">if</span> (<span class="keyword">this</span>.headers[<span class="string">'content-type'</span>] &amp;&amp; 
      <span class="keyword">this</span>.headers[<span class="string">'content-type'</span>].slice(<span class="number">0</span>, <span class="string">'application/x-www-form-urlencoded'</span>.length) ===
        <span class="string">'application/x-www-form-urlencoded'</span> 
     ) {
    form = qs.parse(<span class="keyword">this</span>.body)
  }
  <span class="keyword">if</span> (<span class="keyword">this</span>.uri.query) {
    form = qs.parse(<span class="keyword">this</span>.uri.query)
  } 
  <span class="keyword">if</span> (!form) form = {}
  <span class="keyword">var</span> oa = {}
  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> form) oa[i] = form[i]
  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> _oauth) oa[<span class="string">'oauth_'</span>+i] = _oauth[i]
  <span class="keyword">if</span> (!oa.oauth_version) oa.oauth_version = <span class="string">'1.0'</span>
  <span class="keyword">if</span> (!oa.oauth_timestamp) oa.oauth_timestamp = Math.floor( (<span class="keyword">new</span> Date()).getTime() / <span class="number">1000</span> ).toString()
  <span class="keyword">if</span> (!oa.oauth_nonce) oa.oauth_nonce = uuid().replace(<span class="regexp">/-/g</span>, <span class="string">''</span>)
  
  oa.oauth_signature_method = <span class="string">'HMAC-SHA1'</span>
  
  <span class="keyword">var</span> consumer_secret = oa.oauth_consumer_secret
  <span class="keyword">delete</span> oa.oauth_consumer_secret
  <span class="keyword">var</span> token_secret = oa.oauth_token_secret
  <span class="keyword">delete</span> oa.oauth_token_secret
  
  <span class="keyword">var</span> baseurl = <span class="keyword">this</span>.uri.protocol + <span class="string">'//'</span> + <span class="keyword">this</span>.uri.host + <span class="keyword">this</span>.uri.pathname
  <span class="keyword">var</span> signature = oauth.hmacsign(<span class="keyword">this</span>.method, baseurl, oa, consumer_secret, token_secret)
  
  <span class="comment">// oa.oauth_signature = signature</span>
  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> form) {
    <span class="keyword">if</span> ( i.slice(<span class="number">0</span>, <span class="string">'oauth_'</span>) <span class="keyword">in</span> _oauth) {
      <span class="comment">// skip </span>
    } <span class="keyword">else</span> {
      <span class="keyword">delete</span> oa[<span class="string">'oauth_'</span>+i]
      <span class="keyword">delete</span> oa[i]
    }
  }
  <span class="keyword">this</span>.headers.Authorization = 
    <span class="string">'OAuth '</span>+Object.keys(oa).sort().map(<span class="function"><span class="keyword">function</span> <span class="params">(i)</span> {</span><span class="keyword">return</span> i+<span class="string">'="'</span>+oauth.rfc3986(oa[i])+<span class="string">'"'</span>}).join(<span class="string">','</span>)
  <span class="keyword">this</span>.headers.Authorization += <span class="string">',oauth_signature="'</span>+oauth.rfc3986(signature)+<span class="string">'"'</span>
  <span class="keyword">return</span> <span class="keyword">this</span>
}
Request.prototype.jar = <span class="function"><span class="keyword">function</span> <span class="params">(jar)</span> {</span>
  <span class="keyword">var</span> cookies
  
  <span class="keyword">if</span> (<span class="keyword">this</span>._redirectsFollowed === <span class="number">0</span>) {
    <span class="keyword">this</span>.originalCookieHeader = <span class="keyword">this</span>.headers.cookie
  }
  
  <span class="keyword">if</span> (jar === <span class="literal">false</span>) {
    <span class="comment">// disable cookies</span>
    cookies = <span class="literal">false</span>;
    <span class="keyword">this</span>._disableCookies = <span class="literal">true</span>;
  } <span class="keyword">else</span> <span class="keyword">if</span> (jar) {
    <span class="comment">// fetch cookie from the user defined cookie jar</span>
    cookies = jar.get({ url: <span class="keyword">this</span>.uri.href })
  } <span class="keyword">else</span> {
    <span class="comment">// fetch cookie from the global cookie jar</span>
    cookies = cookieJar.get({ url: <span class="keyword">this</span>.uri.href })
  }
  
  <span class="keyword">if</span> (cookies &amp;&amp; cookies.length) {
    <span class="keyword">var</span> cookieString = cookies.map(<span class="function"><span class="keyword">function</span> <span class="params">(c)</span> {</span>
      <span class="keyword">return</span> c.name + <span class="string">"="</span> + c.value
    }).join(<span class="string">"; "</span>)

    <span class="keyword">if</span> (<span class="keyword">this</span>.originalCookieHeader) {
      <span class="comment">// Don't overwrite existing Cookie header</span>
      <span class="keyword">this</span>.headers.cookie = <span class="keyword">this</span>.originalCookieHeader + <span class="string">'; '</span> + cookieString
    } <span class="keyword">else</span> {
      <span class="keyword">this</span>.headers.cookie = cookieString
    }
  }
  <span class="keyword">this</span>._jar = jar
  <span class="keyword">return</span> <span class="keyword">this</span>
}


<span class="comment">// Stream API</span>
Request.prototype.pipe = <span class="function"><span class="keyword">function</span> <span class="params">(dest, opts)</span> {</span>
  <span class="keyword">if</span> (<span class="keyword">this</span>.response) {
    <span class="keyword">if</span> (<span class="keyword">this</span>._destdata) {
      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"You cannot pipe after data has been emitted from the response."</span>)
    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>._ended) {
      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"You cannot pipe after the response has been ended."</span>)
    } <span class="keyword">else</span> {
      stream.Stream.prototype.pipe.call(<span class="keyword">this</span>, dest, opts)
      <span class="keyword">this</span>.pipeDest(dest)
      <span class="keyword">return</span> dest
    }
  } <span class="keyword">else</span> {
    <span class="keyword">this</span>.dests.push(dest)
    stream.Stream.prototype.pipe.call(<span class="keyword">this</span>, dest, opts)
    <span class="keyword">return</span> dest
  }
}
Request.prototype.write = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">if</span> (!<span class="keyword">this</span>._started) <span class="keyword">this</span>.start()
  <span class="keyword">return</span> <span class="keyword">this</span>.req.write.apply(<span class="keyword">this</span>.req, arguments)
}
Request.prototype.end = <span class="function"><span class="keyword">function</span> <span class="params">(chunk)</span> {</span>
  <span class="keyword">if</span> (chunk) <span class="keyword">this</span>.write(chunk)
  <span class="keyword">if</span> (!<span class="keyword">this</span>._started) <span class="keyword">this</span>.start()
  <span class="keyword">this</span>.req.end()
}
Request.prototype.pause = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">if</span> (!<span class="keyword">this</span>.response) <span class="keyword">this</span>._paused = <span class="literal">true</span>
  <span class="keyword">else</span> <span class="keyword">this</span>.response.pause.apply(<span class="keyword">this</span>.response, arguments)
}
Request.prototype.resume = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">if</span> (!<span class="keyword">this</span>.response) <span class="keyword">this</span>._paused = <span class="literal">false</span>
  <span class="keyword">else</span> <span class="keyword">this</span>.response.resume.apply(<span class="keyword">this</span>.response, arguments)
}
Request.prototype.destroy = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">if</span> (!<span class="keyword">this</span>._ended) <span class="keyword">this</span>.end()
}

<span class="comment">// organize params for post, put, head, del</span>
<span class="function"><span class="keyword">function</span> <span class="title">initParams</span><span class="params">(uri, options, callback)</span> {</span>
  <span class="keyword">if</span> ((<span class="keyword">typeof</span> options === <span class="string">'function'</span>) &amp;&amp; !callback) callback = options;
  <span class="keyword">if</span> (options &amp;&amp; <span class="keyword">typeof</span> options === <span class="string">'object'</span>) {
    options.uri = uri;
  } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> uri === <span class="string">'string'</span>) {
    options = {uri:uri};
  } <span class="keyword">else</span> {
    options = uri;
    uri = options.uri;
  }
  <span class="keyword">return</span> { uri: uri, options: options, callback: callback };
}

<span class="function"><span class="keyword">function</span> <span class="title">request</span> <span class="params">(uri, options, callback)</span> {</span>
  <span class="keyword">if</span> (<span class="keyword">typeof</span> uri === <span class="string">'undefined'</span>) <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'undefined is not a valid uri or options object.'</span>)
  <span class="keyword">if</span> ((<span class="keyword">typeof</span> options === <span class="string">'function'</span>) &amp;&amp; !callback) callback = options;
  <span class="keyword">if</span> (options &amp;&amp; <span class="keyword">typeof</span> options === <span class="string">'object'</span>) {
    options.uri = uri;
  } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> uri === <span class="string">'string'</span>) {
    options = {uri:uri};
  } <span class="keyword">else</span> {
    options = uri;
  }

  <span class="keyword">if</span> (callback) options.callback = callback;
  <span class="keyword">var</span> r = <span class="keyword">new</span> Request(options)
  <span class="keyword">return</span> r
}

module.exports = request

request.initParams = initParams;

request.defaults = <span class="function"><span class="keyword">function</span> <span class="params">(options, requester)</span> {</span>
  <span class="keyword">var</span> def = <span class="function"><span class="keyword">function</span> <span class="params">(method)</span> {</span>
    <span class="keyword">var</span> d = <span class="function"><span class="keyword">function</span> <span class="params">(uri, opts, callback)</span> {</span>
      <span class="keyword">var</span> params = initParams(uri, opts, callback);
      <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> options) {
        <span class="keyword">if</span> (params.options[i] === <span class="literal">undefined</span>) params.options[i] = options[i]
      }
      <span class="keyword">if</span>(<span class="keyword">typeof</span> requester === <span class="string">'function'</span>) {
        <span class="keyword">if</span>(method === request) {
          method = requester;
        } <span class="keyword">else</span> {
          params.options._requester = requester;
        }
      }
      <span class="keyword">return</span> method(params.options, params.callback);
    }
    <span class="keyword">return</span> d;
  }
  <span class="keyword">var</span> de = def(request)
  de.get = def(request.get)
  de.post = def(request.post)
  de.put = def(request.put)
  de.head = def(request.head)
  de.del = def(request.del)
  de.cookie = def(request.cookie)
  de.jar = def(request.jar)
  <span class="keyword">return</span> de
}

request.forever = <span class="function"><span class="keyword">function</span> <span class="params">(agentOptions, optionsArg)</span> {</span>
  <span class="keyword">var</span> options = {}
  <span class="keyword">if</span> (optionsArg) {
    <span class="keyword">for</span> (option <span class="keyword">in</span> optionsArg) {
      options[option] = optionsArg[option]
    }
  }
  <span class="keyword">if</span> (agentOptions) options.agentOptions = agentOptions
  options.forever = <span class="literal">true</span>
  <span class="keyword">return</span> request.defaults(options)
}

request.get = request
request.post = <span class="function"><span class="keyword">function</span> <span class="params">(uri, options, callback)</span> {</span>
  <span class="keyword">var</span> params = initParams(uri, options, callback);
  params.options.method = <span class="string">'POST'</span>;
  <span class="keyword">return</span> request(params.uri || <span class="literal">null</span>, params.options, params.callback)
}
request.put = <span class="function"><span class="keyword">function</span> <span class="params">(uri, options, callback)</span> {</span>
  <span class="keyword">var</span> params = initParams(uri, options, callback);
  params.options.method = <span class="string">'PUT'</span>
  <span class="keyword">return</span> request(params.uri || <span class="literal">null</span>, params.options, params.callback)
}
request.head = <span class="function"><span class="keyword">function</span> <span class="params">(uri, options, callback)</span> {</span>
  <span class="keyword">var</span> params = initParams(uri, options, callback);
  params.options.method = <span class="string">'HEAD'</span>
  <span class="keyword">if</span> (params.options.body || 
      params.options.requestBodyStream || 
      (params.options.json &amp;&amp; <span class="keyword">typeof</span> params.options.json !== <span class="string">'boolean'</span>) || 
      params.options.multipart) {
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"HTTP HEAD requests MUST NOT include a request body."</span>)
  }
  <span class="keyword">return</span> request(params.uri || <span class="literal">null</span>, params.options, params.callback)
}
request.del = <span class="function"><span class="keyword">function</span> <span class="params">(uri, options, callback)</span> {</span>
  <span class="keyword">var</span> params = initParams(uri, options, callback);
  params.options.method = <span class="string">'DELETE'</span>
  <span class="keyword">if</span>(<span class="keyword">typeof</span> params.options._requester === <span class="string">'function'</span>) {
    request = params.options._requester;
  }
  <span class="keyword">return</span> request(params.uri || <span class="literal">null</span>, params.options, params.callback)
}
request.jar = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">return</span> <span class="keyword">new</span> CookieJar
}
request.cookie = <span class="function"><span class="keyword">function</span> <span class="params">(str)</span> {</span>
  <span class="keyword">if</span> (str &amp;&amp; str.uri) str = str.uri
  <span class="keyword">if</span> (<span class="keyword">typeof</span> str !== <span class="string">'string'</span>) <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"The cookie function only accepts STRING as param"</span>)
  <span class="keyword">return</span> <span class="keyword">new</span> Cookie(str)
}

<span class="comment">// Safe toJSON</span>

<span class="function"><span class="keyword">function</span> <span class="title">getSafe</span> <span class="params">(self, uuid)</span> {</span>  
  <span class="keyword">if</span> (<span class="keyword">typeof</span> self === <span class="string">'object'</span> || <span class="keyword">typeof</span> self === <span class="string">'function'</span>) <span class="keyword">var</span> safe = {}
  <span class="keyword">if</span> (Array.isArray(self)) <span class="keyword">var</span> safe = []

  <span class="keyword">var</span> recurse = []
  
  Object.defineProperty(self, uuid, {})
  
  <span class="keyword">var</span> attrs = Object.keys(self).filter(<span class="function"><span class="keyword">function</span> <span class="params">(i)</span> {</span>
    <span class="keyword">if</span> (i === uuid) <span class="keyword">return</span> <span class="literal">false</span> 
    <span class="keyword">if</span> ( (<span class="keyword">typeof</span> self[i] !== <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> self[i] !== <span class="string">'function'</span>) || self[i] === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>
    <span class="keyword">return</span> !(Object.getOwnPropertyDescriptor(self[i], uuid))
  })
  
  
  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;attrs.length;i++) {
    <span class="keyword">if</span> ( (<span class="keyword">typeof</span> self[attrs[i]] !== <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> self[attrs[i]] !== <span class="string">'function'</span>) || 
          self[attrs[i]] === <span class="literal">null</span>
        ) {
      safe[attrs[i]] = self[attrs[i]]
    } <span class="keyword">else</span> {
      recurse.push(attrs[i])
      Object.defineProperty(self[attrs[i]], uuid, {})
    }
  }

  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;recurse.length;i++) {
    safe[recurse[i]] = getSafe(self[recurse[i]], uuid)
  }
  
  <span class="keyword">return</span> safe
}

<span class="function"><span class="keyword">function</span> <span class="title">toJSON</span> <span class="params">()</span> {</span>
  <span class="keyword">return</span> getSafe(<span class="keyword">this</span>, (((<span class="number">1</span>+Math.random())*<span class="number">0x10000</span>)|<span class="number">0</span>).toString(<span class="number">16</span>))
}

Request.prototype.toJSON = toJSON

</code></pre>