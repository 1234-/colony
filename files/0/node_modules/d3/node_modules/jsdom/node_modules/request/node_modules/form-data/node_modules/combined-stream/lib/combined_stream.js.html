<h1>combined-stream</h1>
<pre><code class="lang-js"><span class="keyword">var</span> util = require(<span class="string">'util'</span>);
<span class="keyword">var</span> Stream = require(<span class="string">'stream'</span>).Stream;
<span class="keyword">var</span> DelayedStream = require(<span class="string">'delayed-stream'</span>);

module.exports = CombinedStream;
<span class="function"><span class="keyword">function</span> <span class="title">CombinedStream</span><span class="params">()</span> {</span>
  <span class="keyword">this</span>.writable = <span class="literal">false</span>;
  <span class="keyword">this</span>.readable = <span class="literal">true</span>;
  <span class="keyword">this</span>.dataSize = <span class="number">0</span>;
  <span class="keyword">this</span>.maxDataSize = <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>;
  <span class="keyword">this</span>.pauseStreams = <span class="literal">true</span>;

  <span class="keyword">this</span>._released = <span class="literal">false</span>;
  <span class="keyword">this</span>._streams = [];
  <span class="keyword">this</span>._currentStream = <span class="literal">null</span>;
}
util.inherits(CombinedStream, Stream);

CombinedStream.create = <span class="keyword">function</span>(options) {
  <span class="keyword">var</span> combinedStream = <span class="keyword">new</span> <span class="keyword">this</span>();

  options = options || {};
  <span class="keyword">for</span> (<span class="keyword">var</span> option <span class="keyword">in</span> options) {
    combinedStream[option] = options[option];
  }

  <span class="keyword">return</span> combinedStream;
};

CombinedStream.isStreamLike = <span class="keyword">function</span>(stream) {
  <span class="keyword">return</span> (<span class="keyword">typeof</span> stream !== <span class="string">'function'</span>)
    &amp;&amp; (<span class="keyword">typeof</span> stream !== <span class="string">'string'</span>)
    &amp;&amp; (!Buffer.isBuffer(stream));
};

CombinedStream.prototype.append = <span class="keyword">function</span>(stream) {
  <span class="keyword">var</span> isStreamLike = CombinedStream.isStreamLike(stream);

  <span class="keyword">if</span> (isStreamLike) {
    <span class="keyword">if</span> (!(stream <span class="keyword">instanceof</span> DelayedStream)) {
      stream.on(<span class="string">'data'</span>, <span class="keyword">this</span>._checkDataSize.bind(<span class="keyword">this</span>));

      stream = DelayedStream.create(stream, {
        maxDataSize: <span class="literal">Infinity</span>,
        pauseStream: <span class="keyword">this</span>.pauseStreams,
      });
    }

    <span class="keyword">this</span>._handleErrors(stream);

    <span class="keyword">if</span> (<span class="keyword">this</span>.pauseStreams) {
      stream.pause();
    }
  }

  <span class="keyword">this</span>._streams.push(stream);
  <span class="keyword">return</span> <span class="keyword">this</span>;
};

CombinedStream.prototype.pipe = <span class="keyword">function</span>(dest, options) {
  Stream.prototype.pipe.call(<span class="keyword">this</span>, dest, options);
  <span class="keyword">this</span>.resume();
};

CombinedStream.prototype._getNext = <span class="keyword">function</span>() {
  <span class="keyword">this</span>._currentStream = <span class="literal">null</span>;
  <span class="keyword">var</span> stream = <span class="keyword">this</span>._streams.shift();


  <span class="keyword">if</span> (!stream) {
    <span class="keyword">this</span>.end();
    <span class="keyword">return</span>;
  }

  <span class="keyword">if</span> (<span class="keyword">typeof</span> stream !== <span class="string">'function'</span>) {
    <span class="keyword">this</span>._pipeNext(stream);
    <span class="keyword">return</span>;
  }

  <span class="keyword">var</span> getStream = stream;
  getStream(<span class="keyword">function</span>(stream) {
    <span class="keyword">var</span> isStreamLike = CombinedStream.isStreamLike(stream);
    <span class="keyword">if</span> (isStreamLike) {
      stream.on(<span class="string">'data'</span>, <span class="keyword">this</span>._checkDataSize.bind(<span class="keyword">this</span>));
      <span class="keyword">this</span>._handleErrors(stream);
    }

    <span class="keyword">this</span>._pipeNext(stream);
  }.bind(<span class="keyword">this</span>));
};

CombinedStream.prototype._pipeNext = <span class="keyword">function</span>(stream) {
  <span class="keyword">this</span>._currentStream = stream;

  <span class="keyword">var</span> isStreamLike = CombinedStream.isStreamLike(stream);
  <span class="keyword">if</span> (isStreamLike) {
    stream.on(<span class="string">'end'</span>, <span class="keyword">this</span>._getNext.bind(<span class="keyword">this</span>))
    stream.pipe(<span class="keyword">this</span>, {end: <span class="literal">false</span>});
    <span class="keyword">return</span>;
  }

  <span class="keyword">var</span> value = stream;
  <span class="keyword">this</span>.write(value);
  <span class="keyword">this</span>._getNext();
};

CombinedStream.prototype._handleErrors = <span class="keyword">function</span>(stream) {
  <span class="keyword">var</span> self = <span class="keyword">this</span>;
  stream.on(<span class="string">'error'</span>, <span class="keyword">function</span>(err) {
    self._emitError(err);
  });
};

CombinedStream.prototype.write = <span class="keyword">function</span>(data) {
  <span class="keyword">this</span>.emit(<span class="string">'data'</span>, data);
};

CombinedStream.prototype.pause = <span class="keyword">function</span>() {
  <span class="keyword">if</span> (!<span class="keyword">this</span>.pauseStreams) {
    <span class="keyword">return</span>;
  }

  <span class="keyword">this</span>.emit(<span class="string">'pause'</span>);
};

CombinedStream.prototype.resume = <span class="keyword">function</span>() {
  <span class="keyword">if</span> (!<span class="keyword">this</span>._released) {
    <span class="keyword">this</span>._released = <span class="literal">true</span>;
    <span class="keyword">this</span>.writable = <span class="literal">true</span>;
    <span class="keyword">this</span>._getNext();
  }

  <span class="keyword">this</span>.emit(<span class="string">'resume'</span>);
};

CombinedStream.prototype.end = <span class="keyword">function</span>() {
  <span class="keyword">this</span>._reset();
  <span class="keyword">this</span>.emit(<span class="string">'end'</span>);
};

CombinedStream.prototype.destroy = <span class="keyword">function</span>() {
  <span class="keyword">this</span>._reset();
  <span class="keyword">this</span>.emit(<span class="string">'close'</span>);
};

CombinedStream.prototype._reset = <span class="keyword">function</span>() {
  <span class="keyword">this</span>.writable = <span class="literal">false</span>;
  <span class="keyword">this</span>._streams = [];
  <span class="keyword">this</span>._currentStream = <span class="literal">null</span>;
};

CombinedStream.prototype._checkDataSize = <span class="keyword">function</span>() {
  <span class="keyword">this</span>._updateDataSize();
  <span class="keyword">if</span> (<span class="keyword">this</span>.dataSize &lt;= <span class="keyword">this</span>.maxDataSize) {
    <span class="keyword">return</span>;
  }

  <span class="keyword">var</span> message =
    <span class="string">'DelayedStream#maxDataSize of '</span> + <span class="keyword">this</span>.maxDataSize + <span class="string">' bytes exceeded.'</span>
  <span class="keyword">this</span>._emitError(<span class="keyword">new</span> Error(message));
};

CombinedStream.prototype._updateDataSize = <span class="keyword">function</span>() {
  <span class="keyword">this</span>.dataSize = <span class="number">0</span>;

  <span class="keyword">var</span> self = <span class="keyword">this</span>;
  <span class="keyword">this</span>._streams.forEach(<span class="keyword">function</span>(stream) {
    <span class="keyword">if</span> (!stream.dataSize) {
      <span class="keyword">return</span>;
    }

    self.dataSize += stream.dataSize;
  });

  <span class="keyword">if</span> (<span class="keyword">this</span>._currentStream &amp;&amp; <span class="keyword">this</span>._currentStream.dataSize) {
    <span class="keyword">this</span>.dataSize += <span class="keyword">this</span>._currentStream.dataSize;
  }
};

CombinedStream.prototype._emitError = <span class="keyword">function</span>(err) {
  <span class="keyword">this</span>._reset();
  <span class="keyword">this</span>.emit(<span class="string">'error'</span>, err);
};
</code></pre>