<h1>aws.js</h1>
<pre><code class="lang-js"><span class="comment">/*!
 * knox - auth
 * Copyright(c) 2010 LearnBoost &lt;dev@learnboost.com>
 * MIT Licensed
 */</span>

<span class="comment">/**
 * Module dependencies.
 */</span>

<span class="keyword">var</span> crypto = require(<span class="string">'crypto'</span>)
  , parse = require(<span class="string">'url'</span>).parse;

<span class="comment">/**
 * Valid keys.
 */</span>

<span class="keyword">var</span> keys = [
    <span class="string">'acl'</span>
  , <span class="string">'location'</span>
  , <span class="string">'logging'</span>
  , <span class="string">'notification'</span>
  , <span class="string">'partNumber'</span>
  , <span class="string">'policy'</span>
  , <span class="string">'requestPayment'</span>
  , <span class="string">'torrent'</span>
  , <span class="string">'uploadId'</span>
  , <span class="string">'uploads'</span>
  , <span class="string">'versionId'</span>
  , <span class="string">'versioning'</span>
  , <span class="string">'versions'</span>
  , <span class="string">'website'</span>
];

<span class="comment">/**
 * Return an "Authorization" header value with the given `options`
 * in the form of "AWS &lt;key>:&lt;signature>"
 *
 * @param {Object} options
 * @return {String}
 * @api private
 */</span>

exports.authorization = <span class="keyword">function</span>(options){
  <span class="keyword">return</span> <span class="string">'AWS '</span> + options.key + <span class="string">':'</span> + exports.sign(options);
};

<span class="comment">/**
 * Simple HMAC-SHA1 Wrapper
 *
 * @param {Object} options
 * @return {String}
 * @api private
 */</span> 

exports.hmacSha1 = <span class="keyword">function</span>(options){
  <span class="keyword">return</span> crypto.createHmac(<span class="string">'sha1'</span>, options.secret).update(options.message).digest(<span class="string">'base64'</span>);
};

<span class="comment">/**
 * Create a base64 sha1 HMAC for `options`. 
 * 
 * @param {Object} options
 * @return {String}
 * @api private
 */</span>

exports.sign = <span class="keyword">function</span>(options){
  options.message = exports.stringToSign(options);
  <span class="keyword">return</span> exports.hmacSha1(options);
};

<span class="comment">/**
 * Create a base64 sha1 HMAC for `options`. 
 *
 * Specifically to be used with S3 presigned URLs
 * 
 * @param {Object} options
 * @return {String}
 * @api private
 */</span>

exports.signQuery = <span class="keyword">function</span>(options){
  options.message = exports.queryStringToSign(options);
  <span class="keyword">return</span> exports.hmacSha1(options);
};

<span class="comment">/**
 * Return a string for sign() with the given `options`.
 *
 * Spec:
 * 
 *    &lt;verb>\n
 *    &lt;md5>\n
 *    &lt;content-type>\n
 *    &lt;date>\n
 *    [headers\n]
 *    &lt;resource>
 *
 * @param {Object} options
 * @return {String}
 * @api private
 */</span>

exports.stringToSign = <span class="keyword">function</span>(options){
  <span class="keyword">var</span> headers = options.amazonHeaders || <span class="string">''</span>;
  <span class="keyword">if</span> (headers) headers += <span class="string">'\n'</span>;
  <span class="keyword">return</span> [
      options.verb
    , options.md5
    , options.contentType
    , options.date.toUTCString()
    , headers + options.resource
  ].join(<span class="string">'\n'</span>);
};

<span class="comment">/**
 * Return a string for sign() with the given `options`, but is meant exclusively
 * for S3 presigned URLs
 *
 * Spec:
 * 
 *    &lt;date>\n
 *    &lt;resource>
 *
 * @param {Object} options
 * @return {String}
 * @api private
 */</span>

exports.queryStringToSign = <span class="keyword">function</span>(options){
  <span class="keyword">return</span> <span class="string">'GET\n\n\n'</span> +
    options.date + <span class="string">'\n'</span> +
    options.resource;
};

<span class="comment">/**
 * Perform the following:
 *
 *  - ignore non-amazon headers
 *  - lowercase fields
 *  - sort lexicographically
 *  - trim whitespace between ":"
 *  - join with newline
 *
 * @param {Object} headers
 * @return {String}
 * @api private
 */</span>

exports.canonicalizeHeaders = <span class="keyword">function</span>(headers){
  <span class="keyword">var</span> buf = []
    , fields = Object.keys(headers);
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = fields.length; i &lt; len; ++i) {
    <span class="keyword">var</span> field = fields[i]
      , val = headers[field]
      , field = field.toLowerCase();
    <span class="keyword">if</span> (<span class="number">0</span> !== field.indexOf(<span class="string">'x-amz'</span>)) <span class="keyword">continue</span>;
    buf.push(field + <span class="string">':'</span> + val);
  }
  <span class="keyword">return</span> buf.sort().join(<span class="string">'\n'</span>);
};

<span class="comment">/**
 * Perform the following:
 *
 *  - ignore non sub-resources
 *  - sort lexicographically
 *
 * @param {String} resource
 * @return {String}
 * @api private
 */</span>

exports.canonicalizeResource = <span class="keyword">function</span>(resource){
  <span class="keyword">var</span> url = parse(resource, <span class="literal">true</span>)
    , path = url.pathname
    , buf = [];

  Object.keys(url.query).forEach(<span class="keyword">function</span>(key){
    <span class="keyword">if</span> (!~keys.indexOf(key)) <span class="keyword">return</span>;
    <span class="keyword">var</span> val = <span class="string">''</span> == url.query[key] ? <span class="string">''</span> : <span class="string">'='</span> + encodeURIComponent(url.query[key]);
    buf.push(key + val);
  });

  <span class="keyword">return</span> path + (buf.length
    ? <span class="string">'?'</span> + buf.sort().join(<span class="string">'&amp;'</span>)
    : <span class="string">''</span>);
};
</code></pre>