<h1>xpath.js</h1>
<pre><code class="lang-js"><span class="comment">/** Here is yet another implementation of XPath 1.0 in Javascript.
 *
 * My goal was to make it relatively compact, but as I fixed all the axis bugs
 * the axes became more and more complicated. :-(.
 *
 * I have not implemented namespaces or case-sensitive axes for XML yet.
 *
 * How to test it in Chrome: You can make a Chrome extension that replaces
 * the WebKit XPath parser with this one. But it takes a bit of effort to
 * get around isolated world and same-origin restrictions:
 * manifest.json:
    {
      "name": "XPathTest",
      "version": "0.1",
      "content_scripts": [{
        "matches": ["http://localhost/*"],  // or wildcard host
        "js": ["xpath.js", "injection.js"],
        "all_frames": true, "run_at": "document_start"
      }]
    }
 * injection.js:
    // goal: give my xpath object to the website's JS context.
    var script = document.createElement('script');
    script.textContent =
        "document.addEventListener('xpathextend', function(e) {\n" +
        "  console.log('extending document with xpath...');\n" +
        "  e.detail(window);" +
        "});";
    document.documentElement.appendChild(script);
    document.documentElement.removeChild(script);
    var evt = document.createEvent('CustomEvent');
    evt.initCustomEvent('xpathextend', true, true, this.xpath.extend);
    document.dispatchEvent(evt);
 */</span>
(<span class="keyword">function</span>() {
  <span class="keyword">var</span> core;
  <span class="keyword">var</span> xpath;
  <span class="keyword">if</span> (<span class="string">'function'</span> === <span class="keyword">typeof</span> require) {
    core = require(<span class="string">"../level3/core"</span>).dom.level3.core;
    xpath = exports;
  } <span class="keyword">else</span> {
    core = <span class="keyword">this</span>;
    xpath = {};
  }


  <span class="comment">/***************************************************************************
   *                            Tokenization                                 *
   ***************************************************************************/</span>
  <span class="comment">/**
   * The XPath lexer is basically a single regular expression, along with
   * some helper functions to pop different types.
   */</span>
  <span class="keyword">var</span> Stream = xpath.Stream = <span class="function"><span class="keyword">function</span> <span class="title">Stream</span><span class="params">(str)</span> {</span>
    <span class="keyword">this</span>.original = <span class="keyword">this</span>.str = str;
    <span class="keyword">this</span>.peeked = <span class="literal">null</span>;
    <span class="comment">// TODO: not really needed, but supposedly tokenizer also disambiguates</span>
    <span class="comment">// a * b vs. node test *</span>
    <span class="keyword">this</span>.prev = <span class="literal">null</span>;  <span class="comment">// for debugging</span>
    <span class="keyword">this</span>.prevprev = <span class="literal">null</span>;
  }
  Stream.prototype = {
    peek: <span class="keyword">function</span>() {
      <span class="keyword">if</span> (<span class="keyword">this</span>.peeked) <span class="keyword">return</span> <span class="keyword">this</span>.peeked;
      <span class="keyword">var</span> m = <span class="keyword">this</span>.re.exec(<span class="keyword">this</span>.str);
      <span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="literal">null</span>;
      <span class="keyword">this</span>.str = <span class="keyword">this</span>.str.substr(m[<span class="number">0</span>].length);
      <span class="keyword">return</span> <span class="keyword">this</span>.peeked = m[<span class="number">1</span>];
    },
    <span class="comment">/** Peek 2 tokens ahead. */</span>
    peek2: <span class="keyword">function</span>() {
      <span class="keyword">this</span>.peek();  <span class="comment">// make sure this.peeked is set</span>
      <span class="keyword">var</span> m = <span class="keyword">this</span>.re.exec(<span class="keyword">this</span>.str);
      <span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="literal">null</span>;
      <span class="keyword">return</span> m[<span class="number">1</span>];
    },
    pop: <span class="keyword">function</span>() {
      <span class="keyword">var</span> r = <span class="keyword">this</span>.peek();
      <span class="keyword">this</span>.peeked = <span class="literal">null</span>;
      <span class="keyword">this</span>.prevprev = <span class="keyword">this</span>.prev;
      <span class="keyword">this</span>.prev = r;
      <span class="keyword">return</span> r;
    },
    trypop: <span class="keyword">function</span>(tokens) {
      <span class="keyword">var</span> tok = <span class="keyword">this</span>.peek();
      <span class="keyword">if</span> (tok === tokens) <span class="keyword">return</span> <span class="keyword">this</span>.pop();
      <span class="keyword">if</span> (Array.isArray(tokens)) {
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; tokens.length; ++i) {
          <span class="keyword">var</span> t = tokens[i];
          <span class="keyword">if</span> (t == tok) <span class="keyword">return</span> <span class="keyword">this</span>.pop();;
        }
      }
    },
    trypopfuncname: <span class="keyword">function</span>() {
      <span class="keyword">var</span> tok = <span class="keyword">this</span>.peek();
      <span class="keyword">if</span> (!<span class="keyword">this</span>.isQnameRe.test(tok))
        <span class="keyword">return</span> <span class="literal">null</span>;
      <span class="keyword">switch</span> (tok) {
        <span class="keyword">case</span> <span class="string">'comment'</span>: <span class="keyword">case</span> <span class="string">'text'</span>: <span class="keyword">case</span> <span class="string">'processing-instruction'</span>: <span class="keyword">case</span> <span class="string">'node'</span>:
          <span class="keyword">return</span> <span class="literal">null</span>;
      }
      <span class="keyword">if</span> (<span class="string">'('</span> != <span class="keyword">this</span>.peek2()) <span class="keyword">return</span> <span class="literal">null</span>;
      <span class="keyword">return</span> <span class="keyword">this</span>.pop();
    },
    trypopaxisname: <span class="keyword">function</span>() {
      <span class="keyword">var</span> tok = <span class="keyword">this</span>.peek();
      <span class="keyword">switch</span> (tok) {
        <span class="keyword">case</span> <span class="string">'ancestor'</span>: <span class="keyword">case</span> <span class="string">'ancestor-or-self'</span>: <span class="keyword">case</span> <span class="string">'attribute'</span>:
        <span class="keyword">case</span> <span class="string">'child'</span>: <span class="keyword">case</span> <span class="string">'descendant'</span>: <span class="keyword">case</span> <span class="string">'descendant-or-self'</span>:
        <span class="keyword">case</span> <span class="string">'following'</span>: <span class="keyword">case</span> <span class="string">'following-sibling'</span>: <span class="keyword">case</span> <span class="string">'namespace'</span>:
        <span class="keyword">case</span> <span class="string">'parent'</span>: <span class="keyword">case</span> <span class="string">'preceding'</span>: <span class="keyword">case</span> <span class="string">'preceding-sibling'</span>: <span class="keyword">case</span> <span class="string">'self'</span>:
          <span class="keyword">if</span> (<span class="string">'::'</span> == <span class="keyword">this</span>.peek2()) <span class="keyword">return</span> <span class="keyword">this</span>.pop();
      }
      <span class="keyword">return</span> <span class="literal">null</span>;
    },
    trypopnametest: <span class="keyword">function</span>() {
      <span class="keyword">var</span> tok = <span class="keyword">this</span>.peek();
      <span class="keyword">if</span> (<span class="string">'*'</span> === tok || <span class="keyword">this</span>.startsWithNcNameRe.test(tok)) <span class="keyword">return</span> <span class="keyword">this</span>.pop();
      <span class="keyword">return</span> <span class="literal">null</span>;
    },
    trypopliteral: <span class="keyword">function</span>() {
      <span class="keyword">var</span> tok = <span class="keyword">this</span>.peek();
      <span class="keyword">if</span> (<span class="literal">null</span> == tok) <span class="keyword">return</span> <span class="literal">null</span>;
      <span class="keyword">var</span> first = tok.charAt(<span class="number">0</span>);
      <span class="keyword">var</span> last = tok.charAt(tok.length - <span class="number">1</span>);
      <span class="keyword">if</span> (<span class="string">'"'</span> === first &amp;&amp; <span class="string">'"'</span> === last ||
          <span class="string">"'"</span> === first &amp;&amp; <span class="string">"'"</span> === last) {
        <span class="keyword">this</span>.pop();
        <span class="keyword">return</span> tok.substr(<span class="number">1</span>, tok.length - <span class="number">2</span>);
      }
    },
    trypopnumber: <span class="keyword">function</span>() {
      <span class="keyword">var</span> tok = <span class="keyword">this</span>.peek();
      <span class="keyword">if</span> (<span class="keyword">this</span>.isNumberRe.test(tok)) <span class="keyword">return</span> parseFloat(<span class="keyword">this</span>.pop());
      <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">null</span>;
    },
    trypopvarref: <span class="keyword">function</span>() {
      <span class="keyword">var</span> tok = <span class="keyword">this</span>.peek();
      <span class="keyword">if</span> (<span class="literal">null</span> == tok) <span class="keyword">return</span> <span class="literal">null</span>;
      <span class="keyword">if</span> (<span class="string">'$'</span> === tok.charAt(<span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">this</span>.pop().substr(<span class="number">1</span>);
      <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">null</span>;
    },
    position: <span class="keyword">function</span>() {
      <span class="keyword">return</span> <span class="keyword">this</span>.original.length - <span class="keyword">this</span>.str.length;
    }
  };
  (<span class="keyword">function</span>() {
    <span class="comment">// http://www.w3.org/TR/REC-xml-names/#NT-NCName</span>
    <span class="keyword">var</span> nameStartCharsExceptColon =
        <span class="string">'A-Z_a-z\xc0-\xd6\xd8-\xf6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF'</span> +
        <span class="string">'\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF'</span> +
        <span class="string">'\uFDF0-\uFFFD'</span>;  <span class="comment">// JS doesn't support [#x10000-#xEFFFF]</span>
    <span class="keyword">var</span> nameCharExceptColon = nameStartCharsExceptColon +
        <span class="string">'\\-\\.0-9\xb7\u0300-\u036F\u203F-\u2040'</span>;
    <span class="keyword">var</span> ncNameChars = <span class="string">'['</span> + nameStartCharsExceptColon +
        <span class="string">']['</span> + nameCharExceptColon + <span class="string">']*'</span>
    <span class="comment">// http://www.w3.org/TR/REC-xml-names/#NT-QName</span>
    <span class="keyword">var</span> qNameChars = ncNameChars + <span class="string">'(?::'</span> + ncNameChars + <span class="string">')?'</span>;
    <span class="keyword">var</span> otherChars = <span class="string">'\\.\\.|[\\(\\)\\[\\].@,]|::'</span>;  <span class="comment">// .. must come before [.]</span>
    <span class="keyword">var</span> operatorChars =
        <span class="string">'and|or|mod|div|'</span> +
        <span class="string">'//|!=|&lt;=|>=|[*/|+\\-=&lt;>]'</span>;  <span class="comment">// //, !=, &lt;=, >= before individual ones.</span>
    <span class="keyword">var</span> literal = <span class="string">'"[^"]*"|'</span> + <span class="string">"'[^']*'"</span>;
    <span class="keyword">var</span> numberChars = <span class="string">'[0-9]+(?:\\.[0-9]*)?|\\.[0-9]+'</span>;
    <span class="keyword">var</span> variableReference = <span class="string">'\\$'</span> + qNameChars;
    <span class="keyword">var</span> nameTestChars = <span class="string">'\\*|'</span> + ncNameChars + <span class="string">':\\*|'</span> + qNameChars;
    <span class="keyword">var</span> optionalSpace = <span class="string">'[ \t\r\n]*'</span>;  <span class="comment">// stricter than regexp \s.</span>
    <span class="keyword">var</span> nodeType = <span class="string">'comment|text|processing-instruction|node'</span>;
    <span class="keyword">var</span> re = <span class="keyword">new</span> RegExp(
        <span class="comment">// numberChars before otherChars so that leading-decimal doesn't become .</span>
        <span class="string">'^'</span> + optionalSpace + <span class="string">'('</span> + numberChars + <span class="string">'|'</span> + otherChars + <span class="string">'|'</span> +
        nameTestChars + <span class="string">'|'</span> + operatorChars + <span class="string">'|'</span> + literal + <span class="string">'|'</span> +
        variableReference + <span class="string">')'</span>
        <span class="comment">// operatorName | nodeType | functionName | axisName are lumped into</span>
        <span class="comment">// qName for now; we'll check them on pop.</span>
    );
    Stream.prototype.re = re;
    Stream.prototype.startsWithNcNameRe = <span class="keyword">new</span> RegExp(<span class="string">'^'</span> + ncNameChars);
    Stream.prototype.isQnameRe = <span class="keyword">new</span> RegExp(<span class="string">'^'</span> + qNameChars + <span class="string">'$'</span>);
    Stream.prototype.isNumberRe = <span class="keyword">new</span> RegExp(<span class="string">'^'</span> + numberChars + <span class="string">'$'</span>);
  })();

  <span class="comment">/***************************************************************************
   *                               Parsing                                   *
   ***************************************************************************/</span>
  <span class="keyword">var</span> parse = xpath.parse = <span class="function"><span class="keyword">function</span> <span class="title">parse</span><span class="params">(stream, a)</span> {</span>
    <span class="keyword">var</span> r = orExpr(stream,a);
    <span class="keyword">var</span> x, unparsed = [];
    <span class="keyword">while</span> (x = stream.pop()) {
      unparsed.push(x);
    }
    <span class="keyword">if</span> (unparsed.length)
      <span class="keyword">throw</span> <span class="keyword">new</span> XPathException(XPathException.INVALID_EXPRESSION_ERR,
                               <span class="string">'Position '</span> + stream.position() +
                               <span class="string">': Unparsed tokens: '</span> + unparsed.join(<span class="string">' '</span>));
    <span class="keyword">return</span> r;
  }

  <span class="comment">/**
   * binaryL  ::= subExpr
   *            | binaryL op subExpr
   * so a op b op c becomes ((a op b) op c)
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">binaryL</span><span class="params">(subExpr, stream, a, ops)</span> {</span>
    <span class="keyword">var</span> lhs = subExpr(stream, a);
    <span class="keyword">if</span> (lhs == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;
    <span class="keyword">var</span> op;
    <span class="keyword">while</span> (op = stream.trypop(ops)) {
      <span class="keyword">var</span> rhs = subExpr(stream, a);
      <span class="keyword">if</span> (rhs == <span class="literal">null</span>)
        <span class="keyword">throw</span> <span class="keyword">new</span> XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 <span class="string">'Position '</span> + stream.position() +
                                 <span class="string">': Expected something after '</span> + op);
      lhs = a.node(op, lhs, rhs);
    }
    <span class="keyword">return</span> lhs;
  }
  <span class="comment">/**
   * Too bad this is never used. If they made a ** operator (raise to power),
   ( we would use it.
   * binaryR  ::= subExpr
   *            | subExpr op binaryR
   * so a op b op c becomes (a op (b op c))
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">binaryR</span><span class="params">(subExpr, stream, a, ops)</span> {</span>
    <span class="keyword">var</span> lhs = subExpr(stream, a);
    <span class="keyword">if</span> (lhs == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;
    <span class="keyword">var</span> op = stream.trypop(ops);
    <span class="keyword">if</span> (op) {
      <span class="keyword">var</span> rhs = binaryR(stream, a);
      <span class="keyword">if</span> (rhs == <span class="literal">null</span>)
        <span class="keyword">throw</span> <span class="keyword">new</span> XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 <span class="string">'Position '</span> + stream.position() +
                                 <span class="string">': Expected something after '</span> + op);
      <span class="keyword">return</span> a.node(op, lhs, rhs);
    } <span class="keyword">else</span> {
      <span class="keyword">return</span> lhs;<span class="comment">// TODO</span>
    }
  }
  <span class="comment">/** [1] LocationPath::= RelativeLocationPath | AbsoluteLocationPath
   * e.g. a, a/b, //a/b
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">locationPath</span><span class="params">(stream, a)</span> {</span>
    <span class="keyword">return</span> absoluteLocationPath(stream, a) ||
           relativeLocationPath(<span class="literal">null</span>, stream, a);
  }
  <span class="comment">/** [2] AbsoluteLocationPath::= '/' RelativeLocationPath? | AbbreviatedAbsoluteLocationPath
   *  [10] AbbreviatedAbsoluteLocationPath::= '//' RelativeLocationPath
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">absoluteLocationPath</span><span class="params">(stream, a)</span> {</span>
    <span class="keyword">var</span> op = stream.peek();
    <span class="keyword">if</span> (<span class="string">'/'</span> === op || <span class="string">'//'</span> === op) {
      <span class="keyword">var</span> lhs = a.node(<span class="string">'Root'</span>);
      <span class="keyword">return</span> relativeLocationPath(lhs, stream, a, <span class="literal">true</span>);
    } <span class="keyword">else</span> {
      <span class="keyword">return</span> <span class="literal">null</span>;
    }
  }
  <span class="comment">/** [3] RelativeLocationPath::= Step | RelativeLocationPath '/' Step |
   *                            | AbbreviatedRelativeLocationPath
   *  [11] AbbreviatedRelativeLocationPath::= RelativeLocationPath '//' Step
   * e.g. p/a, etc.
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">relativeLocationPath</span><span class="params">(lhs, stream, a, isOnlyRootOk)</span> {</span>
    <span class="keyword">if</span> (<span class="literal">null</span> == lhs) {
      lhs = step(stream, a);
      <span class="keyword">if</span> (<span class="literal">null</span> == lhs) <span class="keyword">return</span> lhs;
    }
    <span class="keyword">var</span> op;
    <span class="keyword">while</span> (op = stream.trypop([<span class="string">'/'</span>, <span class="string">'//'</span>])) {
      <span class="keyword">if</span> (<span class="string">'//'</span> === op) {
        lhs = a.node(<span class="string">'/'</span>, lhs,
                     a.node(<span class="string">'Axis'</span>, <span class="string">'descendant-or-self'</span>, <span class="string">'node'</span>, <span class="literal">undefined</span>));
      }
      <span class="keyword">var</span> rhs = step(stream, a);
      <span class="keyword">if</span> (<span class="literal">null</span> == rhs &amp;&amp; <span class="string">'/'</span> === op &amp;&amp; isOnlyRootOk) <span class="keyword">return</span> lhs;
      <span class="keyword">else</span> isOnlyRootOk = <span class="literal">false</span>;
      <span class="keyword">if</span> (<span class="literal">null</span> == rhs)
        <span class="keyword">throw</span> <span class="keyword">new</span> XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 <span class="string">'Position '</span> + stream.position() +
                                 <span class="string">': Expected step after '</span> + op);
      lhs = a.node(<span class="string">'/'</span>, lhs, rhs);
    }
    <span class="keyword">return</span> lhs;
  }
  <span class="comment">/** [4] Step::= AxisSpecifier NodeTest Predicate* | AbbreviatedStep
   *  [12] AbbreviatedStep::= '.' | '..'
   * e.g. @href, self::p, p, a[@href], ., ..
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">step</span><span class="params">(stream, a)</span> {</span>
    <span class="keyword">var</span> abbrStep = stream.trypop([<span class="string">'.'</span>, <span class="string">'..'</span>]);
    <span class="keyword">if</span> (<span class="string">'.'</span> === abbrStep)  <span class="comment">// A location step of . is short for self::node().</span>
      <span class="keyword">return</span> a.node(<span class="string">'Axis'</span>, <span class="string">'self'</span>, <span class="string">'node'</span>);
    <span class="keyword">if</span> (<span class="string">'..'</span> === abbrStep)  <span class="comment">// A location step of .. is short for parent::node()</span>
      <span class="keyword">return</span> a.node(<span class="string">'Axis'</span>, <span class="string">'parent'</span>, <span class="string">'node'</span>);

    <span class="keyword">var</span> axis = axisSpecifier(stream, a);
    <span class="keyword">var</span> nodeType = nodeTypeTest(stream, a);
    <span class="keyword">var</span> nodeName;
    <span class="keyword">if</span> (<span class="literal">null</span> == nodeType) nodeName = nodeNameTest(stream, a);
    <span class="keyword">if</span> (<span class="literal">null</span> == axis &amp;&amp; <span class="literal">null</span> == nodeType &amp;&amp; <span class="literal">null</span> == nodeName) <span class="keyword">return</span> <span class="literal">null</span>;
    <span class="keyword">if</span> (<span class="literal">null</span> == nodeType &amp;&amp; <span class="literal">null</span> == nodeName)
        <span class="keyword">throw</span> <span class="keyword">new</span> XPathException(
            XPathException.INVALID_EXPRESSION_ERR,
            <span class="string">'Position '</span> + stream.position() +
            <span class="string">': Expected nodeTest after axisSpecifier '</span> + axis);
    <span class="keyword">if</span> (<span class="literal">null</span> == axis) axis = <span class="string">'child'</span>;
    <span class="keyword">if</span> (<span class="literal">null</span> == nodeType) {
      <span class="comment">// When there's only a node name, then the node type is forced to be the</span>
      <span class="comment">// principal node type of the axis.</span>
      <span class="comment">// see http://www.w3.org/TR/xpath/#dt-principal-node-type</span>
      <span class="keyword">if</span> (<span class="string">'attribute'</span> === axis) nodeType = <span class="string">'attribute'</span>;
      <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'namespace'</span> === axis) nodeType = <span class="string">'namespace'</span>;
      <span class="keyword">else</span> nodeType = <span class="string">'element'</span>;
    }
    <span class="keyword">var</span> lhs = a.node(<span class="string">'Axis'</span>, axis, nodeType, nodeName);
    <span class="keyword">var</span> pred;
    <span class="keyword">while</span> (<span class="literal">null</span> != (pred = predicate(lhs, stream, a))) {
      lhs = pred;
    }
    <span class="keyword">return</span> lhs;
  }
  <span class="comment">/** [5] AxisSpecifier::= AxisName '::' | AbbreviatedAxisSpecifier
   *  [6] AxisName::= 'ancestor' | 'ancestor-or-self' | 'attribute' | 'child'
   *                | 'descendant' | 'descendant-or-self' | 'following'
   *                | 'following-sibling' | 'namespace' | 'parent' |
   *                | 'preceding' | 'preceding-sibling' | 'self'
   *  [13] AbbreviatedAxisSpecifier::= '@'?
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">axisSpecifier</span><span class="params">(stream, a)</span> {</span>
    <span class="keyword">var</span> attr = stream.trypop(<span class="string">'@'</span>);
    <span class="keyword">if</span> (<span class="literal">null</span> != attr) <span class="keyword">return</span> <span class="string">'attribute'</span>;
    <span class="keyword">var</span> axisName = stream.trypopaxisname();
    <span class="keyword">if</span> (<span class="literal">null</span> != axisName) {
      <span class="keyword">var</span> coloncolon = stream.trypop(<span class="string">'::'</span>);
      <span class="keyword">if</span> (<span class="literal">null</span> == coloncolon)
        <span class="keyword">throw</span> <span class="keyword">new</span> XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 <span class="string">'Position '</span> + stream.position() +
                                 <span class="string">': Should not happen. Should be ::.'</span>);
      <span class="keyword">return</span> axisName;
    }
  }
  <span class="comment">/** [7] NodeTest::= NameTest | NodeType '(' ')' | 'processing-instruction' '(' Literal ')'
   *  [38] NodeType::= 'comment' | 'text' | 'processing-instruction' | 'node'
   * I've split nodeTypeTest from nodeNameTest for convenience.
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">nodeTypeTest</span><span class="params">(stream, a)</span> {</span>
    <span class="keyword">if</span> (<span class="string">'('</span> !== stream.peek2()) {
      <span class="keyword">return</span> <span class="literal">null</span>;
    }
    <span class="keyword">var</span> type = stream.trypop([<span class="string">'comment'</span>, <span class="string">'text'</span>, <span class="string">'processing-instruction'</span>, <span class="string">'node'</span>]);
    <span class="keyword">if</span> (<span class="literal">null</span> != type) {
      <span class="keyword">if</span> (<span class="literal">null</span> == stream.trypop(<span class="string">'('</span>))
        <span class="keyword">throw</span> <span class="keyword">new</span> XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 <span class="string">'Position '</span> + stream.position() +
                                 <span class="string">': Should not happen.'</span>);
      <span class="keyword">var</span> param = <span class="literal">undefined</span>;
      <span class="keyword">if</span> (type == <span class="string">'processing-instruction'</span>) {
        param = stream.trypopliteral();
      }
      <span class="keyword">if</span> (<span class="literal">null</span> == stream.trypop(<span class="string">')'</span>))
        <span class="keyword">throw</span> <span class="keyword">new</span> XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 <span class="string">'Position '</span> + stream.position() +
                                 <span class="string">': Expected close parens.'</span>);
      <span class="keyword">return</span> type
    }
  }
  <span class="function"><span class="keyword">function</span> <span class="title">nodeNameTest</span><span class="params">(stream, a)</span> {</span>
    <span class="keyword">var</span> name = stream.trypopnametest();
    <span class="keyword">if</span> (name != <span class="literal">null</span>) <span class="keyword">return</span> name;
    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">null</span>;
  }
  <span class="comment">/** [8] Predicate::= '[' PredicateExpr ']'
   *  [9] PredicateExpr::= Expr
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">predicate</span><span class="params">(lhs, stream, a)</span> {</span>
    <span class="keyword">if</span> (<span class="literal">null</span> == stream.trypop(<span class="string">'['</span>)) <span class="keyword">return</span> <span class="literal">null</span>;
    <span class="keyword">var</span> expr = orExpr(stream, a);
    <span class="keyword">if</span> (<span class="literal">null</span> == expr)
      <span class="keyword">throw</span> <span class="keyword">new</span> XPathException(XPathException.INVALID_EXPRESSION_ERR,
                               <span class="string">'Position '</span> + stream.position() +
                               <span class="string">': Expected expression after ['</span>);
    <span class="keyword">if</span> (<span class="literal">null</span> == stream.trypop(<span class="string">']'</span>))
      <span class="keyword">throw</span> <span class="keyword">new</span> XPathException(XPathException.INVALID_EXPRESSION_ERR,
                               <span class="string">'Position '</span> + stream.position() +
                               <span class="string">': Expected ] after expression.'</span>);
    <span class="keyword">return</span> a.node(<span class="string">'Predicate'</span>, lhs, expr);
  }
  <span class="comment">/** [14] Expr::= OrExpr
   */</span>
  <span class="comment">/** [15] PrimaryExpr::= VariableReference | '(' Expr ')' | Literal | Number | FunctionCall
   * e.g. $x,  (3+4),  "hi",  32,  f(x)
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">primaryExpr</span><span class="params">(stream, a)</span> {</span>
    <span class="keyword">var</span> x = stream.trypopliteral();
    <span class="keyword">if</span> (<span class="literal">null</span> == x)
      x = stream.trypopnumber();
    <span class="keyword">if</span> (<span class="literal">null</span> != x) {
      <span class="keyword">return</span> x;
    }
    <span class="keyword">var</span> varRef = stream.trypopvarref();
    <span class="keyword">if</span> (<span class="literal">null</span> != varRef) <span class="keyword">return</span> a.node(<span class="string">'VariableReference'</span>, varRef);
    <span class="keyword">var</span> funCall = functionCall(stream, a);
    <span class="keyword">if</span> (<span class="literal">null</span> != funCall) {
      <span class="keyword">return</span> funCall;
    }
    <span class="keyword">if</span> (stream.trypop(<span class="string">'('</span>)) {
      <span class="keyword">var</span> e = orExpr(stream, a);
      <span class="keyword">if</span> (<span class="literal">null</span> == e)
        <span class="keyword">throw</span> <span class="keyword">new</span> XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 <span class="string">'Position '</span> + stream.position() +
                                 <span class="string">': Expected expression after (.'</span>);
      <span class="keyword">if</span> (<span class="literal">null</span> == stream.trypop(<span class="string">')'</span>))
        <span class="keyword">throw</span> <span class="keyword">new</span> XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 <span class="string">'Position '</span> + stream.position() +
                                 <span class="string">': Expected ) after expression.'</span>);
      <span class="keyword">return</span> e;
    }
    <span class="keyword">return</span> <span class="literal">null</span>;
  }
  <span class="comment">/** [16] FunctionCall::= FunctionName '(' ( Argument ( ',' Argument )* )? ')'
   *  [17] Argument::= Expr
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">functionCall</span><span class="params">(stream, a)</span> {</span>
    <span class="keyword">var</span> name = stream.trypopfuncname(stream, a);
    <span class="keyword">if</span> (<span class="literal">null</span> == name) <span class="keyword">return</span> <span class="literal">null</span>;
    <span class="keyword">if</span> (<span class="literal">null</span> == stream.trypop(<span class="string">'('</span>))
      <span class="keyword">throw</span> <span class="keyword">new</span> XPathException(XPathException.INVALID_EXPRESSION_ERR,
                               <span class="string">'Position '</span> + stream.position() +
                               <span class="string">': Expected ( ) after function name.'</span>);
    <span class="keyword">var</span> params = [];
    <span class="keyword">var</span> first = <span class="literal">true</span>;
    <span class="keyword">while</span> (<span class="literal">null</span> == stream.trypop(<span class="string">')'</span>)) {
      <span class="keyword">if</span> (!first &amp;&amp; <span class="literal">null</span> == stream.trypop(<span class="string">','</span>))
        <span class="keyword">throw</span> <span class="keyword">new</span> XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 <span class="string">'Position '</span> + stream.position() +
                                 <span class="string">': Expected , between arguments of the function.'</span>);
      first = <span class="literal">false</span>;
      <span class="keyword">var</span> param = orExpr(stream, a);
      <span class="keyword">if</span> (param == <span class="literal">null</span>)
        <span class="keyword">throw</span> <span class="keyword">new</span> XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 <span class="string">'Position '</span> + stream.position() +
                                 <span class="string">': Expected expression as argument of function.'</span>);
      params.push(param);
    }
    <span class="keyword">return</span> a.node(<span class="string">'FunctionCall'</span>, name, params);
  }

  <span class="comment">/** [18] UnionExpr::= PathExpr | UnionExpr '|' PathExpr
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">unionExpr</span><span class="params">(stream, a)</span> {</span> <span class="keyword">return</span> binaryL(pathExpr, stream, a, <span class="string">'|'</span>); }
  <span class="comment">/** [19] PathExpr ::= LocationPath
   *                  | FilterExpr
   *                  | FilterExpr '/' RelativeLocationPath
   *                  | FilterExpr '//' RelativeLocationPath
   * Unlike most other nodes, this one always generates a node because
   * at this point all reverse nodesets must turn into a forward nodeset
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">pathExpr</span><span class="params">(stream, a)</span> {</span>
    <span class="comment">// We have to do FilterExpr before LocationPath because otherwise</span>
    <span class="comment">// LocationPath will eat up the name from a function call.</span>
    <span class="keyword">var</span> filter = filterExpr(stream, a);
    <span class="keyword">if</span> (<span class="literal">null</span> == filter) {
      <span class="keyword">var</span> loc = locationPath(stream, a);
      <span class="keyword">if</span> (<span class="literal">null</span> == loc) {
        <span class="keyword">throw</span> <span class="keyword">new</span> Error
        <span class="keyword">throw</span> <span class="keyword">new</span> XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 <span class="string">'Position '</span> + stream.position() +
                                 <span class="string">': The expression shouldn\'t be empty...'</span>);
      }
      <span class="keyword">return</span> a.node(<span class="string">'PathExpr'</span>, loc);
    }
    <span class="keyword">var</span> rel = relativeLocationPath(filter, stream, a, <span class="literal">false</span>);
    <span class="keyword">if</span> (filter === rel) <span class="keyword">return</span> rel;
    <span class="keyword">else</span> <span class="keyword">return</span> a.node(<span class="string">'PathExpr'</span>, rel);
  }
  <span class="comment">/** [20] FilterExpr::= PrimaryExpr | FilterExpr Predicate
   * aka. FilterExpr ::= PrimaryExpr Predicate*
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">filterExpr</span><span class="params">(stream, a)</span> {</span>
    <span class="keyword">var</span> primary = primaryExpr(stream, a);
    <span class="keyword">if</span> (primary == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;
    <span class="keyword">var</span> pred, lhs = primary;
    <span class="keyword">while</span> (<span class="literal">null</span> != (pred = predicate(lhs, stream, a))) {
      lhs = pred;
    }
    <span class="keyword">return</span> lhs;
  }

  <span class="comment">/** [21] OrExpr::= AndExpr | OrExpr 'or' AndExpr
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">orExpr</span><span class="params">(stream, a)</span> {</span>
    <span class="keyword">var</span> orig = (stream.peeked || <span class="string">''</span>) + stream.str
    <span class="keyword">var</span> r = binaryL(andExpr, stream, a, <span class="string">'or'</span>);
    <span class="keyword">var</span> now = (stream.peeked || <span class="string">''</span>) + stream.str;
    <span class="keyword">return</span> r;
  }
  <span class="comment">/** [22] AndExpr::= EqualityExpr | AndExpr 'and' EqualityExpr
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">andExpr</span><span class="params">(stream, a)</span> {</span> <span class="keyword">return</span> binaryL(equalityExpr, stream, a, <span class="string">'and'</span>); }
  <span class="comment">/** [23] EqualityExpr::= RelationalExpr | EqualityExpr '=' RelationalExpr
   *                     | EqualityExpr '!=' RelationalExpr
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">equalityExpr</span><span class="params">(stream, a)</span> {</span> <span class="keyword">return</span> binaryL(relationalExpr, stream, a, [<span class="string">'='</span>,<span class="string">'!='</span>]); }
  <span class="comment">/** [24] RelationalExpr::= AdditiveExpr | RelationalExpr '&lt;' AdditiveExpr
   *                       | RelationalExpr '>' AdditiveExpr
   *                       | RelationalExpr '&lt;=' AdditiveExpr
   *                       | RelationalExpr '>=' AdditiveExpr
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">relationalExpr</span><span class="params">(stream, a)</span> {</span> <span class="keyword">return</span> binaryL(additiveExpr, stream, a, [<span class="string">'&lt;'</span>,<span class="string">'>'</span>,<span class="string">'&lt;='</span>,<span class="string">'>='</span>]); }
  <span class="comment">/** [25] AdditiveExpr::= MultiplicativeExpr
   *                     | AdditiveExpr '+' MultiplicativeExpr
   *                     | AdditiveExpr '-' MultiplicativeExpr
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">additiveExpr</span><span class="params">(stream, a)</span> {</span> <span class="keyword">return</span> binaryL(multiplicativeExpr, stream, a, [<span class="string">'+'</span>,<span class="string">'-'</span>]); }
  <span class="comment">/** [26] MultiplicativeExpr::= UnaryExpr
   *                           | MultiplicativeExpr MultiplyOperator UnaryExpr
   *                           | MultiplicativeExpr 'div' UnaryExpr
   *                           | MultiplicativeExpr 'mod' UnaryExpr
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">multiplicativeExpr</span><span class="params">(stream, a)</span> {</span> <span class="keyword">return</span> binaryL(unaryExpr, stream, a, [<span class="string">'*'</span>,<span class="string">'div'</span>,<span class="string">'mod'</span>]); }
  <span class="comment">/** [27] UnaryExpr::= UnionExpr | '-' UnaryExpr
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">unaryExpr</span><span class="params">(stream, a)</span> {</span>
    <span class="keyword">if</span> (stream.trypop(<span class="string">'-'</span>)) {
      <span class="keyword">var</span> e = unaryExpr(stream, a);
      <span class="keyword">if</span> (<span class="literal">null</span> == e)
        <span class="keyword">throw</span> <span class="keyword">new</span> XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 <span class="string">'Position '</span> + stream.position() +
                                 <span class="string">': Expected unary expression after -'</span>);
      <span class="keyword">return</span> a.node(<span class="string">'UnaryMinus'</span>, e);
    }
    <span class="keyword">else</span> <span class="keyword">return</span> unionExpr(stream, a);
  }
  <span class="keyword">var</span> astFactory = {
    node: <span class="keyword">function</span>() {<span class="keyword">return</span> Array.prototype.slice.call(arguments);}
  };


  <span class="comment">/***************************************************************************
   *                            Optimizations (TODO)                         *
   ***************************************************************************/</span>
  <span class="comment">/**
   * Some things I've been considering:
   * 1) a//b becomes a/descendant::b if there's no predicate that uses
   *    position() or last()
   * 2) axis[pred]: when pred doesn't use position, evaluate it just once per
   *    node in the node-set rather than once per (node, position, last).
   * For more optimizations, look up Gecko's optimizer:
   * http://mxr.mozilla.org/mozilla-central/source/content/xslt/src/xpath/txXPathOptimizer.cpp
   */</span>
  <span class="comment">// TODO</span>
  <span class="function"><span class="keyword">function</span> <span class="title">optimize</span><span class="params">(ast)</span> {</span>
  }

  <span class="comment">/***************************************************************************
   *                           Evaluation: axes                              *
   ***************************************************************************/</span>

  <span class="comment">/**
   * Data types: For string, number, boolean, we just use Javascript types.
   * Node-sets have the form
   *    {nodes: [node, ...]}
   * or {nodes: [node, ...], pos: [[1], [2], ...], lasts: [[1], [2], ...]}
   *
   * Most of the time, only the node is used and the position information is
   * discarded. But if you use a predicate, we need to try every value of
   * position and last in case the predicate calls position() or last().
   */</span>

  <span class="comment">/**
   * The NodeMultiSet is a helper class to help generate
   * {nodes:[], pos:[], lasts:[]} structures. It is useful for the
   * descendant, descendant-or-self, following-sibling, and
   * preceding-sibling axes for which we can use a stack to organize things.
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">NodeMultiSet</span><span class="params">(isReverseAxis)</span> {</span>
    <span class="keyword">this</span>.nodes = [];
    <span class="keyword">this</span>.pos = [];
    <span class="keyword">this</span>.lasts = [];
    <span class="keyword">this</span>.nextPos = [];
    <span class="keyword">this</span>.seriesIndexes = [];  <span class="comment">// index within nodes that each series begins.</span>
    <span class="keyword">this</span>.isReverseAxis = isReverseAxis;
    <span class="keyword">this</span>._pushToNodes = isReverseAxis ? Array.prototype.unshift : Array.prototype.push;
  }
  NodeMultiSet.prototype = {
    pushSeries: <span class="function"><span class="keyword">function</span> <span class="title">pushSeries</span><span class="params">()</span> {</span>
      <span class="keyword">this</span>.nextPos.push(<span class="number">1</span>);
      <span class="keyword">this</span>.seriesIndexes.push(<span class="keyword">this</span>.nodes.length);
    },
    popSeries: <span class="function"><span class="keyword">function</span> <span class="title">popSeries</span><span class="params">()</span> {</span>
      console.assert(<span class="number">0</span> &lt; <span class="keyword">this</span>.nextPos.length, <span class="keyword">this</span>.nextPos);
      <span class="keyword">var</span> last = <span class="keyword">this</span>.nextPos.pop() - <span class="number">1</span>,
          indexInPos = <span class="keyword">this</span>.nextPos.length,
          seriesBeginIndex = <span class="keyword">this</span>.seriesIndexes.pop(),
          seriesEndIndex = <span class="keyword">this</span>.nodes.length;
      <span class="keyword">for</span> (<span class="keyword">var</span> i = seriesBeginIndex; i &lt; seriesEndIndex; ++i) {
        console.assert(indexInPos &lt; <span class="keyword">this</span>.lasts[i].length);
        console.assert(<span class="literal">undefined</span> === <span class="keyword">this</span>.lasts[i][indexInPos]);
        <span class="keyword">this</span>.lasts[i][indexInPos] = last;
      }
    },
    finalize: <span class="keyword">function</span>() {
      <span class="keyword">if</span> (<span class="literal">null</span> == <span class="keyword">this</span>.nextPos) <span class="keyword">return</span> <span class="keyword">this</span>;
      console.assert(<span class="number">0</span> === <span class="keyword">this</span>.nextPos.length);
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.lasts.length; ++i) {
        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>.lasts[i].length; ++j) {
          console.assert(<span class="literal">null</span> != <span class="keyword">this</span>.lasts[i][j], i + <span class="string">','</span> + j + <span class="string">':'</span> + JSON.stringify(<span class="keyword">this</span>.lasts));
        }
      }
      <span class="keyword">this</span>.pushSeries = <span class="keyword">this</span>.popSeries = <span class="keyword">this</span>.addNode = <span class="keyword">function</span>() {
        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Already finalized.'</span>);
      };
      <span class="keyword">return</span> <span class="keyword">this</span>;
    },
    addNode: <span class="function"><span class="keyword">function</span> <span class="title">addNode</span><span class="params">(node)</span> {</span>
      console.assert(node);
      <span class="keyword">this</span>._pushToNodes.call(<span class="keyword">this</span>.nodes, node)
      <span class="keyword">this</span>._pushToNodes.call(<span class="keyword">this</span>.pos, <span class="keyword">this</span>.nextPos.slice());
      <span class="keyword">this</span>._pushToNodes.call(<span class="keyword">this</span>.lasts, <span class="keyword">new</span> Array(<span class="keyword">this</span>.nextPos.length));
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.nextPos.length; ++i) <span class="keyword">this</span>.nextPos[i]++;
    },
    simplify: <span class="keyword">function</span>() {
      <span class="keyword">this</span>.finalize();
      <span class="keyword">return</span> {nodes:<span class="keyword">this</span>.nodes, pos:<span class="keyword">this</span>.pos, lasts:<span class="keyword">this</span>.lasts};
    }
  };
  <span class="function"><span class="keyword">function</span> <span class="title">eachContext</span><span class="params">(nodeMultiSet)</span> {</span>
    <span class="keyword">var</span> r = [];
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nodeMultiSet.nodes.length; i++) {
      <span class="keyword">var</span> node = nodeMultiSet.nodes[i];
      <span class="keyword">if</span> (!nodeMultiSet.pos) {
        r.push({nodes:[node], pos: [[i + <span class="number">1</span>]], lasts: [[nodeMultiSet.nodes.length]]});
      } <span class="keyword">else</span> {
        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; nodeMultiSet.pos[i].length; ++j) {
          r.push({nodes:[node], pos: [[nodeMultiSet.pos[i][j]]], lasts: [[nodeMultiSet.lasts[i][j]]]});
        }
      }
    }
    <span class="keyword">return</span> r;
  }
  <span class="comment">/** Matcher used in the axes.
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">NodeMatcher</span><span class="params">(nodeTypeNum, nodeName, shouldLowerCase)</span> {</span>
    <span class="keyword">this</span>.nodeTypeNum = nodeTypeNum;
    <span class="keyword">this</span>.nodeName = nodeName;
    <span class="keyword">this</span>.shouldLowerCase = shouldLowerCase;
    <span class="keyword">this</span>.nodeNameTest =
      <span class="literal">null</span> == nodeName ? <span class="keyword">this</span>._alwaysTrue :
      shouldLowerCase ? <span class="keyword">this</span>._nodeNameLowerCaseEquals :
      <span class="keyword">this</span>._nodeNameEquals;
  }
  NodeMatcher.prototype = {
    matches: <span class="function"><span class="keyword">function</span> <span class="title">matches</span><span class="params">(node)</span> {</span>
      <span class="keyword">return</span> (<span class="number">0</span> === <span class="keyword">this</span>.nodeTypeNum || node.nodeType === <span class="keyword">this</span>.nodeTypeNum) &amp;&amp;
          <span class="keyword">this</span>.nodeNameTest(node.nodeName);
    },
    _alwaysTrue: <span class="keyword">function</span>(name) {<span class="keyword">return</span> <span class="literal">true</span>;},
    _nodeNameEquals: <span class="function"><span class="keyword">function</span> <span class="title">_nodeNameEquals</span><span class="params">(name)</span> {</span>
      <span class="keyword">return</span> <span class="keyword">this</span>.nodeName === name;
    },
    _nodeNameLowerCaseEquals: <span class="function"><span class="keyword">function</span> <span class="title">_nodeNameLowerCaseEquals</span><span class="params">(name)</span> {</span>
      <span class="keyword">return</span> <span class="keyword">this</span>.nodeName === name.toLowerCase();
    }
  };

  <span class="function"><span class="keyword">function</span> <span class="title">followingSiblingHelper</span><span class="params">(nodeList  <span class="comment">/*destructive!*/</span>, nodeTypeNum, nodeName, shouldLowerCase, shift, peek, followingNode, andSelf, isReverseAxis)</span> {</span>
    <span class="keyword">var</span> matcher = <span class="keyword">new</span> NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);
    <span class="keyword">var</span> nodeMultiSet = <span class="keyword">new</span> NodeMultiSet(isReverseAxis);
    <span class="keyword">while</span> (<span class="number">0</span> &lt; nodeList.length) {  <span class="comment">// can be if for following, preceding</span>
      <span class="keyword">var</span> node = shift.call(nodeList);
      console.assert(node != <span class="literal">null</span>);
      node = followingNode(node);
      nodeMultiSet.pushSeries();
      <span class="keyword">var</span> numPushed = <span class="number">1</span>;
      <span class="keyword">while</span> (<span class="literal">null</span> != node) {
        <span class="keyword">if</span> (! andSelf &amp;&amp; matcher.matches(node))
          nodeMultiSet.addNode(node);
        <span class="keyword">if</span> (node === peek.call(nodeList)) {
          shift.call(nodeList);
          nodeMultiSet.pushSeries();
          numPushed++;
        }
        <span class="keyword">if</span> (andSelf &amp;&amp; matcher.matches(node))
          nodeMultiSet.addNode(node);
        node = followingNode(node);
      }
      <span class="keyword">while</span> (<span class="number">0</span> &lt; numPushed--)
        nodeMultiSet.popSeries();
    }
    <span class="keyword">return</span> nodeMultiSet;
  }

  <span class="comment">/** Returns the next non-descendant node in document order.
   * This is the first node in following::node(), if node is the context.
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">followingNonDescendantNode</span><span class="params">(node)</span> {</span>
    <span class="keyword">if</span> (node.ownerElement) {
      <span class="keyword">if</span> (node.ownerElement.firstChild)
        <span class="keyword">return</span> node.ownerElement.firstChild;
      node = node.ownerElement;
    }
    <span class="keyword">do</span> {
      <span class="keyword">if</span> (node.nextSibling) <span class="keyword">return</span> node.nextSibling;
    } <span class="keyword">while</span> (node = node.parentNode);
    <span class="keyword">return</span> <span class="literal">null</span>;
  }

  <span class="comment">/** Returns the next node in a document-order depth-first search.
   * See the definition of document order[1]:
   *   1) element
   *   2) namespace nodes
   *   3) attributes
   *   4) children
   *   [1]: http://www.w3.org/TR/xpath/#dt-document-order
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">followingNode</span><span class="params">(node)</span> {</span>
    <span class="keyword">if</span> (node.ownerElement)  <span class="comment">// attributes: following node of element.</span>
      node = node.ownerElement;
    <span class="keyword">if</span> (<span class="literal">null</span> != node.firstChild)
      <span class="keyword">return</span> node.firstChild;
    <span class="keyword">do</span> {
      <span class="keyword">if</span> (<span class="literal">null</span> != node.nextSibling) {
        <span class="keyword">return</span> node.nextSibling;
      }
      node = node.parentNode;
    } <span class="keyword">while</span> (node);
    <span class="keyword">return</span> <span class="literal">null</span>;
  }
  <span class="comment">/** Returns the previous node in document order (excluding attributes
   * and namespace nodes).
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">precedingNode</span><span class="params">(node)</span> {</span>
    <span class="keyword">if</span> (node.ownerElement)
      <span class="keyword">return</span> node.ownerElement;
    <span class="keyword">if</span> (<span class="literal">null</span> != node.previousSibling) {
      node = node.previousSibling;
      <span class="keyword">while</span> (<span class="literal">null</span> != node.lastChild) {
        node = node.lastChild;
      }
      <span class="keyword">return</span> node;
    }
    <span class="keyword">if</span> (<span class="literal">null</span> != node.parentNode) {
      <span class="keyword">return</span> node.parentNode;
    }
    <span class="keyword">return</span> <span class="literal">null</span>;
  }
  <span class="comment">/** This axis is inefficient if there are many nodes in the nodeList.
   * But I think it's a pretty useless axis so it's ok. */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">followingHelper</span><span class="params">(nodeList  <span class="comment">/*destructive!*/</span>, nodeTypeNum, nodeName, shouldLowerCase)</span> {</span>
    <span class="keyword">var</span> matcher = <span class="keyword">new</span> NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);
    <span class="keyword">var</span> nodeMultiSet = <span class="keyword">new</span> NodeMultiSet(<span class="literal">false</span>);
    <span class="keyword">var</span> cursor = nodeList[<span class="number">0</span>];
    <span class="keyword">var</span> unorderedFollowingStarts = [];
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nodeList.length; i++) {
      <span class="keyword">var</span> node = nodeList[i];
      <span class="keyword">var</span> start = followingNonDescendantNode(node);
      <span class="keyword">if</span> (start)
        unorderedFollowingStarts.push(start);
    }
    <span class="keyword">if</span> (<span class="number">0</span> === unorderedFollowingStarts.length)
      <span class="keyword">return</span> {nodes:[]};
    <span class="keyword">var</span> pos = [], nextPos = [];
    <span class="keyword">var</span> started = <span class="number">0</span>;
    <span class="keyword">while</span> (cursor = followingNode(cursor)) {
      <span class="keyword">for</span> (<span class="keyword">var</span> i = unorderedFollowingStarts.length - <span class="number">1</span>; i >= <span class="number">0</span>; i--){
        <span class="keyword">if</span> (cursor === unorderedFollowingStarts[i]) {
          nodeMultiSet.pushSeries();
          unorderedFollowingStarts.splice(i,i+<span class="number">1</span>);
          started++;
        }
      }
      <span class="keyword">if</span> (started &amp;&amp; matcher.matches(cursor)) {
        nodeMultiSet.addNode(cursor);
      }
    }
    console.assert(<span class="number">0</span> === unorderedFollowingStarts.length);
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; started; i++)
      nodeMultiSet.popSeries();
    <span class="keyword">return</span> nodeMultiSet.finalize();
  }
  <span class="function"><span class="keyword">function</span> <span class="title">precedingHelper</span><span class="params">(nodeList  <span class="comment">/*destructive!*/</span>, nodeTypeNum, nodeName, shouldLowerCase)</span> {</span>
    <span class="keyword">var</span> matcher = <span class="keyword">new</span> NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);
    <span class="keyword">var</span> cursor = nodeList.pop();
    <span class="keyword">if</span> (<span class="literal">null</span> == cursor) <span class="keyword">return</span> {nodes:{}};
    <span class="keyword">var</span> r = {nodes:[], pos:[], lasts:[]};
    <span class="keyword">var</span> nextParents = [cursor.parentNode || cursor.ownerElement], nextPos = [<span class="number">1</span>];
    <span class="keyword">while</span> (cursor = precedingNode(cursor)) {
      <span class="keyword">if</span> (cursor === nodeList[nodeList.length - <span class="number">1</span>]) {
        nextParents.push(nodeList.pop());
        nextPos.push(<span class="number">1</span>);
      }
      <span class="keyword">var</span> matches = matcher.matches(cursor);
      <span class="keyword">var</span> pos, someoneUsed = <span class="literal">false</span>;
      <span class="keyword">if</span> (matches)
        pos = nextPos.slice();

      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nextParents.length; ++i) {
        <span class="keyword">if</span> (cursor === nextParents[i]) {
          nextParents[i] = cursor.parentNode || cursor.ownerElement;
          <span class="keyword">if</span> (matches) {
            pos[i] = <span class="literal">null</span>;
          }
        } <span class="keyword">else</span> {
          <span class="keyword">if</span> (matches) {
            pos[i] = nextPos[i]++;
            someoneUsed = <span class="literal">true</span>;
          }
        }
      }
      <span class="keyword">if</span> (someoneUsed) {
        r.nodes.unshift(cursor);
        r.pos.unshift(pos);
      }
    }
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; r.pos.length; ++i) {
      <span class="keyword">var</span> lasts = [];
      r.lasts.push(lasts);
      <span class="keyword">for</span> (<span class="keyword">var</span> j = r.pos[i].length - <span class="number">1</span>; j >= <span class="number">0</span>; j--) {
        <span class="keyword">if</span> (<span class="literal">null</span> == r.pos[i][j]) {
          r.pos[i].splice(j, j+<span class="number">1</span>);
        } <span class="keyword">else</span> {
          lasts.unshift(nextPos[j] - <span class="number">1</span>);
        }
      }
    }
    <span class="keyword">return</span> r;
  }

  <span class="comment">/** node-set, axis -> node-set */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">descendantDfs</span><span class="params">(nodeMultiSet, node, remaining, matcher, andSelf, attrIndices, attrNodes)</span> {</span>
    <span class="keyword">while</span> (<span class="number">0</span> &lt; remaining.length &amp;&amp; <span class="literal">null</span> != remaining[<span class="number">0</span>].ownerElement) {
      <span class="keyword">var</span> attr = remaining.shift();
      <span class="keyword">if</span> (andSelf &amp;&amp; matcher.matches(attr)) {
        attrNodes.push(attr);
        attrIndices.push(nodeMultiSet.nodes.length);
      }
    }
    <span class="keyword">if</span> (<span class="literal">null</span> != node &amp;&amp; !andSelf) {
      <span class="keyword">if</span> (matcher.matches(node))
        nodeMultiSet.addNode(node);
    }
    <span class="keyword">var</span> pushed = <span class="literal">false</span>;
    <span class="keyword">if</span> (<span class="literal">null</span> == node) {
      <span class="keyword">if</span> (<span class="number">0</span> === remaining.length) <span class="keyword">return</span>;
      node = remaining.shift();
      nodeMultiSet.pushSeries();
      pushed = <span class="literal">true</span>;
    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> &lt; remaining.length &amp;&amp; node === remaining[<span class="number">0</span>]) {
      nodeMultiSet.pushSeries();
      pushed = <span class="literal">true</span>;
      remaining.shift();
    }
    <span class="keyword">if</span> (andSelf) {
      <span class="keyword">if</span> (matcher.matches(node))
        nodeMultiSet.addNode(node);
    }
    <span class="comment">// TODO: use optimization. Also try element.getElementsByTagName</span>
    <span class="comment">// var nodeList = 1 === nodeTypeNum &amp;&amp; null != node.children ? node.children : node.childNodes;</span>
    <span class="keyword">var</span> nodeList = node.childNodes;
    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; nodeList.length; ++j) {
      <span class="keyword">var</span> child = nodeList[j];
      descendantDfs(nodeMultiSet, child, remaining, matcher, andSelf, attrIndices, attrNodes);
    }
    <span class="keyword">if</span> (pushed) {
      nodeMultiSet.popSeries();
    }
  }
  <span class="function"><span class="keyword">function</span> <span class="title">descenantHelper</span><span class="params">(nodeList  <span class="comment">/*destructive!*/</span>, nodeTypeNum, nodeName, shouldLowerCase, andSelf)</span> {</span>
    <span class="keyword">var</span> matcher = <span class="keyword">new</span> NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);
    <span class="keyword">var</span> nodeMultiSet = <span class="keyword">new</span> NodeMultiSet(<span class="literal">false</span>);
    <span class="keyword">var</span> attrIndices = [], attrNodes = [];
    <span class="keyword">while</span> (<span class="number">0</span> &lt; nodeList.length) {
      <span class="comment">// var node = nodeList.shift();</span>
      descendantDfs(nodeMultiSet, <span class="literal">null</span>, nodeList, matcher, andSelf, attrIndices, attrNodes);
    }
    nodeMultiSet.finalize();
    <span class="keyword">for</span> (<span class="keyword">var</span> i = attrNodes.length-<span class="number">1</span>; i >= <span class="number">0</span>; --i) {
      nodeMultiSet.nodes.splice(attrIndices[i], attrIndices[i], attrNodes[i]);
      nodeMultiSet.pos.splice(attrIndices[i], attrIndices[i], [<span class="number">1</span>]);
      nodeMultiSet.lasts.splice(attrIndices[i], attrIndices[i], [<span class="number">1</span>]);
    }
    <span class="keyword">return</span> nodeMultiSet;
  }
  <span class="comment">/**
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">ancestorHelper</span><span class="params">(nodeList  <span class="comment">/*destructive!*/</span>, nodeTypeNum, nodeName, shouldLowerCase, andSelf)</span> {</span>
    <span class="keyword">var</span> matcher = <span class="keyword">new</span> NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);
    <span class="keyword">var</span> ancestors = []; <span class="comment">// array of non-empty arrays of matching ancestors</span>
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nodeList.length; ++i) {
      <span class="keyword">var</span> node = nodeList[i];
      <span class="keyword">var</span> isFirst = <span class="literal">true</span>;
      <span class="keyword">var</span> a = [];
      <span class="keyword">while</span> (<span class="literal">null</span> != node) {
        <span class="keyword">if</span> (!isFirst || andSelf) {
          <span class="keyword">if</span> (matcher.matches(node))
            a.push(node);
        }
        isFirst = <span class="literal">false</span>;
        node = node.parentNode || node.ownerElement;
      }
      <span class="keyword">if</span> (<span class="number">0</span> &lt; a.length)
        ancestors.push(a);
    }
    <span class="keyword">var</span> lasts = [];
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ancestors.length; ++i) lasts.push(ancestors[i].length);
    <span class="keyword">var</span> nodeMultiSet = <span class="keyword">new</span> NodeMultiSet(<span class="literal">true</span>);
    <span class="keyword">var</span> newCtx = {nodes:[], pos:[], lasts:[]};
    <span class="keyword">while</span> (<span class="number">0</span> &lt; ancestors.length) {
      <span class="keyword">var</span> pos = [ancestors[<span class="number">0</span>].length];
      <span class="keyword">var</span> last = [lasts[<span class="number">0</span>]];
      <span class="keyword">var</span> node = ancestors[<span class="number">0</span>].pop();
      <span class="keyword">for</span> (<span class="keyword">var</span> i = ancestors.length - <span class="number">1</span>; i > <span class="number">0</span>; --i) {
        <span class="keyword">if</span> (node === ancestors[i][ancestors[i].length - <span class="number">1</span>]) {
          pos.push(ancestors[i].length);
          last.push(lasts[i]);
          ancestors[i].pop();
          <span class="keyword">if</span> (<span class="number">0</span> === ancestors[i].length) {
            ancestors.splice(i, i+<span class="number">1</span>);
            lasts.splice(i, i+<span class="number">1</span>);
          }
        }
      }
      <span class="keyword">if</span> (<span class="number">0</span> === ancestors[<span class="number">0</span>].length) {
        ancestors.shift();
        lasts.shift();
      }
      newCtx.nodes.push(node);
      newCtx.pos.push(pos);
      newCtx.lasts.push(last);
    }
    <span class="keyword">return</span> newCtx;
  }
  <span class="comment">/** Helper function for sortDocumentOrder. Returns a list of indices, from the
   * node to the root, of positions within parent.
   * For convenience, the node is the first element of the array.
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">addressVector</span><span class="params">(node)</span> {</span>
    <span class="keyword">var</span> r = [node];
    <span class="keyword">if</span> (<span class="literal">null</span> != node.ownerElement) {
      node = node.ownerElement;
      r.push(-<span class="number">1</span>);
    }
    <span class="keyword">while</span> (<span class="literal">null</span> != node) {
      <span class="keyword">var</span> i = <span class="number">0</span>;
      <span class="keyword">while</span> (<span class="literal">null</span> != node.previousSibling) {
        node = node.previousSibling;
        i++;
      }
      r.push(i);
      node = node.parentNode
    }
    <span class="keyword">return</span> r;
  }
  <span class="function"><span class="keyword">function</span> <span class="title">addressComparator</span><span class="params">(a, b)</span> {</span>
    <span class="keyword">var</span> minlen = Math.min(a.length - <span class="number">1</span>, b.length - <span class="number">1</span>),  <span class="comment">// not including [0]=node</span>
        alen = a.length,
        blen = b.length;
    <span class="keyword">if</span> (a[<span class="number">0</span>] === b[<span class="number">0</span>]) <span class="keyword">return</span> <span class="number">0</span>;
    <span class="keyword">var</span> c;
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; minlen; ++i) {
      c = a[alen - i - <span class="number">1</span>] - b[blen - i - <span class="number">1</span>];
      <span class="keyword">if</span> (<span class="number">0</span> !== c)
        <span class="keyword">break</span>;
    }
    <span class="keyword">if</span> (<span class="literal">null</span> == c || <span class="number">0</span> === c) {
      <span class="comment">// All equal until one of the nodes. The longer one is the descendant.</span>
      c = alen - blen;
    }
    <span class="keyword">if</span> (<span class="number">0</span> === c)
      c = a.nodeName - b.nodeName;
    <span class="keyword">if</span> (<span class="number">0</span> === c)
      c = <span class="number">1</span>;
    <span class="keyword">return</span> c;
  }
  <span class="keyword">var</span> sortUniqDocumentOrder = xpath.sortUniqDocumentOrder = <span class="keyword">function</span>(nodes) {
    <span class="keyword">var</span> a = [];
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nodes.length; i++) {
      <span class="keyword">var</span> node = nodes[i];
      <span class="keyword">var</span> v = addressVector(node);
      a.push(v);
    }
    a.sort(addressComparator);
    <span class="keyword">var</span> b = [];
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a.length; i++) {
      <span class="keyword">if</span> (<span class="number">0</span> &lt; i &amp;&amp; a[i][<span class="number">0</span>] === a[i - <span class="number">1</span>][<span class="number">0</span>])
        <span class="keyword">continue</span>;
      b.push(a[i][<span class="number">0</span>]);
    }
    <span class="keyword">return</span> b;
  }
  <span class="comment">/** Sort node multiset. Does not do any de-duping. */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">sortNodeMultiSet</span><span class="params">(nodeMultiSet)</span> {</span>
    <span class="keyword">var</span> a = [];
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nodeMultiSet.nodes.length; i++) {
      <span class="keyword">var</span> v = addressVector(nodeMultiSet.nodes[i]);
      a.push({v:v, n:nodeMultiSet.nodes[i],
              p:nodeMultiSet.pos[i], l:nodeMultiSet.lasts[i]});
    }
    a.sort(compare);
    <span class="keyword">var</span> r = {nodes:[], pos:[], lasts:[]};
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a.length; ++i) {
      r.nodes.push(a[i].n);
      r.pos.push(a[i].p);
      r.lasts.push(a[i].l);
    }
    <span class="function"><span class="keyword">function</span> <span class="title">compare</span><span class="params">(x, y)</span> {</span>
      <span class="keyword">return</span> addressComparator(x.v, y.v);
    }
    <span class="keyword">return</span> r;
  }
  <span class="comment">/** Returns an array containing all the ancestors down to a node.
   * The array starts with document.
   */</span>
  <span class="function"><span class="keyword">function</span> <span class="title">nodeAndAncestors</span><span class="params">(node)</span> {</span>
    <span class="keyword">var</span> ancestors = [node];
    <span class="keyword">var</span> p = node;
    <span class="keyword">while</span> (p = p.parentNode || p.ownerElement) {
      ancestors.unshift(p);
    }
    <span class="keyword">return</span> ancestors;
  }
  <span class="function"><span class="keyword">function</span> <span class="title">compareSiblings</span><span class="params">(a, b)</span> {</span>
    <span class="keyword">if</span> (a === b) <span class="keyword">return</span> <span class="number">0</span>;
    <span class="keyword">var</span> c = a;
    <span class="keyword">while</span> (c = c.previousSibling) {
      <span class="keyword">if</span> (c === b)
        <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// b &lt; a</span>
    }
    c = b;
    <span class="keyword">while</span> (c = c.previousSibling) {
      <span class="keyword">if</span> (c === a)
        <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// a &lt; b</span>
    }
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'a and b are not siblings: '</span> + xpath.stringifyObject(a) + <span class="string">' vs '</span> + xpath.stringifyObject(b));
  }
  <span class="comment">/** The merge in merge-sort.*/</span>
  <span class="function"><span class="keyword">function</span> <span class="title">mergeNodeLists</span><span class="params">(x, y)</span> {</span>
    <span class="keyword">var</span> a, b, aanc, banc, r = [];
    <span class="keyword">if</span> (<span class="string">'object'</span> !== <span class="keyword">typeof</span> x)
      <span class="keyword">throw</span> <span class="keyword">new</span> XPathException(XPathException.INVALID_EXPRESSION_ERR,
                               <span class="string">'Invalid LHS for | operator '</span> +
                               <span class="string">'(expected node-set): '</span> + x);
    <span class="keyword">if</span> (<span class="string">'object'</span> !== <span class="keyword">typeof</span> y)
      <span class="keyword">throw</span> <span class="keyword">new</span> XPathException(XPathException.INVALID_EXPRESSION_ERR,
                               <span class="string">'Invalid LHS for | operator '</span> +
                               <span class="string">'(expected node-set): '</span> + y);
    <span class="keyword">while</span> (<span class="literal">true</span>) {
      <span class="keyword">if</span> (<span class="literal">null</span> == a) {
        a = x.shift();
        <span class="keyword">if</span> (<span class="literal">null</span> != a)
          aanc = addressVector(a);
      }
      <span class="keyword">if</span> (<span class="literal">null</span> == b) {
        b = y.shift();
        <span class="keyword">if</span> (<span class="literal">null</span> != b)
          banc = addressVector(b);
      }
      <span class="keyword">if</span> (<span class="literal">null</span> == a || <span class="literal">null</span> == b) <span class="keyword">break</span>;
      <span class="keyword">var</span> c = addressComparator(aanc, banc);
      <span class="keyword">if</span> (c &lt; <span class="number">0</span>) {
        r.push(a);
        a = <span class="literal">null</span>;
        aanc = <span class="literal">null</span>;
      } <span class="keyword">else</span> <span class="keyword">if</span> (c > <span class="number">0</span>) {
        r.push(b);
        b = <span class="literal">null</span>;
        banc = <span class="literal">null</span>;
      } <span class="keyword">else</span> <span class="keyword">if</span> (a.nodeName &lt; b.nodeName) {  <span class="comment">// attributes</span>
        r.push(a);
        a = <span class="literal">null</span>;
        aanc = <span class="literal">null</span>;
      } <span class="keyword">else</span> <span class="keyword">if</span> (a.nodeName > b.nodeName) {  <span class="comment">// attributes</span>
        r.push(b);
        b = <span class="literal">null</span>;
        banc = <span class="literal">null</span>;
      } <span class="keyword">else</span> <span class="keyword">if</span> (a !== b) {
        <span class="comment">// choose b arbitrarily</span>
        r.push(b);
        b = <span class="literal">null</span>;
        banc = <span class="literal">null</span>;
      } <span class="keyword">else</span> {
        console.assert(a === b, c);
        <span class="comment">// just skip b without pushing it.</span>
        b = <span class="literal">null</span>;
        banc = <span class="literal">null</span>;
      }
    }
    <span class="keyword">while</span> (a) {
      r.push(a);
      a = x.shift();
    }
    <span class="keyword">while</span> (b) {
      r.push(b);
      b = y.shift();
    }
    <span class="keyword">return</span> r;
  }
  <span class="function"><span class="keyword">function</span> <span class="title">comparisonHelper</span><span class="params">(test, x, y, isNumericComparison)</span> {</span>
    <span class="keyword">var</span> coersion;
    <span class="keyword">if</span> (isNumericComparison)
      coersion = fn.number;
    <span class="keyword">else</span> coersion =
      <span class="string">'boolean'</span> === <span class="keyword">typeof</span> x || <span class="string">'boolean'</span> === <span class="keyword">typeof</span> y ? fn[<span class="string">'boolean'</span>] :
      <span class="string">'number'</span> === <span class="keyword">typeof</span> x || <span class="string">'number'</span> === <span class="keyword">typeof</span> y ? fn.number :
      fn.string;
    <span class="keyword">if</span> (<span class="string">'object'</span> === <span class="keyword">typeof</span> x &amp;&amp; <span class="string">'object'</span> === <span class="keyword">typeof</span> y) {
      <span class="keyword">var</span> aMap = {};
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; x.nodes.length; ++i) {
        <span class="keyword">var</span> xi = coersion({nodes:[x.nodes[i]]});
        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; y.nodes.length; ++j) {
          <span class="keyword">var</span> yj = coersion({nodes:[y.nodes[j]]});
          <span class="keyword">if</span> (test(xi, yj)) <span class="keyword">return</span> <span class="literal">true</span>;
        }
      }
      <span class="keyword">return</span> <span class="literal">false</span>;
    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'object'</span> === <span class="keyword">typeof</span> x &amp;&amp; x.nodes &amp;&amp; x.nodes.length) {
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; x.nodes.length; ++i) {
        <span class="keyword">var</span> xi = coersion({nodes:[x.nodes[i]]}), yc = coersion(y);
        <span class="keyword">if</span> (test(xi, yc))
          <span class="keyword">return</span> <span class="literal">true</span>;
      }
      <span class="keyword">return</span> <span class="literal">false</span>;
    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'object'</span> === <span class="keyword">typeof</span> y &amp;&amp; x.nodes &amp;&amp; x.nodes.length) {
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; x.nodes.length; ++i) {
        <span class="keyword">var</span> yi = coersion({nodes:[y.nodes[i]]}), xc = coersion(x);
        <span class="keyword">if</span> (test(xc, yi))
          <span class="keyword">return</span> <span class="literal">true</span>;
      }
      <span class="keyword">return</span> <span class="literal">false</span>;
    } <span class="keyword">else</span> {
      <span class="keyword">var</span> xc = coersion(x), yc = coersion(y);
      <span class="keyword">return</span> test(xc, yc);
    }
  }
  <span class="keyword">var</span> axes = xpath.axes = {
    <span class="string">'ancestor'</span>:
      <span class="function"><span class="keyword">function</span> <span class="title">ancestor</span><span class="params">(nodeList  <span class="comment">/*destructive!*/</span>, nodeTypeNum, nodeName, shouldLowerCase)</span> {</span>
        <span class="keyword">return</span> ancestorHelper(
          nodeList  <span class="comment">/*destructive!*/</span>, nodeTypeNum, nodeName, shouldLowerCase, <span class="literal">false</span>);
      },
    <span class="string">'ancestor-or-self'</span>:
      <span class="function"><span class="keyword">function</span> <span class="title">ancestorOrSelf</span><span class="params">(nodeList  <span class="comment">/*destructive!*/</span>, nodeTypeNum, nodeName, shouldLowerCase)</span> {</span>
        <span class="keyword">return</span> ancestorHelper(
          nodeList  <span class="comment">/*destructive!*/</span>, nodeTypeNum, nodeName, shouldLowerCase, <span class="literal">true</span>);
      },
    <span class="string">'attribute'</span>:
      <span class="function"><span class="keyword">function</span> <span class="title">attribute</span><span class="params">(nodeList  <span class="comment">/*destructive!*/</span>, nodeTypeNum, nodeName, shouldLowerCase)</span> {</span>
        <span class="comment">// TODO: figure out whether positions should be undefined here.</span>
        <span class="keyword">var</span> matcher = <span class="keyword">new</span> NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);
        <span class="keyword">var</span> nodeMultiSet = <span class="keyword">new</span> NodeMultiSet(<span class="literal">false</span>);
        <span class="keyword">if</span> (<span class="literal">null</span> != nodeName) {
          <span class="comment">// TODO: with namespace</span>
          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nodeList.length; ++i) {
            <span class="keyword">var</span> node = nodeList[i];
            <span class="keyword">if</span> (<span class="literal">null</span> == node.getAttributeNode)
              <span class="keyword">continue</span>;  <span class="comment">// only Element has .getAttributeNode</span>
            <span class="keyword">var</span> attr = node.getAttributeNode(nodeName);
            <span class="keyword">if</span> (<span class="literal">null</span> != attr &amp;&amp; matcher.matches(attr)) {
              nodeMultiSet.pushSeries();
              nodeMultiSet.addNode(attr);
              nodeMultiSet.popSeries();
            }
          }
        } <span class="keyword">else</span> {
          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nodeList.length; ++i) {
            <span class="keyword">var</span> node = nodeList[i];
            <span class="keyword">if</span> (<span class="literal">null</span> != node.attributes) {
              nodeMultiSet.pushSeries();
              <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; node.attributes.length; j++) {  <span class="comment">// all nodes have .attributes</span>
                <span class="keyword">var</span> attr = node.attributes[j];
                <span class="keyword">if</span> (matcher.matches(attr))  <span class="comment">// TODO: I think this check is unnecessary</span>
                  nodeMultiSet.addNode(attr);
              }
              nodeMultiSet.popSeries();
            }
          }
        }
        <span class="keyword">return</span> nodeMultiSet.finalize();
      },
    <span class="string">'child'</span>:
      <span class="function"><span class="keyword">function</span> <span class="title">child</span><span class="params">(nodeList  <span class="comment">/*destructive!*/</span>, nodeTypeNum, nodeName, shouldLowerCase)</span> {</span>
        <span class="keyword">var</span> matcher = <span class="keyword">new</span> NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);
        <span class="keyword">var</span> nodeMultiSet = <span class="keyword">new</span> NodeMultiSet(<span class="literal">false</span>);
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nodeList.length; ++i) {
          <span class="keyword">var</span> n = nodeList[i];
          <span class="keyword">if</span> (n.ownerElement)  <span class="comment">// skip attribute nodes' text child.</span>
            <span class="keyword">continue</span>;
          <span class="keyword">if</span> (n.childNodes) {
            nodeMultiSet.pushSeries();
            <span class="keyword">var</span> childList = <span class="number">1</span> === nodeTypeNum &amp;&amp; <span class="literal">null</span> != n.children ?
                n.children : n.childNodes;
            <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; childList.length; ++j) {
              <span class="keyword">var</span> child = childList[j];
              <span class="keyword">if</span> (matcher.matches(child)) {
                nodeMultiSet.addNode(child);
              }
              <span class="comment">// don't have to do de-duping because children have parent,</span>
              <span class="comment">// which are current context.</span>
            }
            nodeMultiSet.popSeries();
          }
        }
        nodeMultiSet.finalize();
        r = sortNodeMultiSet(nodeMultiSet);
        <span class="keyword">return</span> r;
      },
    <span class="string">'descendant'</span>:
      <span class="function"><span class="keyword">function</span> <span class="title">descenant</span><span class="params">(nodeList  <span class="comment">/*destructive!*/</span>, nodeTypeNum, nodeName, shouldLowerCase)</span> {</span>
        <span class="keyword">return</span> descenantHelper(
          nodeList  <span class="comment">/*destructive!*/</span>, nodeTypeNum, nodeName, shouldLowerCase, <span class="literal">false</span>);
      },
    <span class="string">'descendant-or-self'</span>:
      <span class="function"><span class="keyword">function</span> <span class="title">descenantOrSelf</span><span class="params">(nodeList  <span class="comment">/*destructive!*/</span>, nodeTypeNum, nodeName, shouldLowerCase)</span> {</span>
        <span class="keyword">return</span> descenantHelper(
          nodeList  <span class="comment">/*destructive!*/</span>, nodeTypeNum, nodeName, shouldLowerCase, <span class="literal">true</span>);
      },
    <span class="string">'following'</span>:
      <span class="function"><span class="keyword">function</span> <span class="title">following</span><span class="params">(nodeList  <span class="comment">/*destructive!*/</span>, nodeTypeNum, nodeName, shouldLowerCase)</span> {</span>
        <span class="keyword">return</span> followingHelper(nodeList  <span class="comment">/*destructive!*/</span>, nodeTypeNum, nodeName, shouldLowerCase);
      },
    <span class="string">'following-sibling'</span>:
      <span class="function"><span class="keyword">function</span> <span class="title">followingSibling</span><span class="params">(nodeList  <span class="comment">/*destructive!*/</span>, nodeTypeNum, nodeName, shouldLowerCase)</span> {</span>
        <span class="keyword">return</span> followingSiblingHelper(
          nodeList  <span class="comment">/*destructive!*/</span>, nodeTypeNum, nodeName, shouldLowerCase,
          Array.prototype.shift, <span class="keyword">function</span>() {<span class="keyword">return</span> <span class="keyword">this</span>[<span class="number">0</span>];},
          <span class="keyword">function</span>(node) {<span class="keyword">return</span> node.nextSibling;});
      },
    <span class="string">'namespace'</span>:
      <span class="function"><span class="keyword">function</span> <span class="title">namespace</span><span class="params">(nodeList  <span class="comment">/*destructive!*/</span>, nodeTypeNum, nodeName, shouldLowerCase)</span> {</span>
        <span class="comment">// TODO</span>
      },
    <span class="string">'parent'</span>:
      <span class="function"><span class="keyword">function</span> <span class="title">parent</span><span class="params">(nodeList  <span class="comment">/*destructive!*/</span>, nodeTypeNum, nodeName, shouldLowerCase)</span> {</span>
        <span class="keyword">var</span> matcher = <span class="keyword">new</span> NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);
        <span class="keyword">var</span> nodes = [], pos = [];
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nodeList.length; ++i) {
          <span class="keyword">var</span> parent = nodeList[i].parentNode || nodeList[i].ownerElement;
          <span class="keyword">if</span> (<span class="literal">null</span> == parent)
            <span class="keyword">continue</span>;
          <span class="keyword">if</span> (!matcher.matches(parent))
            <span class="keyword">continue</span>;
          <span class="keyword">if</span> (nodes.length > <span class="number">0</span> &amp;&amp; parent === nodes[nodes.length-<span class="number">1</span>])
            <span class="keyword">continue</span>;
          nodes.push(parent);
          pos.push([<span class="number">1</span>]);
        }
        <span class="keyword">return</span> {nodes:nodes, pos:pos, lasts:pos};
      },
    <span class="string">'preceding'</span>:
      <span class="function"><span class="keyword">function</span> <span class="title">preceding</span><span class="params">(nodeList  <span class="comment">/*destructive!*/</span>, nodeTypeNum, nodeName, shouldLowerCase)</span> {</span>
        <span class="keyword">return</span> precedingHelper(
          nodeList  <span class="comment">/*destructive!*/</span>, nodeTypeNum, nodeName, shouldLowerCase);
      },
    <span class="string">'preceding-sibling'</span>:
      <span class="function"><span class="keyword">function</span> <span class="title">precedingSibling</span><span class="params">(nodeList  <span class="comment">/*destructive!*/</span>, nodeTypeNum, nodeName, shouldLowerCase)</span> {</span>
        <span class="keyword">return</span> followingSiblingHelper(
          nodeList  <span class="comment">/*destructive!*/</span>, nodeTypeNum, nodeName, shouldLowerCase,
          Array.prototype.pop, <span class="keyword">function</span>() {<span class="keyword">return</span> <span class="keyword">this</span>[<span class="keyword">this</span>.length-<span class="number">1</span>];},
          <span class="keyword">function</span>(node) {<span class="keyword">return</span> node.previousSibling},
          <span class="literal">false</span>, <span class="literal">true</span>);
      },
    <span class="string">'self'</span>:
      <span class="function"><span class="keyword">function</span> <span class="title">self</span><span class="params">(nodeList  <span class="comment">/*destructive!*/</span>, nodeTypeNum, nodeName, shouldLowerCase)</span> {</span>
        <span class="keyword">var</span> nodes = [], pos = [];
        <span class="keyword">var</span> matcher = <span class="keyword">new</span> NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nodeList.length; ++i) {
          <span class="keyword">if</span> (matcher.matches(nodeList[i])) {
            nodes.push(nodeList[i]);
            pos.push([<span class="number">1</span>]);
          }
        }
        <span class="keyword">return</span> {nodes: nodes, pos: pos, lasts: pos}
      }
  };

  <span class="comment">/***************************************************************************
   *                         Evaluation: functions                           *
   ***************************************************************************/</span>
  <span class="keyword">var</span> fn = {
    <span class="string">'number'</span>: <span class="function"><span class="keyword">function</span> <span class="title">number</span><span class="params">(optObject)</span> {</span>
      <span class="keyword">if</span> (<span class="string">'number'</span> === <span class="keyword">typeof</span> optObject)
        <span class="keyword">return</span> optObject;
      <span class="keyword">if</span> (<span class="string">'string'</span> === <span class="keyword">typeof</span> optObject)
        <span class="keyword">return</span> parseFloat(optObject);  <span class="comment">// note: parseFloat(' ') -> NaN, unlike +' ' -> 0.</span>
      <span class="keyword">if</span> (<span class="string">'boolean'</span> === <span class="keyword">typeof</span> optObject)
        <span class="keyword">return</span> +optObject;
      <span class="keyword">return</span> fn.number(fn.string.call(<span class="keyword">this</span>, optObject));  <span class="comment">// for node-sets</span>
    },
    <span class="string">'string'</span>: <span class="function"><span class="keyword">function</span> <span class="title">string</span><span class="params">(optObject)</span> {</span>
      <span class="keyword">if</span> (<span class="literal">null</span> == optObject)
        <span class="keyword">return</span> fn.string(<span class="keyword">this</span>);
      <span class="keyword">if</span> (<span class="string">'string'</span> === <span class="keyword">typeof</span> optObject || <span class="string">'boolean'</span> === <span class="keyword">typeof</span> optObject ||
          <span class="string">'number'</span> === <span class="keyword">typeof</span> optObject)
        <span class="keyword">return</span> <span class="string">''</span> + optObject;
      <span class="keyword">if</span> (<span class="number">0</span> == optObject.nodes.length) <span class="keyword">return</span> <span class="string">''</span>;
      <span class="keyword">if</span> (<span class="literal">null</span> != optObject.nodes[<span class="number">0</span>].textContent)
        <span class="keyword">return</span> optObject.nodes[<span class="number">0</span>].textContent;
      <span class="keyword">return</span> optObject.nodes[<span class="number">0</span>].nodeValue;
    },
    <span class="string">'boolean'</span>: <span class="function"><span class="keyword">function</span> <span class="title">booleanVal</span><span class="params">(x)</span> {</span>
      <span class="keyword">return</span> <span class="string">'object'</span> === <span class="keyword">typeof</span> x ? x.nodes.length > <span class="number">0</span> : !!x;
    },
    <span class="string">'last'</span>: <span class="function"><span class="keyword">function</span> <span class="title">last</span><span class="params">()</span> {</span>
      console.assert(Array.isArray(<span class="keyword">this</span>.pos));
      console.assert(Array.isArray(<span class="keyword">this</span>.lasts));
      console.assert(<span class="number">1</span> === <span class="keyword">this</span>.pos.length);
      console.assert(<span class="number">1</span> === <span class="keyword">this</span>.lasts.length);
      console.assert(<span class="number">1</span> === <span class="keyword">this</span>.lasts[<span class="number">0</span>].length);
      <span class="keyword">return</span> <span class="keyword">this</span>.lasts[<span class="number">0</span>][<span class="number">0</span>];
    },
    <span class="string">'position'</span>: <span class="function"><span class="keyword">function</span> <span class="title">position</span><span class="params">()</span> {</span>
      console.assert(Array.isArray(<span class="keyword">this</span>.pos));
      console.assert(Array.isArray(<span class="keyword">this</span>.lasts));
      console.assert(<span class="number">1</span> === <span class="keyword">this</span>.pos.length);
      console.assert(<span class="number">1</span> === <span class="keyword">this</span>.lasts.length);
      console.assert(<span class="number">1</span> === <span class="keyword">this</span>.pos[<span class="number">0</span>].length);
      <span class="keyword">return</span> <span class="keyword">this</span>.pos[<span class="number">0</span>][<span class="number">0</span>];
    },
    <span class="string">'count'</span>: <span class="function"><span class="keyword">function</span> <span class="title">count</span><span class="params">(nodeSet)</span> {</span>
      <span class="keyword">if</span> (<span class="string">'object'</span> !== <span class="keyword">typeof</span> nodeSet)
        <span class="keyword">throw</span> <span class="keyword">new</span> XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 <span class="string">'Position '</span> + stream.position() +
                                 <span class="string">': Function count(node-set) '</span> +
                                 <span class="string">'got wrong argument type: '</span> + nodeSet);
      <span class="keyword">return</span> nodeSet.nodes.length;
    },
    <span class="string">'id'</span>: <span class="function"><span class="keyword">function</span> <span class="title">id</span><span class="params">(object)</span> {</span>
      <span class="keyword">var</span> r = {nodes: []};
      <span class="keyword">var</span> doc = <span class="keyword">this</span>.nodes[<span class="number">0</span>].ownerDocument || <span class="keyword">this</span>.nodes[<span class="number">0</span>];
      console.assert(doc);
      <span class="keyword">var</span> ids;
      <span class="keyword">if</span> (<span class="string">'object'</span> === <span class="keyword">typeof</span> object) {
        <span class="comment">// for node-sets, map id over each node value.</span>
        ids = [];
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; object.nodes.length; ++i) {
          <span class="keyword">var</span> idNode = object.nodes[i];
          <span class="keyword">var</span> idsString = fn.string({nodes:[idNode]});
          <span class="keyword">var</span> a = idsString.split(<span class="regexp">/[ \t\r\n]+/g</span>);
          Array.prototype.push.apply(ids, a);
        }
      } <span class="keyword">else</span> {
        <span class="keyword">var</span> idsString = fn.string(object);
        <span class="keyword">var</span> a = idsString.split(<span class="regexp">/[ \t\r\n]+/g</span>);
        ids = a;
      }
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ids.length; ++i) {
        <span class="keyword">var</span> id = ids[i];
        <span class="keyword">if</span> (<span class="number">0</span> === id.length)
          <span class="keyword">continue</span>;
        <span class="keyword">var</span> node = doc.getElementById(id);
        <span class="keyword">if</span> (<span class="literal">null</span> != node)
          r.nodes.push(node);
      }
      r.nodes = sortUniqDocumentOrder(r.nodes);
      <span class="keyword">return</span> r;
    },
    <span class="string">'local-name'</span>: <span class="keyword">function</span>(nodeSet) {
      <span class="keyword">if</span> (<span class="literal">null</span> == nodeSet)
        <span class="keyword">return</span> fn.name(<span class="keyword">this</span>);
      <span class="keyword">if</span> (<span class="literal">null</span> == nodeSet.nodes) {
        <span class="keyword">throw</span> <span class="keyword">new</span> XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 <span class="string">'argument to name() must be a node-set. got '</span> + nodeSet);
      }
      <span class="comment">// TODO: namespaced version</span>
      <span class="keyword">return</span> nodeSet.nodes[<span class="number">0</span>].nodeName.toLowerCase();  <span class="comment">// TODO: no toLowerCase for xml</span>
    },
    <span class="string">'namespace-uri'</span>: <span class="keyword">function</span>(nodeSet) {
      <span class="comment">// TODO</span>
      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'not implemented yet'</span>);
    },
    <span class="string">'name'</span>: <span class="keyword">function</span>(nodeSet) {
      <span class="keyword">if</span> (<span class="literal">null</span> == nodeSet)
        <span class="keyword">return</span> fn.name(<span class="keyword">this</span>);
      <span class="keyword">if</span> (<span class="literal">null</span> == nodeSet.nodes) {
        <span class="keyword">throw</span> <span class="keyword">new</span> XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 <span class="string">'argument to name() must be a node-set. got '</span> + nodeSet);
      }
      <span class="keyword">return</span> nodeSet.nodes[<span class="number">0</span>].nodeName.toLowerCase();  <span class="comment">// TODO: no toLowerCase for xml</span>
    },
    <span class="string">'concat'</span>: <span class="function"><span class="keyword">function</span> <span class="title">concat</span><span class="params">(x)</span> {</span>
      <span class="keyword">var</span> l = [];
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arguments.length; ++i) {
        l.push(fn.string(arguments[i]));
      }
      <span class="keyword">return</span> l.join(<span class="string">''</span>);
    },
    <span class="string">'starts-with'</span>: <span class="function"><span class="keyword">function</span> <span class="title">startsWith</span><span class="params">(a, b)</span> {</span>
      <span class="keyword">var</span> as = fn.string(a), bs = fn.string(b);
      <span class="keyword">return</span> as.substr(<span class="number">0</span>, bs.length) === bs;
    },
    <span class="string">'contains'</span>: <span class="function"><span class="keyword">function</span> <span class="title">contains</span><span class="params">(a, b)</span> {</span>
      <span class="keyword">var</span> as = fn.string(a), bs = fn.string(b);
      <span class="keyword">var</span> i = as.indexOf(bs);
      <span class="keyword">if</span> (-<span class="number">1</span> === i) <span class="keyword">return</span> <span class="literal">false</span>;
      <span class="keyword">return</span> <span class="literal">true</span>;
    },
    <span class="string">'substring-before'</span>: <span class="function"><span class="keyword">function</span> <span class="title">substringBefore</span><span class="params">(a, b)</span> {</span>
      <span class="keyword">var</span> as = fn.string(a), bs = fn.string(b);
      <span class="keyword">var</span> i = as.indexOf(bs);
      <span class="keyword">if</span> (-<span class="number">1</span> === i) <span class="keyword">return</span> <span class="string">''</span>;
      <span class="keyword">return</span> as.substr(<span class="number">0</span>, i);
    },
    <span class="string">'substring-after'</span>: <span class="function"><span class="keyword">function</span> <span class="title">substringBefore</span><span class="params">(a, b)</span> {</span>
      <span class="keyword">var</span> as = fn.string(a), bs = fn.string(b);
      <span class="keyword">var</span> i = as.indexOf(bs);
      <span class="keyword">if</span> (-<span class="number">1</span> === i) <span class="keyword">return</span> <span class="string">''</span>;
      <span class="keyword">return</span> as.substr(i + bs.length);
    },
    <span class="string">'substring'</span>: <span class="function"><span class="keyword">function</span> <span class="title">substring</span><span class="params">(string, start, optEnd)</span> {</span>
      <span class="keyword">if</span> (<span class="literal">null</span> == string || <span class="literal">null</span> == start) {
        <span class="keyword">throw</span> <span class="keyword">new</span> XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                 <span class="string">'Must be at least 2 arguments to string()'</span>);
      }
      <span class="keyword">var</span> sString = fn.string(string),
          iStart = fn.round(start),
          iEnd = optEnd == <span class="literal">null</span> ? <span class="literal">null</span> : fn.round(optEnd);
      <span class="comment">// Note that xpath string positions user 1-based index</span>
      <span class="keyword">if</span> (iEnd == <span class="literal">null</span>)
        <span class="keyword">return</span> sString.substr(iStart - <span class="number">1</span>);
      <span class="keyword">else</span>
        <span class="keyword">return</span> sString.substr(iStart - <span class="number">1</span>, iEnd);
    },
    <span class="string">'string-length'</span>: <span class="function"><span class="keyword">function</span> <span class="title">stringLength</span><span class="params">(optString)</span> {</span>
      <span class="keyword">return</span> fn.string.call(<span class="keyword">this</span>, optString).length;
    },
    <span class="string">'normalize-space'</span>: <span class="function"><span class="keyword">function</span> <span class="title">normalizeSpace</span><span class="params">(optString)</span> {</span>
      <span class="keyword">var</span> s = fn.string.call(<span class="keyword">this</span>, optString);
      <span class="keyword">return</span> s.replace(<span class="regexp">/[ \t\r\n]+/g</span>, <span class="string">' '</span>).replace(<span class="regexp">/^ | $/g</span>, <span class="string">''</span>);
    },
    <span class="string">'translate'</span>: <span class="function"><span class="keyword">function</span> <span class="title">translate</span><span class="params">(string, from, to)</span> {</span>
      <span class="keyword">var</span> sString = fn.string.call(<span class="keyword">this</span>, string),
          sFrom = fn.string(from),
          sTo = fn.string(to);
      <span class="keyword">var</span> eachCharRe = [];
      <span class="keyword">var</span> map = {};
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; sFrom.length; ++i) {
        <span class="keyword">var</span> c = sFrom.charAt(i);
        map[c] = sTo.charAt(i);  <span class="comment">// returns '' if beyond length of sTo.</span>
        <span class="comment">// copied from goog.string.regExpEscape in the Closure library.</span>
        eachCharRe.push(
          c.replace(<span class="regexp">/([-()\[\]{}+?*.$\^|,:#&lt;!\\])/g</span>, <span class="string">'\\$1'</span>).
            replace(<span class="regexp">/\x08/g</span>, <span class="string">'\\x08'</span>));
      }
      <span class="keyword">var</span> re = <span class="keyword">new</span> RegExp(eachCharRe.join(<span class="string">'|'</span>), <span class="string">'g'</span>);
      <span class="keyword">return</span> sString.replace(re, <span class="keyword">function</span>(c) {<span class="keyword">return</span> map[c];});
    },
    <span class="comment">/// Boolean functions</span>
    <span class="string">'not'</span>: <span class="function"><span class="keyword">function</span> <span class="title">not</span><span class="params">(x)</span> {</span>
      <span class="keyword">var</span> bx = fn[<span class="string">'boolean'</span>](x);
      <span class="keyword">return</span> !bx;
    },
    <span class="string">'true'</span>: <span class="function"><span class="keyword">function</span> <span class="title">trueVal</span><span class="params">()</span> {</span> <span class="keyword">return</span> <span class="literal">true</span>; },
    <span class="string">'false'</span>: <span class="function"><span class="keyword">function</span> <span class="title">falseVal</span><span class="params">()</span> {</span> <span class="keyword">return</span> <span class="literal">false</span>; },
    <span class="comment">// TODO</span>
    <span class="string">'lang'</span>: <span class="function"><span class="keyword">function</span> <span class="title">lang</span><span class="params">(string)</span> {</span> <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Not implemented'</span>);},
    <span class="string">'sum'</span>: <span class="function"><span class="keyword">function</span> <span class="title">sum</span><span class="params">(optNodeSet)</span> {</span>
      <span class="keyword">if</span> (<span class="literal">null</span> == optNodeSet) <span class="keyword">return</span> fn.sum(<span class="keyword">this</span>);
      <span class="comment">// for node-sets, map id over each node value.</span>
      <span class="keyword">var</span> sum = <span class="number">0</span>;
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; optNodeSet.nodes.length; ++i) {
        <span class="keyword">var</span> node = optNodeSet.nodes[i];
        <span class="keyword">var</span> x = fn.number({nodes:[node]});
        sum += x;
      }
      <span class="keyword">return</span> sum;
    },
    <span class="string">'floor'</span>: <span class="function"><span class="keyword">function</span> <span class="title">floor</span><span class="params">(number)</span> {</span>
      <span class="keyword">return</span> Math.floor(fn.number(number));
    },
    <span class="string">'ceiling'</span>: <span class="function"><span class="keyword">function</span> <span class="title">ceiling</span><span class="params">(number)</span> {</span>
      <span class="keyword">return</span> Math.ceil(fn.number(number));
    },
    <span class="string">'round'</span>: <span class="function"><span class="keyword">function</span> <span class="title">round</span><span class="params">(number)</span> {</span>
      <span class="keyword">return</span> Math.round(fn.number(number));
    }
  };
  <span class="comment">/***************************************************************************
   *                         Evaluation: operators                           *
   ***************************************************************************/</span>
  <span class="keyword">var</span> more = {
    UnaryMinus: <span class="keyword">function</span>(x) { <span class="keyword">return</span> -fn.number(x); },
    <span class="string">'+'</span>: <span class="keyword">function</span>(x, y) { <span class="keyword">return</span> fn.number(x) + fn.number(y); },
    <span class="string">'-'</span>: <span class="keyword">function</span>(x, y) { <span class="keyword">return</span> fn.number(x) - fn.number(y); },
    <span class="string">'*'</span>: <span class="keyword">function</span>(x, y) { <span class="keyword">return</span> fn.number(x) * fn.number(y); },
    <span class="string">'div'</span>: <span class="keyword">function</span>(x, y) { <span class="keyword">return</span> fn.number(x) / fn.number(y); },
    <span class="string">'mod'</span>: <span class="keyword">function</span>(x, y) { <span class="keyword">return</span> fn.number(x) % fn.number(y); },
    <span class="string">'&lt;'</span>: <span class="keyword">function</span>(x, y) {
      <span class="keyword">return</span> comparisonHelper(<span class="keyword">function</span>(x, y) { <span class="keyword">return</span> fn.number(x) &lt; fn.number(y);}, x, y, <span class="literal">true</span>);
    },
    <span class="string">'&lt;='</span>: <span class="keyword">function</span>(x, y) {
      <span class="keyword">return</span> comparisonHelper(<span class="keyword">function</span>(x, y) { <span class="keyword">return</span> fn.number(x) &lt;= fn.number(y);}, x, y, <span class="literal">true</span>);
    },
    <span class="string">'>'</span>:  <span class="keyword">function</span>(x, y) {
      <span class="keyword">return</span> comparisonHelper(<span class="keyword">function</span>(x, y) { <span class="keyword">return</span> fn.number(x) > fn.number(y);}, x, y, <span class="literal">true</span>);
    },
    <span class="string">'>='</span>: <span class="keyword">function</span>(x, y) {
      <span class="keyword">return</span> comparisonHelper(<span class="keyword">function</span>(x, y) { <span class="keyword">return</span> fn.number(x) >= fn.number(y);}, x, y, <span class="literal">true</span>);
    },
    <span class="string">'and'</span>: <span class="keyword">function</span>(x, y) { <span class="keyword">return</span> fn[<span class="string">'boolean'</span>](x) &amp;&amp; fn[<span class="string">'boolean'</span>](y); },
    <span class="string">'or'</span>: <span class="keyword">function</span>(x, y) { <span class="keyword">return</span> fn[<span class="string">'boolean'</span>](x) || fn[<span class="string">'boolean'</span>](y); },
    <span class="string">'|'</span>: <span class="keyword">function</span>(x, y) { <span class="keyword">return</span> {nodes: mergeNodeLists(x.nodes, y.nodes)}; },
    <span class="string">'='</span>: <span class="keyword">function</span>(x, y) {
      <span class="comment">// optimization for two node-sets case: avoid n^2 comparisons.</span>
      <span class="keyword">if</span> (<span class="string">'object'</span> === <span class="keyword">typeof</span> x &amp;&amp; <span class="string">'object'</span> === <span class="keyword">typeof</span> y) {
        <span class="keyword">var</span> aMap = {};
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; x.nodes.length; ++i) {
          <span class="keyword">var</span> s = fn.string({nodes:[x.nodes[i]]});
          aMap[s] = <span class="literal">true</span>;
        }
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; y.nodes.length; ++i) {
          <span class="keyword">var</span> s = fn.string({nodes:[y.nodes[i]]});
          <span class="keyword">if</span> (aMap[s]) <span class="keyword">return</span> <span class="literal">true</span>;
        }
        <span class="keyword">return</span> <span class="literal">false</span>;
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> comparisonHelper(<span class="keyword">function</span>(x, y) {<span class="keyword">return</span> x === y;}, x, y);
      }
    },
    <span class="string">'!='</span>: <span class="keyword">function</span>(x, y) {
      <span class="comment">// optimization for two node-sets case: avoid n^2 comparisons.</span>
      <span class="keyword">if</span> (<span class="string">'object'</span> === <span class="keyword">typeof</span> x &amp;&amp; <span class="string">'object'</span> === <span class="keyword">typeof</span> y) {
        <span class="keyword">if</span> (<span class="number">0</span> === x.nodes.length || <span class="number">0</span> === y.nodes.length) <span class="keyword">return</span> <span class="literal">false</span>;
        <span class="keyword">var</span> aMap = {};
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; x.nodes.length; ++i) {
          <span class="keyword">var</span> s = fn.string({nodes:[x.nodes[i]]});
          aMap[s] = <span class="literal">true</span>;
        }
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; y.nodes.length; ++i) {
          <span class="keyword">var</span> s = fn.string({nodes:[y.nodes[i]]});
          <span class="keyword">if</span> (!aMap[s]) <span class="keyword">return</span> <span class="literal">true</span>;
        }
        <span class="keyword">return</span> <span class="literal">false</span>;
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> comparisonHelper(<span class="keyword">function</span>(x, y) {<span class="keyword">return</span> x !== y;}, x, y);
      }
    }
  };
  <span class="keyword">var</span> nodeTypes = xpath.nodeTypes = {
    <span class="string">'node'</span>: <span class="number">0</span>,
    <span class="string">'attribute'</span>: <span class="number">2</span>,
    <span class="string">'comment'</span>: <span class="number">8</span>, <span class="comment">// this.doc.COMMENT_NODE,</span>
    <span class="string">'text'</span>: <span class="number">3</span>, <span class="comment">// this.doc.TEXT_NODE,</span>
    <span class="string">'processing-instruction'</span>: <span class="number">7</span>, <span class="comment">// this.doc.PROCESSING_INSTRUCTION_NODE,</span>
    <span class="string">'element'</span>: <span class="number">1</span>  <span class="comment">//this.doc.ELEMENT_NODE</span>
  };
  <span class="comment">/** For debugging and unit tests: returnjs a stringified version of the
   * argument. */</span>
  <span class="keyword">var</span> stringifyObject = xpath.stringifyObject = <span class="function"><span class="keyword">function</span> <span class="title">stringifyObject</span><span class="params">(ctx)</span> {</span>
    <span class="keyword">var</span> seenKey = <span class="string">'seen'</span> + Math.floor(Math.random()*<span class="number">1000000000</span>);
    <span class="keyword">return</span> JSON.stringify(helper(ctx));

    <span class="function"><span class="keyword">function</span> <span class="title">helper</span><span class="params">(ctx)</span> {</span>
      <span class="keyword">if</span> (Array.isArray(ctx)) {
        <span class="keyword">return</span> ctx.map(<span class="keyword">function</span>(x) {<span class="keyword">return</span> helper(x);});
      }
      <span class="keyword">if</span> (<span class="string">'object'</span> !== <span class="keyword">typeof</span> ctx) <span class="keyword">return</span> ctx;
      <span class="keyword">if</span> (<span class="literal">null</span> == ctx) <span class="keyword">return</span> ctx;
    <span class="comment">//  if (ctx.toString) return ctx.toString();</span>
      <span class="keyword">if</span> (<span class="literal">null</span> != ctx.outerHTML) <span class="keyword">return</span> ctx.outerHTML;
      <span class="keyword">if</span> (<span class="literal">null</span> != ctx.nodeValue) <span class="keyword">return</span> ctx.nodeName + <span class="string">'='</span> + ctx.nodeValue;
      <span class="keyword">if</span> (ctx[seenKey]) <span class="keyword">return</span> <span class="string">'[circular]'</span>;
      ctx[seenKey] = <span class="literal">true</span>;
      <span class="keyword">var</span> nicer = {};
      <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> ctx) {
        <span class="keyword">if</span> (seenKey === key)
          <span class="keyword">continue</span>;
        <span class="keyword">try</span> {
          nicer[key] = helper(ctx[key]);
        } <span class="keyword">catch</span> (e) {
          nicer[key] = <span class="string">'[exception: '</span> + e.message + <span class="string">']'</span>;
        }
      }
      <span class="keyword">delete</span> ctx[seenKey];
      <span class="keyword">return</span> nicer;
    }
  }
  <span class="keyword">var</span> Evaluator = xpath.Evaluator = <span class="function"><span class="keyword">function</span> <span class="title">Evaluator</span><span class="params">(doc)</span> {</span>
    <span class="keyword">this</span>.doc = doc;
  }
  Evaluator.prototype = {
    val: <span class="function"><span class="keyword">function</span> <span class="title">val</span><span class="params">(ast, ctx)</span> {</span>
      console.assert(ctx.nodes);

      <span class="keyword">if</span> (<span class="string">'number'</span> === <span class="keyword">typeof</span> ast || <span class="string">'string'</span> === <span class="keyword">typeof</span> ast) <span class="keyword">return</span> ast;
      <span class="keyword">if</span> (more[ast[<span class="number">0</span>]]) {
        <span class="keyword">var</span> evaluatedParams = [];
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; ast.length; ++i) {
          evaluatedParams.push(<span class="keyword">this</span>.val(ast[i], ctx));
        }
        <span class="keyword">var</span> r = more[ast[<span class="number">0</span>]].apply(ctx, evaluatedParams);
        <span class="keyword">return</span> r;
      }
      <span class="keyword">switch</span> (ast[<span class="number">0</span>]) {
        <span class="keyword">case</span> <span class="string">'Root'</span>: <span class="keyword">return</span> {nodes: [<span class="keyword">this</span>.doc]};
        <span class="keyword">case</span> <span class="string">'FunctionCall'</span>:
          <span class="keyword">var</span> functionName = ast[<span class="number">1</span>], functionParams = ast[<span class="number">2</span>];
          <span class="keyword">if</span> (<span class="literal">null</span> == fn[functionName])
            <span class="keyword">throw</span> <span class="keyword">new</span> XPathException(XPathException.INVALID_EXPRESSION_ERR,
                                     <span class="string">'Unknown function: '</span> + functionName);
          <span class="keyword">var</span> evaluatedParams = [];
          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; functionParams.length; ++i) {
            evaluatedParams.push(<span class="keyword">this</span>.val(functionParams[i], ctx));
          }
          <span class="keyword">var</span> r = fn[functionName].apply(ctx, evaluatedParams);
          <span class="keyword">return</span> r;
        <span class="keyword">case</span> <span class="string">'Predicate'</span>:
          <span class="keyword">var</span> lhs = <span class="keyword">this</span>.val(ast[<span class="number">1</span>], ctx);
          <span class="keyword">var</span> ret = {nodes: []};
          <span class="keyword">var</span> contexts = eachContext(lhs);
          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; contexts.length; ++i) {
            <span class="keyword">var</span> singleNodeSet = contexts[i];
            <span class="keyword">var</span> rhs = <span class="keyword">this</span>.val(ast[<span class="number">2</span>], singleNodeSet);
            <span class="keyword">var</span> success;
            <span class="keyword">if</span> (<span class="string">'number'</span> === <span class="keyword">typeof</span> rhs) {
              success = rhs === singleNodeSet.pos[<span class="number">0</span>][<span class="number">0</span>];
            } <span class="keyword">else</span> {
              success = fn[<span class="string">'boolean'</span>](rhs);
            }
            <span class="keyword">if</span> (success) {
              <span class="keyword">var</span> node = singleNodeSet.nodes[<span class="number">0</span>];
              ret.nodes.push(node);
              <span class="comment">// skip over all the rest of the same node.</span>
              <span class="keyword">while</span> (i+<span class="number">1</span> &lt; contexts.length &amp;&amp; node === contexts[i+<span class="number">1</span>].nodes[<span class="number">0</span>]) {
                i++;
              }
            }
          }
          <span class="keyword">return</span> ret;
        <span class="keyword">case</span> <span class="string">'PathExpr'</span>:
          <span class="comment">// turn the path into an expressoin; i.e., remove the position</span>
          <span class="comment">// information of the last axis.</span>
          <span class="keyword">var</span> x = <span class="keyword">this</span>.val(ast[<span class="number">1</span>], ctx);
          <span class="comment">// Make the nodeset a forward-direction-only one.</span>
          <span class="keyword">if</span> (x.finalize) {  <span class="comment">// it is a NodeMultiSet</span>
            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; x.nodes.length; ++i) {
              console.assert(<span class="literal">null</span> != x.nodes[i].nodeType);
            }
            <span class="keyword">return</span> {nodes: x.nodes};
          } <span class="keyword">else</span> {
            <span class="keyword">return</span> x;
          }
        <span class="keyword">case</span> <span class="string">'/'</span>:
          <span class="comment">// TODO: don't generate '/' nodes, just Axis nodes.</span>
          <span class="keyword">var</span> lhs = <span class="keyword">this</span>.val(ast[<span class="number">1</span>], ctx);
          console.assert(<span class="literal">null</span> != lhs);
          <span class="keyword">var</span> r = <span class="keyword">this</span>.val(ast[<span class="number">2</span>], lhs);
          console.assert(<span class="literal">null</span> != r);
          <span class="keyword">return</span> r;
        <span class="keyword">case</span> <span class="string">'Axis'</span>:
          <span class="comment">// All the axis tests from Step. We only get AxisSpecifier NodeTest,</span>
          <span class="comment">// not the predicate (which is applied later)</span>
          <span class="keyword">var</span> axis = ast[<span class="number">1</span>],
              nodeType = ast[<span class="number">2</span>],
              nodeTypeNum = nodeTypes[nodeType],
              shouldLowerCase = <span class="literal">true</span>,  <span class="comment">// TODO: give option</span>
              nodeName = ast[<span class="number">3</span>] &amp;&amp; shouldLowerCase ? ast[<span class="number">3</span>].toLowerCase() : ast[<span class="number">3</span>];
          nodeName = nodeName === <span class="string">'*'</span> ? <span class="literal">null</span> : nodeName;
          <span class="keyword">if</span> (<span class="string">'object'</span> !== <span class="keyword">typeof</span> ctx) <span class="keyword">return</span> {nodes:[], pos:[]};
          <span class="keyword">var</span> nodeList = ctx.nodes.slice();  <span class="comment">// TODO: is copy needed?</span>
          <span class="keyword">var</span> r = axes[axis](nodeList  <span class="comment">/*destructive!*/</span>, nodeTypeNum, nodeName, shouldLowerCase);
          <span class="keyword">return</span> r;
      }
    }
  };
  <span class="keyword">var</span> evaluate = xpath.evaluate = <span class="function"><span class="keyword">function</span> <span class="title">evaluate</span><span class="params">(expr, doc, context)</span> {</span>
    <span class="comment">//var astFactory = new AstEvaluatorFactory(doc, context);</span>
    <span class="keyword">var</span> stream = <span class="keyword">new</span> Stream(expr);
    <span class="keyword">var</span> ast = parse(stream, astFactory);
    <span class="keyword">var</span> val = <span class="keyword">new</span> Evaluator(doc).val(ast, {nodes: [context]});
    <span class="keyword">return</span> val;
  }

  <span class="comment">/***************************************************************************
   *                           DOM interface                                 *
   ***************************************************************************/</span>
  <span class="keyword">var</span> XPathException = xpath.XPathException = <span class="function"><span class="keyword">function</span> <span class="title">XPathException</span><span class="params">(code, message)</span> {</span>
    <span class="keyword">var</span> e = <span class="keyword">new</span> Error(message);
    <span class="keyword">this</span>.__proto__ = e;
    <span class="keyword">this</span>.name = <span class="string">'XPathException'</span>;
    <span class="keyword">this</span>.code = code;
  }
  XPathException.prototype = Error.prototype;
  XPathException.prototype.__proto__ = XPathException;
  XPathException.INVALID_EXPRESSION_ERR = <span class="number">51</span>;
  XPathException.TYPE_ERR = <span class="number">52</span>;


  <span class="keyword">var</span> XPathEvaluator = xpath.XPathEvaluator = <span class="function"><span class="keyword">function</span> <span class="title">XPathEvaluator</span><span class="params">()</span> {</span>}
  XPathEvaluator.prototype = {
    createExpression: <span class="keyword">function</span>(expression, resolver) {
      <span class="keyword">return</span> <span class="keyword">new</span> XPathExpression(expression, resolver);
    },
    createNSResolver: <span class="keyword">function</span>(nodeResolver) {
      <span class="comment">// TODO</span>
    },
    evaluate: <span class="function"><span class="keyword">function</span> <span class="title">evaluate</span><span class="params">(expression, contextNode, resolver, type, result)</span> {</span>
      <span class="keyword">var</span> expr = <span class="keyword">new</span> XPathExpression(expression, resolver);
      <span class="keyword">return</span> expr.evaluate(contextNode, type, result);
    }
  };


  <span class="keyword">var</span> XPathExpression = xpath.XPathExpression = <span class="function"><span class="keyword">function</span> <span class="title">XPathExpression</span><span class="params">(expression, resolver, optDoc)</span> {</span>
    <span class="keyword">var</span> stream = <span class="keyword">new</span> Stream(expression);
    <span class="keyword">this</span>._ast = parse(stream, astFactory);
    <span class="keyword">this</span>._doc = optDoc;
  }
  XPathExpression.prototype = {
    evaluate: <span class="function"><span class="keyword">function</span> <span class="title">evaluate</span><span class="params">(contextNode, type, result)</span> {</span>
      <span class="keyword">if</span> (<span class="literal">null</span> == contextNode.nodeType)
        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'bad argument (expected context node): '</span> + contextNode);
      <span class="keyword">var</span> doc = contextNode.ownerDocument || contextNode;
      <span class="keyword">if</span> (<span class="literal">null</span> != <span class="keyword">this</span>._doc &amp;&amp; <span class="keyword">this</span>._doc !== doc) {
        <span class="keyword">throw</span> <span class="keyword">new</span> core.DOMException(
            core.WRONG_DOCUMENT_ERR,
            <span class="string">'The document must be the same as the context node\'s document.'</span>);
      }
      <span class="keyword">var</span> evaluator = <span class="keyword">new</span> Evaluator(doc);
      <span class="keyword">var</span> value = evaluator.val(<span class="keyword">this</span>._ast, {nodes: [contextNode]});
      <span class="keyword">if</span> (XPathResult.NUMBER_TYPE === type)
        value = fn.number(value);
      <span class="keyword">else</span> <span class="keyword">if</span> (XPathResult.STRING_TYPE === type)
        value = fn.string(value);
      <span class="keyword">else</span> <span class="keyword">if</span> (XPathResult.BOOLEAN_TYPE === type)
        value = fn[<span class="string">'boolean'</span>](value);
      <span class="keyword">else</span> <span class="keyword">if</span> (XPathResult.ANY_TYPE !== type &amp;&amp;
               XPathResult.UNORDERED_NODE_ITERATOR_TYPE !== type &amp;&amp;
               XPathResult.ORDERED_NODE_ITERATOR_TYPE !== type &amp;&amp;
               XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE !== type &amp;&amp;
               XPathResult.ORDERED_NODE_SNAPSHOT_TYPE !== type &amp;&amp;
               XPathResult.ANY_UNORDERED_NODE_TYPE !== type &amp;&amp;
               XPathResult.FIRST_ORDERED_NODE_TYPE !== type)
        <span class="keyword">throw</span> <span class="keyword">new</span> core.DOMException(
            core.NOT_SUPPORTED_ERR,
            <span class="string">'You must provide an XPath result type (0=any).'</span>);
      <span class="keyword">else</span> <span class="keyword">if</span> (XPathResult.ANY_TYPE !== type &amp;&amp;
               <span class="string">'object'</span> !== <span class="keyword">typeof</span> value)
        <span class="keyword">throw</span> <span class="keyword">new</span> XPathException(
            XPathException.TYPE_ERR,
            <span class="string">'Value should be a node-set: '</span> + value);
      <span class="keyword">return</span> <span class="keyword">new</span> XPathResult(doc, value, type);
    }
  }

  <span class="keyword">var</span> XPathResult = xpath.XPathResult = <span class="function"><span class="keyword">function</span> <span class="title">XPathResult</span><span class="params">(doc, value, resultType)</span> {</span>
    <span class="keyword">this</span>._value = value;
    <span class="keyword">this</span>._resultType = resultType;
    <span class="keyword">this</span>._i = <span class="number">0</span>;
    <span class="keyword">this</span>._invalidated = <span class="literal">false</span>;
    <span class="keyword">if</span> (<span class="keyword">this</span>.resultType === XPathResult.UNORDERED_NODE_ITERATOR_TYPE ||
        <span class="keyword">this</span>.resultType === XPathResult.ORDERED_NODE_ITERATOR_TYPE) {
      doc.addEventListener(<span class="string">'DOMSubtreeModified'</span>, invalidate, <span class="literal">true</span>);
      <span class="keyword">var</span> self = <span class="keyword">this</span>;
      <span class="function"><span class="keyword">function</span> <span class="title">invalidate</span><span class="params">()</span> {</span>
        self._invalidated = <span class="literal">true</span>;
        doc.removeEventListener(<span class="string">'DOMSubtreeModified'</span>, invalidate, <span class="literal">true</span>);
      }
    }
  }
  XPathResult.ANY_TYPE = <span class="number">0</span>;
  XPathResult.NUMBER_TYPE = <span class="number">1</span>;
  XPathResult.STRING_TYPE = <span class="number">2</span>;
  XPathResult.BOOLEAN_TYPE = <span class="number">3</span>;
  XPathResult.UNORDERED_NODE_ITERATOR_TYPE = <span class="number">4</span>;
  XPathResult.ORDERED_NODE_ITERATOR_TYPE = <span class="number">5</span>;
  XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE = <span class="number">6</span>;
  XPathResult.ORDERED_NODE_SNAPSHOT_TYPE = <span class="number">7</span>;
  XPathResult.ANY_UNORDERED_NODE_TYPE = <span class="number">8</span>;
  XPathResult.FIRST_ORDERED_NODE_TYPE = <span class="number">9</span>;
  XPathResult.prototype = {
    <span class="comment">// XPathResultType</span>
    get resultType() {
      <span class="keyword">if</span> (<span class="keyword">this</span>._resultType) <span class="keyword">return</span> <span class="keyword">this</span>._resultType;
      <span class="keyword">switch</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>._value) {
        <span class="keyword">case</span> <span class="string">'number'</span>: <span class="keyword">return</span> XPathResult.NUMBER_TYPE;
        <span class="keyword">case</span> <span class="string">'string'</span>: <span class="keyword">return</span> XPathResult.STRING_TYPE;
        <span class="keyword">case</span> <span class="string">'boolean'</span>: <span class="keyword">return</span> XPathResult.BOOLEAN_TYPE;
        <span class="keyword">default</span>: <span class="keyword">return</span> XPathResult.UNORDERED_NODE_ITERATOR_TYPE;
      }
    },
    get numberValue() {
      <span class="keyword">if</span> (XPathResult.NUMBER_TYPE !== <span class="keyword">this</span>.resultType)
        <span class="keyword">throw</span> <span class="keyword">new</span> XPathException(XPathException.TYPE_ERR,
                                 <span class="string">'You should have asked for a NUMBER_TYPE.'</span>);
      <span class="keyword">return</span> <span class="keyword">this</span>._value;
    },
    get stringValue() {
      <span class="keyword">if</span> (XPathResult.STRING_TYPE !== <span class="keyword">this</span>.resultType)
        <span class="keyword">throw</span> <span class="keyword">new</span> XPathException(XPathException.TYPE_ERR,
                                 <span class="string">'You should have asked for a STRING_TYPE.'</span>);
      <span class="keyword">return</span> <span class="keyword">this</span>._value;
    },
    get booleanValue() {
      <span class="keyword">if</span> (XPathResult.BOOLEAN_TYPE !== <span class="keyword">this</span>.resultType)
        <span class="keyword">throw</span> <span class="keyword">new</span> XPathException(XPathException.TYPE_ERR,
                                 <span class="string">'You should have asked for a BOOLEAN_TYPE.'</span>);
      <span class="keyword">return</span> <span class="keyword">this</span>._value;
    },
    get singleNodeValue() {
      <span class="keyword">if</span> (XPathResult.ANY_UNORDERED_NODE_TYPE !== <span class="keyword">this</span>.resultType &amp;&amp;
          XPathResult.FIRST_ORDERED_NODE_TYPE !== <span class="keyword">this</span>.resultType)
        <span class="keyword">throw</span> <span class="keyword">new</span> XPathException(
            XPathException.TYPE_ERR,
            <span class="string">'You should have asked for a FIRST_ORDERED_NODE_TYPE.'</span>);
      <span class="keyword">return</span> <span class="keyword">this</span>._value.nodes[<span class="number">0</span>] || <span class="literal">null</span>;
    },
    get invalidIteratorState() {
      <span class="keyword">if</span> (XPathResult.UNORDERED_NODE_ITERATOR_TYPE !== <span class="keyword">this</span>.resultType &amp;&amp;
          XPathResult.ORDERED_NODE_ITERATOR_TYPE !== <span class="keyword">this</span>.resultType)
        <span class="keyword">return</span> <span class="literal">false</span>;
      <span class="keyword">return</span> !!<span class="keyword">this</span>._invalidated;
    },
    get snapshotLength() {
      <span class="keyword">if</span> (XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE !== <span class="keyword">this</span>.resultType &amp;&amp;
          XPathResult.ORDERED_NODE_SNAPSHOT_TYPE !== <span class="keyword">this</span>.resultType)
        <span class="keyword">throw</span> <span class="keyword">new</span> XPathException(
            XPathException.TYPE_ERR,
            <span class="string">'You should have asked for a ORDERED_NODE_SNAPSHOT_TYPE.'</span>);
      <span class="keyword">return</span> <span class="keyword">this</span>._value.nodes.length;
    },
    iterateNext: <span class="function"><span class="keyword">function</span> <span class="title">iterateNext</span><span class="params">()</span> {</span>
      <span class="keyword">if</span> (XPathResult.UNORDERED_NODE_ITERATOR_TYPE !== <span class="keyword">this</span>.resultType &amp;&amp;
          XPathResult.ORDERED_NODE_ITERATOR_TYPE !== <span class="keyword">this</span>.resultType)
        <span class="keyword">throw</span> <span class="keyword">new</span> XPathException(
            XPathException.TYPE_ERR,
            <span class="string">'You should have asked for a ORDERED_NODE_ITERATOR_TYPE.'</span>);
      <span class="keyword">if</span> (<span class="keyword">this</span>.invalidIteratorState)
        <span class="keyword">throw</span> <span class="keyword">new</span> core.DOMException(
            core.INVALID_STATE_ERR,
            <span class="string">'The document has been mutated since the result was returned'</span>);
      <span class="keyword">return</span> <span class="keyword">this</span>._value.nodes[<span class="keyword">this</span>._i++] || <span class="literal">null</span>;
    },
    snapshotItem: <span class="function"><span class="keyword">function</span> <span class="title">snapshotItem</span><span class="params">(index)</span> {</span>
      <span class="keyword">if</span> (XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE !== <span class="keyword">this</span>.resultType &amp;&amp;
          XPathResult.ORDERED_NODE_SNAPSHOT_TYPE !== <span class="keyword">this</span>.resultType)
        <span class="keyword">throw</span> <span class="keyword">new</span> XPathException(
            XPathException.TYPE_ERR,
            <span class="string">'You should have asked for a ORDERED_NODE_SNAPSHOT_TYPE.'</span>);
      <span class="keyword">return</span> <span class="keyword">this</span>._value.nodes[index] || <span class="literal">null</span>;
    }
  };
  <span class="comment">// so you can access ANY_TYPE etc. from the instances:</span>
  XPathResult.prototype.__proto__ = XPathResult;

  core.XPathException = XPathException;
  core.XPathExpression = XPathExpression;
  core.XPathResult = XPathResult;
  core.XPathEvaluator = XPathEvaluator;

  core.Document.prototype.createExpression =
    XPathEvaluator.prototype.createExpression;

  core.Document.prototype.createNSResolver =
      XPathEvaluator.prototype.createNSResolver;

  core.Document.prototype.evaluate = XPathEvaluator.prototype.evaluate;

})();
</code></pre>