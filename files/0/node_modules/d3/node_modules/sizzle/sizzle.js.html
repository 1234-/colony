<h1>sizzle</h1>
<pre><code class="lang-js"><span class="comment">/*!
 * Sizzle CSS Selector Engine
 *  Copyright 2011, The Dojo Foundation
 *  Released under the MIT, BSD, and GPL Licenses.
 *  More information: http://sizzlejs.com/
 */</span>
(<span class="keyword">function</span>(){

<span class="keyword">var</span> chunker = <span class="regexp">/((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g</span>,
	expando = <span class="string">"sizcache"</span> + (Math.random() + <span class="string">''</span>).replace(<span class="string">'.'</span>, <span class="string">''</span>),
	done = <span class="number">0</span>,
	toString = Object.prototype.toString,
	hasDuplicate = <span class="literal">false</span>,
	baseHasDuplicate = <span class="literal">true</span>,
	rBackslash = <span class="regexp">/\\/g,
	rReturn = /</span>\r\n/g,
	rNonWord = <span class="regexp">/\W/</span>;

<span class="comment">// Here we check if the JavaScript engine is using some sort of</span>
<span class="comment">// optimization where it does not always call our comparision</span>
<span class="comment">// function. If that is the case, discard the hasDuplicate value.</span>
<span class="comment">//   Thus far that includes Google Chrome.</span>
[<span class="number">0</span>, <span class="number">0</span>].sort(<span class="keyword">function</span>() {
	baseHasDuplicate = <span class="literal">false</span>;
	<span class="keyword">return</span> <span class="number">0</span>;
});

<span class="keyword">var</span> Sizzle = <span class="keyword">function</span>( selector, context, results, seed ) {
	results = results || [];
	context = context || document;

	<span class="keyword">var</span> origContext = context;

	<span class="keyword">if</span> ( context.nodeType !== <span class="number">1</span> &amp;&amp; context.nodeType !== <span class="number">9</span> ) {
		<span class="keyword">return</span> [];
	}

	<span class="keyword">if</span> ( !selector || <span class="keyword">typeof</span> selector !== <span class="string">"string"</span> ) {
		<span class="keyword">return</span> results;
	}

	<span class="keyword">var</span> m, set, checkSet, extra, ret, cur, pop, i,
		prune = <span class="literal">true</span>,
		contextXML = Sizzle.isXML( context ),
		parts = [],
		soFar = selector;

	<span class="comment">// Reset the position of the chunker regexp (start from head)</span>
	<span class="keyword">do</span> {
		chunker.exec( <span class="string">""</span> );
		m = chunker.exec( soFar );

		<span class="keyword">if</span> ( m ) {
			soFar = m[<span class="number">3</span>];

			parts.push( m[<span class="number">1</span>] );

			<span class="keyword">if</span> ( m[<span class="number">2</span>] ) {
				extra = m[<span class="number">3</span>];
				<span class="keyword">break</span>;
			}
		}
	} <span class="keyword">while</span> ( m );

	<span class="keyword">if</span> ( parts.length > <span class="number">1</span> &amp;&amp; origPOS.exec( selector ) ) {

		<span class="keyword">if</span> ( parts.length === <span class="number">2</span> &amp;&amp; Expr.relative[ parts[<span class="number">0</span>] ] ) {
			set = posProcess( parts[<span class="number">0</span>] + parts[<span class="number">1</span>], context, seed );

		} <span class="keyword">else</span> {
			set = Expr.relative[ parts[<span class="number">0</span>] ] ?
				[ context ] :
				Sizzle( parts.shift(), context );

			<span class="keyword">while</span> ( parts.length ) {
				selector = parts.shift();

				<span class="keyword">if</span> ( Expr.relative[ selector ] ) {
					selector += parts.shift();
				}

				set = posProcess( selector, set, seed );
			}
		}

	} <span class="keyword">else</span> {
		<span class="comment">// Take a shortcut and set the context if the root selector is an ID</span>
		<span class="comment">// (but not if it'll be faster if the inner selector is an ID)</span>
		<span class="keyword">if</span> ( !seed &amp;&amp; parts.length > <span class="number">1</span> &amp;&amp; context.nodeType === <span class="number">9</span> &amp;&amp; !contextXML &amp;&amp;
				Expr.match.ID.test(parts[<span class="number">0</span>]) &amp;&amp; !Expr.match.ID.test(parts[parts.length - <span class="number">1</span>]) ) {

			ret = Sizzle.find( parts.shift(), context, contextXML );
			context = ret.expr ?
				Sizzle.filter( ret.expr, ret.set )[<span class="number">0</span>] :
				ret.set[<span class="number">0</span>];
		}

		<span class="keyword">if</span> ( context ) {
			ret = seed ?
				{ expr: parts.pop(), set: makeArray(seed) } :
				Sizzle.find( parts.pop(), parts.length === <span class="number">1</span> &amp;&amp; (parts[<span class="number">0</span>] === <span class="string">"~"</span> || parts[<span class="number">0</span>] === <span class="string">"+"</span>) &amp;&amp; context.parentNode ? context.parentNode : context, contextXML );

			set = ret.expr ?
				Sizzle.filter( ret.expr, ret.set ) :
				ret.set;

			<span class="keyword">if</span> ( parts.length > <span class="number">0</span> ) {
				checkSet = makeArray( set );

			} <span class="keyword">else</span> {
				prune = <span class="literal">false</span>;
			}

			<span class="keyword">while</span> ( parts.length ) {
				cur = parts.pop();
				pop = cur;

				<span class="keyword">if</span> ( !Expr.relative[ cur ] ) {
					cur = <span class="string">""</span>;
				} <span class="keyword">else</span> {
					pop = parts.pop();
				}

				<span class="keyword">if</span> ( pop == <span class="literal">null</span> ) {
					pop = context;
				}

				Expr.relative[ cur ]( checkSet, pop, contextXML );
			}

		} <span class="keyword">else</span> {
			checkSet = parts = [];
		}
	}

	<span class="keyword">if</span> ( !checkSet ) {
		checkSet = set;
	}

	<span class="keyword">if</span> ( !checkSet ) {
		Sizzle.error( cur || selector );
	}

	<span class="keyword">if</span> ( toString.call(checkSet) === <span class="string">"[object Array]"</span> ) {
		<span class="keyword">if</span> ( !prune ) {
			results.push.apply( results, checkSet );

		} <span class="keyword">else</span> <span class="keyword">if</span> ( context &amp;&amp; context.nodeType === <span class="number">1</span> ) {
			<span class="keyword">for</span> ( i = <span class="number">0</span>; checkSet[i] != <span class="literal">null</span>; i++ ) {
				<span class="keyword">if</span> ( checkSet[i] &amp;&amp; (checkSet[i] === <span class="literal">true</span> || checkSet[i].nodeType === <span class="number">1</span> &amp;&amp; Sizzle.contains(context, checkSet[i])) ) {
					results.push( set[i] );
				}
			}

		} <span class="keyword">else</span> {
			<span class="keyword">for</span> ( i = <span class="number">0</span>; checkSet[i] != <span class="literal">null</span>; i++ ) {
				<span class="keyword">if</span> ( checkSet[i] &amp;&amp; checkSet[i].nodeType === <span class="number">1</span> ) {
					results.push( set[i] );
				}
			}
		}

	} <span class="keyword">else</span> {
		makeArray( checkSet, results );
	}

	<span class="keyword">if</span> ( extra ) {
		Sizzle( extra, origContext, results, seed );
		Sizzle.uniqueSort( results );
	}

	<span class="keyword">return</span> results;
};

Sizzle.uniqueSort = <span class="keyword">function</span>( results ) {
	<span class="keyword">if</span> ( sortOrder ) {
		hasDuplicate = baseHasDuplicate;
		results.sort( sortOrder );

		<span class="keyword">if</span> ( hasDuplicate ) {
			<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">1</span>; i &lt; results.length; i++ ) {
				<span class="keyword">if</span> ( results[i] === results[ i - <span class="number">1</span> ] ) {
					results.splice( i--, <span class="number">1</span> );
				}
			}
		}
	}

	<span class="keyword">return</span> results;
};

Sizzle.matches = <span class="keyword">function</span>( expr, set ) {
	<span class="keyword">return</span> Sizzle( expr, <span class="literal">null</span>, <span class="literal">null</span>, set );
};

Sizzle.matchesSelector = <span class="keyword">function</span>( node, expr ) {
	<span class="keyword">return</span> Sizzle( expr, <span class="literal">null</span>, <span class="literal">null</span>, [node] ).length > <span class="number">0</span>;
};

Sizzle.find = <span class="keyword">function</span>( expr, context, isXML ) {
	<span class="keyword">var</span> set, i, len, match, type, left;

	<span class="keyword">if</span> ( !expr ) {
		<span class="keyword">return</span> [];
	}

	<span class="keyword">for</span> ( i = <span class="number">0</span>, len = Expr.order.length; i &lt; len; i++ ) {
		type = Expr.order[i];

		<span class="keyword">if</span> ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
			left = match[<span class="number">1</span>];
			match.splice( <span class="number">1</span>, <span class="number">1</span> );

			<span class="keyword">if</span> ( left.substr( left.length - <span class="number">1</span> ) !== <span class="string">"\\"</span> ) {
				match[<span class="number">1</span>] = (match[<span class="number">1</span>] || <span class="string">""</span>).replace( rBackslash, <span class="string">""</span> );
				set = Expr.find[ type ]( match, context, isXML );

				<span class="keyword">if</span> ( set != <span class="literal">null</span> ) {
					expr = expr.replace( Expr.match[ type ], <span class="string">""</span> );
					<span class="keyword">break</span>;
				}
			}
		}
	}

	<span class="keyword">if</span> ( !set ) {
		set = <span class="keyword">typeof</span> context.getElementsByTagName !== <span class="string">"undefined"</span> ?
			context.getElementsByTagName( <span class="string">"*"</span> ) :
			[];
	}

	<span class="keyword">return</span> { set: set, expr: expr };
};

Sizzle.filter = <span class="keyword">function</span>( expr, set, inplace, not ) {
	<span class="keyword">var</span> match, anyFound,
		type, found, item, filter, left,
		i, pass,
		old = expr,
		result = [],
		curLoop = set,
		isXMLFilter = set &amp;&amp; set[<span class="number">0</span>] &amp;&amp; Sizzle.isXML( set[<span class="number">0</span>] );

	<span class="keyword">while</span> ( expr &amp;&amp; set.length ) {
		<span class="keyword">for</span> ( type <span class="keyword">in</span> Expr.filter ) {
			<span class="keyword">if</span> ( (match = Expr.leftMatch[ type ].exec( expr )) != <span class="literal">null</span> &amp;&amp; match[<span class="number">2</span>] ) {
				filter = Expr.filter[ type ];
				left = match[<span class="number">1</span>];

				anyFound = <span class="literal">false</span>;

				match.splice(<span class="number">1</span>,<span class="number">1</span>);

				<span class="keyword">if</span> ( left.substr( left.length - <span class="number">1</span> ) === <span class="string">"\\"</span> ) {
					<span class="keyword">continue</span>;
				}

				<span class="keyword">if</span> ( curLoop === result ) {
					result = [];
				}

				<span class="keyword">if</span> ( Expr.preFilter[ type ] ) {
					match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );

					<span class="keyword">if</span> ( !match ) {
						anyFound = found = <span class="literal">true</span>;

					} <span class="keyword">else</span> <span class="keyword">if</span> ( match === <span class="literal">true</span> ) {
						<span class="keyword">continue</span>;
					}
				}

				<span class="keyword">if</span> ( match ) {
					<span class="keyword">for</span> ( i = <span class="number">0</span>; (item = curLoop[i]) != <span class="literal">null</span>; i++ ) {
						<span class="keyword">if</span> ( item ) {
							found = filter( item, match, i, curLoop );
							pass = not ^ found;

							<span class="keyword">if</span> ( inplace &amp;&amp; found != <span class="literal">null</span> ) {
								<span class="keyword">if</span> ( pass ) {
									anyFound = <span class="literal">true</span>;

								} <span class="keyword">else</span> {
									curLoop[i] = <span class="literal">false</span>;
								}

							} <span class="keyword">else</span> <span class="keyword">if</span> ( pass ) {
								result.push( item );
								anyFound = <span class="literal">true</span>;
							}
						}
					}
				}

				<span class="keyword">if</span> ( found !== <span class="literal">undefined</span> ) {
					<span class="keyword">if</span> ( !inplace ) {
						curLoop = result;
					}

					expr = expr.replace( Expr.match[ type ], <span class="string">""</span> );

					<span class="keyword">if</span> ( !anyFound ) {
						<span class="keyword">return</span> [];
					}

					<span class="keyword">break</span>;
				}
			}
		}

		<span class="comment">// Improper expression</span>
		<span class="keyword">if</span> ( expr === old ) {
			<span class="keyword">if</span> ( anyFound == <span class="literal">null</span> ) {
				Sizzle.error( expr );

			} <span class="keyword">else</span> {
				<span class="keyword">break</span>;
			}
		}

		old = expr;
	}

	<span class="keyword">return</span> curLoop;
};

Sizzle.error = <span class="keyword">function</span>( msg ) {
	<span class="keyword">throw</span> <span class="keyword">new</span> Error( <span class="string">"Syntax error, unrecognized expression: "</span> + msg );
};

<span class="comment">/**
 * Utility function for retreiving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */</span>
<span class="keyword">var</span> getText = Sizzle.getText = <span class="keyword">function</span>( elem ) {
    <span class="keyword">var</span> i, node,
		nodeType = elem.nodeType,
		ret = <span class="string">""</span>;

	<span class="keyword">if</span> ( nodeType ) {
		<span class="keyword">if</span> ( nodeType === <span class="number">1</span> || nodeType === <span class="number">9</span> || nodeType === <span class="number">11</span> ) {
			<span class="comment">// Use textContent || innerText for elements</span>
			<span class="keyword">if</span> ( <span class="keyword">typeof</span> elem.textContent === <span class="string">'string'</span> ) {
				<span class="keyword">return</span> elem.textContent;
			} <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="keyword">typeof</span> elem.innerText === <span class="string">'string'</span> ) {
				<span class="comment">// Replace IE's carriage returns</span>
				<span class="keyword">return</span> elem.innerText.replace( rReturn, <span class="string">''</span> );
			} <span class="keyword">else</span> {
				<span class="comment">// Traverse it's children</span>
				<span class="keyword">for</span> ( elem = elem.firstChild; elem; elem = elem.nextSibling) {
					ret += getText( elem );
				}
			}
		} <span class="keyword">else</span> <span class="keyword">if</span> ( nodeType === <span class="number">3</span> || nodeType === <span class="number">4</span> ) {
			<span class="keyword">return</span> elem.nodeValue;
		}
	} <span class="keyword">else</span> {

		<span class="comment">// If no nodeType, this is expected to be an array</span>
		<span class="keyword">for</span> ( i = <span class="number">0</span>; (node = elem[i]); i++ ) {
			<span class="comment">// Do not traverse comment nodes</span>
			<span class="keyword">if</span> ( node.nodeType !== <span class="number">8</span> ) {
				ret += getText( node );
			}
		}
	}
	<span class="keyword">return</span> ret;
};

<span class="keyword">var</span> Expr = Sizzle.selectors = {
	order: [ <span class="string">"ID"</span>, <span class="string">"NAME"</span>, <span class="string">"TAG"</span> ],

	match: {
		ID: <span class="regexp">/#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/</span>,
		CLASS: <span class="regexp">/\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/</span>,
		NAME: <span class="regexp">/\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/</span>,
		ATTR: <span class="regexp">/\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/</span>,
		TAG: <span class="regexp">/^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/</span>,
		CHILD: <span class="regexp">/:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/</span>,
		POS: <span class="regexp">/:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/</span>,
		PSEUDO: <span class="regexp">/:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/</span>
	},

	leftMatch: {},

	attrMap: {
		<span class="string">"class"</span>: <span class="string">"className"</span>,
		<span class="string">"for"</span>: <span class="string">"htmlFor"</span>
	},

	attrHandle: {
		href: <span class="keyword">function</span>( elem ) {
			<span class="keyword">return</span> elem.getAttribute( <span class="string">"href"</span> );
		},
		type: <span class="keyword">function</span>( elem ) {
			<span class="keyword">return</span> elem.getAttribute( <span class="string">"type"</span> );
		}
	},

	relative: {
		<span class="string">"+"</span>: <span class="keyword">function</span>(checkSet, part){
			<span class="keyword">var</span> isPartStr = <span class="keyword">typeof</span> part === <span class="string">"string"</span>,
				isTag = isPartStr &amp;&amp; !rNonWord.test( part ),
				isPartStrNotTag = isPartStr &amp;&amp; !isTag;

			<span class="keyword">if</span> ( isTag ) {
				part = part.toLowerCase();
			}

			<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, l = checkSet.length, elem; i &lt; l; i++ ) {
				<span class="keyword">if</span> ( (elem = checkSet[i]) ) {
					<span class="keyword">while</span> ( (elem = elem.previousSibling) &amp;&amp; elem.nodeType !== <span class="number">1</span> ) {}

					checkSet[i] = isPartStrNotTag || elem &amp;&amp; elem.nodeName.toLowerCase() === part ?
						elem || <span class="literal">false</span> :
						elem === part;
				}
			}

			<span class="keyword">if</span> ( isPartStrNotTag ) {
				Sizzle.filter( part, checkSet, <span class="literal">true</span> );
			}
		},

		<span class="string">">"</span>: <span class="keyword">function</span>( checkSet, part ) {
			<span class="keyword">var</span> elem,
				isPartStr = <span class="keyword">typeof</span> part === <span class="string">"string"</span>,
				i = <span class="number">0</span>,
				l = checkSet.length;

			<span class="keyword">if</span> ( isPartStr &amp;&amp; !rNonWord.test( part ) ) {
				part = part.toLowerCase();

				<span class="keyword">for</span> ( ; i &lt; l; i++ ) {
					elem = checkSet[i];

					<span class="keyword">if</span> ( elem ) {
						<span class="keyword">var</span> parent = elem.parentNode;
						checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : <span class="literal">false</span>;
					}
				}

			} <span class="keyword">else</span> {
				<span class="keyword">for</span> ( ; i &lt; l; i++ ) {
					elem = checkSet[i];

					<span class="keyword">if</span> ( elem ) {
						checkSet[i] = isPartStr ?
							elem.parentNode :
							elem.parentNode === part;
					}
				}

				<span class="keyword">if</span> ( isPartStr ) {
					Sizzle.filter( part, checkSet, <span class="literal">true</span> );
				}
			}
		},

		<span class="string">""</span>: <span class="keyword">function</span>(checkSet, part, isXML){
			<span class="keyword">var</span> nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			<span class="keyword">if</span> ( <span class="keyword">typeof</span> part === <span class="string">"string"</span> &amp;&amp; !rNonWord.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( <span class="string">"parentNode"</span>, part, doneName, checkSet, nodeCheck, isXML );
		},

		<span class="string">"~"</span>: <span class="keyword">function</span>( checkSet, part, isXML ) {
			<span class="keyword">var</span> nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			<span class="keyword">if</span> ( <span class="keyword">typeof</span> part === <span class="string">"string"</span> &amp;&amp; !rNonWord.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( <span class="string">"previousSibling"</span>, part, doneName, checkSet, nodeCheck, isXML );
		}
	},

	find: {
		ID: <span class="keyword">function</span>( match, context, isXML ) {
			<span class="keyword">if</span> ( <span class="keyword">typeof</span> context.getElementById !== <span class="string">"undefined"</span> &amp;&amp; !isXML ) {
				<span class="keyword">var</span> m = context.getElementById(match[<span class="number">1</span>]);
				<span class="comment">// Check parentNode to catch when Blackberry 4.6 returns</span>
				<span class="comment">// nodes that are no longer in the document #6963</span>
				<span class="keyword">return</span> m &amp;&amp; m.parentNode ? [m] : [];
			}
		},

		NAME: <span class="keyword">function</span>( match, context ) {
			<span class="keyword">if</span> ( <span class="keyword">typeof</span> context.getElementsByName !== <span class="string">"undefined"</span> ) {
				<span class="keyword">var</span> ret = [],
					results = context.getElementsByName( match[<span class="number">1</span>] );

				<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, l = results.length; i &lt; l; i++ ) {
					<span class="keyword">if</span> ( results[i].getAttribute(<span class="string">"name"</span>) === match[<span class="number">1</span>] ) {
						ret.push( results[i] );
					}
				}

				<span class="keyword">return</span> ret.length === <span class="number">0</span> ? <span class="literal">null</span> : ret;
			}
		},

		TAG: <span class="keyword">function</span>( match, context ) {
			<span class="keyword">if</span> ( <span class="keyword">typeof</span> context.getElementsByTagName !== <span class="string">"undefined"</span> ) {
				<span class="keyword">return</span> context.getElementsByTagName( match[<span class="number">1</span>] );
			}
		}
	},
	preFilter: {
		CLASS: <span class="keyword">function</span>( match, curLoop, inplace, result, not, isXML ) {
			match = <span class="string">" "</span> + match[<span class="number">1</span>].replace( rBackslash, <span class="string">""</span> ) + <span class="string">" "</span>;

			<span class="keyword">if</span> ( isXML ) {
				<span class="keyword">return</span> match;
			}

			<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, elem; (elem = curLoop[i]) != <span class="literal">null</span>; i++ ) {
				<span class="keyword">if</span> ( elem ) {
					<span class="keyword">if</span> ( not ^ (elem.className &amp;&amp; (<span class="string">" "</span> + elem.className + <span class="string">" "</span>).replace(<span class="regexp">/[\t\n\r]/g</span>, <span class="string">" "</span>).indexOf(match) >= <span class="number">0</span>) ) {
						<span class="keyword">if</span> ( !inplace ) {
							result.push( elem );
						}

					} <span class="keyword">else</span> <span class="keyword">if</span> ( inplace ) {
						curLoop[i] = <span class="literal">false</span>;
					}
				}
			}

			<span class="keyword">return</span> <span class="literal">false</span>;
		},

		ID: <span class="keyword">function</span>( match ) {
			<span class="keyword">return</span> match[<span class="number">1</span>].replace( rBackslash, <span class="string">""</span> );
		},

		TAG: <span class="keyword">function</span>( match, curLoop ) {
			<span class="keyword">return</span> match[<span class="number">1</span>].replace( rBackslash, <span class="string">""</span> ).toLowerCase();
		},

		CHILD: <span class="keyword">function</span>( match ) {
			<span class="keyword">if</span> ( match[<span class="number">1</span>] === <span class="string">"nth"</span> ) {
				<span class="keyword">if</span> ( !match[<span class="number">2</span>] ) {
					Sizzle.error( match[<span class="number">0</span>] );
				}

				match[<span class="number">2</span>] = match[<span class="number">2</span>].replace(<span class="regexp">/^\+|\s*/g</span>, <span class="string">''</span>);

				<span class="comment">// parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'</span>
				<span class="keyword">var</span> test = <span class="regexp">/(-?)(\d*)(?:n([+\-]?\d*))?/</span>.exec(
					match[<span class="number">2</span>] === <span class="string">"even"</span> &amp;&amp; <span class="string">"2n"</span> || match[<span class="number">2</span>] === <span class="string">"odd"</span> &amp;&amp; <span class="string">"2n+1"</span> ||
					!<span class="regexp">/\D/</span>.test( match[<span class="number">2</span>] ) &amp;&amp; <span class="string">"0n+"</span> + match[<span class="number">2</span>] || match[<span class="number">2</span>]);

				<span class="comment">// calculate the numbers (first)n+(last) including if they are negative</span>
				match[<span class="number">2</span>] = (test[<span class="number">1</span>] + (test[<span class="number">2</span>] || <span class="number">1</span>)) - <span class="number">0</span>;
				match[<span class="number">3</span>] = test[<span class="number">3</span>] - <span class="number">0</span>;
			}
			<span class="keyword">else</span> <span class="keyword">if</span> ( match[<span class="number">2</span>] ) {
				Sizzle.error( match[<span class="number">0</span>] );
			}

			<span class="comment">// TODO: Move to normal caching system</span>
			match[<span class="number">0</span>] = done++;

			<span class="keyword">return</span> match;
		},

		ATTR: <span class="keyword">function</span>( match, curLoop, inplace, result, not, isXML ) {
			<span class="keyword">var</span> name = match[<span class="number">1</span>] = match[<span class="number">1</span>].replace( rBackslash, <span class="string">""</span> );

			<span class="keyword">if</span> ( !isXML &amp;&amp; Expr.attrMap[name] ) {
				match[<span class="number">1</span>] = Expr.attrMap[name];
			}

			<span class="comment">// Handle if an un-quoted value was used</span>
			match[<span class="number">4</span>] = ( match[<span class="number">4</span>] || match[<span class="number">5</span>] || <span class="string">""</span> ).replace( rBackslash, <span class="string">""</span> );

			<span class="keyword">if</span> ( match[<span class="number">2</span>] === <span class="string">"~="</span> ) {
				match[<span class="number">4</span>] = <span class="string">" "</span> + match[<span class="number">4</span>] + <span class="string">" "</span>;
			}

			<span class="keyword">return</span> match;
		},

		PSEUDO: <span class="keyword">function</span>( match, curLoop, inplace, result, not ) {
			<span class="keyword">if</span> ( match[<span class="number">1</span>] === <span class="string">"not"</span> ) {
				<span class="comment">// If we're dealing with a complex expression, or a simple one</span>
				<span class="keyword">if</span> ( ( chunker.exec(match[<span class="number">3</span>]) || <span class="string">""</span> ).length > <span class="number">1</span> || <span class="regexp">/^\w/</span>.test(match[<span class="number">3</span>]) ) {
					match[<span class="number">3</span>] = Sizzle(match[<span class="number">3</span>], <span class="literal">null</span>, <span class="literal">null</span>, curLoop);

				} <span class="keyword">else</span> {
					<span class="keyword">var</span> ret = Sizzle.filter(match[<span class="number">3</span>], curLoop, inplace, <span class="literal">true</span> ^ not);

					<span class="keyword">if</span> ( !inplace ) {
						result.push.apply( result, ret );
					}

					<span class="keyword">return</span> <span class="literal">false</span>;
				}

			} <span class="keyword">else</span> <span class="keyword">if</span> ( Expr.match.POS.test( match[<span class="number">0</span>] ) || Expr.match.CHILD.test( match[<span class="number">0</span>] ) ) {
				<span class="keyword">return</span> <span class="literal">true</span>;
			}

			<span class="keyword">return</span> match;
		},

		POS: <span class="keyword">function</span>( match ) {
			match.unshift( <span class="literal">true</span> );

			<span class="keyword">return</span> match;
		}
	},

	filters: {
		enabled: <span class="keyword">function</span>( elem ) {
			<span class="keyword">return</span> elem.disabled === <span class="literal">false</span> &amp;&amp; elem.type !== <span class="string">"hidden"</span>;
		},

		disabled: <span class="keyword">function</span>( elem ) {
			<span class="keyword">return</span> elem.disabled === <span class="literal">true</span>;
		},

		checked: <span class="keyword">function</span>( elem ) {
			<span class="keyword">return</span> elem.checked === <span class="literal">true</span>;
		},

		selected: <span class="keyword">function</span>( elem ) {
			<span class="comment">// Accessing this property makes selected-by-default</span>
			<span class="comment">// options in Safari work properly</span>
			<span class="keyword">if</span> ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			<span class="keyword">return</span> elem.selected === <span class="literal">true</span>;
		},

		parent: <span class="keyword">function</span>( elem ) {
			<span class="keyword">return</span> !!elem.firstChild;
		},

		empty: <span class="keyword">function</span>( elem ) {
			<span class="keyword">return</span> !elem.firstChild;
		},

		has: <span class="keyword">function</span>( elem, i, match ) {
			<span class="keyword">return</span> !!Sizzle( match[<span class="number">3</span>], elem ).length;
		},

		header: <span class="keyword">function</span>( elem ) {
			<span class="keyword">return</span> (<span class="regexp">/h\d/i</span>).test( elem.nodeName );
		},

		text: <span class="keyword">function</span>( elem ) {
			<span class="keyword">var</span> attr = elem.getAttribute( <span class="string">"type"</span> ), type = elem.type;
			<span class="comment">// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)</span>
			<span class="comment">// use getAttribute instead to test this case</span>
			<span class="keyword">return</span> elem.nodeName.toLowerCase() === <span class="string">"input"</span> &amp;&amp; <span class="string">"text"</span> === type &amp;&amp; ( attr === type || attr === <span class="literal">null</span> );
		},

		radio: <span class="keyword">function</span>( elem ) {
			<span class="keyword">return</span> elem.nodeName.toLowerCase() === <span class="string">"input"</span> &amp;&amp; <span class="string">"radio"</span> === elem.type;
		},

		checkbox: <span class="keyword">function</span>( elem ) {
			<span class="keyword">return</span> elem.nodeName.toLowerCase() === <span class="string">"input"</span> &amp;&amp; <span class="string">"checkbox"</span> === elem.type;
		},

		file: <span class="keyword">function</span>( elem ) {
			<span class="keyword">return</span> elem.nodeName.toLowerCase() === <span class="string">"input"</span> &amp;&amp; <span class="string">"file"</span> === elem.type;
		},

		password: <span class="keyword">function</span>( elem ) {
			<span class="keyword">return</span> elem.nodeName.toLowerCase() === <span class="string">"input"</span> &amp;&amp; <span class="string">"password"</span> === elem.type;
		},

		submit: <span class="keyword">function</span>( elem ) {
			<span class="keyword">var</span> name = elem.nodeName.toLowerCase();
			<span class="keyword">return</span> (name === <span class="string">"input"</span> || name === <span class="string">"button"</span>) &amp;&amp; <span class="string">"submit"</span> === elem.type;
		},

		image: <span class="keyword">function</span>( elem ) {
			<span class="keyword">return</span> elem.nodeName.toLowerCase() === <span class="string">"input"</span> &amp;&amp; <span class="string">"image"</span> === elem.type;
		},

		reset: <span class="keyword">function</span>( elem ) {
			<span class="keyword">var</span> name = elem.nodeName.toLowerCase();
			<span class="keyword">return</span> (name === <span class="string">"input"</span> || name === <span class="string">"button"</span>) &amp;&amp; <span class="string">"reset"</span> === elem.type;
		},

		button: <span class="keyword">function</span>( elem ) {
			<span class="keyword">var</span> name = elem.nodeName.toLowerCase();
			<span class="keyword">return</span> name === <span class="string">"input"</span> &amp;&amp; <span class="string">"button"</span> === elem.type || name === <span class="string">"button"</span>;
		},

		input: <span class="keyword">function</span>( elem ) {
			<span class="keyword">return</span> (<span class="regexp">/input|select|textarea|button/i</span>).test( elem.nodeName );
		},

		focus: <span class="keyword">function</span>( elem ) {
			<span class="keyword">return</span> elem === elem.ownerDocument.activeElement;
		}
	},
	setFilters: {
		first: <span class="keyword">function</span>( elem, i ) {
			<span class="keyword">return</span> i === <span class="number">0</span>;
		},

		last: <span class="keyword">function</span>( elem, i, match, array ) {
			<span class="keyword">return</span> i === array.length - <span class="number">1</span>;
		},

		even: <span class="keyword">function</span>( elem, i ) {
			<span class="keyword">return</span> i % <span class="number">2</span> === <span class="number">0</span>;
		},

		odd: <span class="keyword">function</span>( elem, i ) {
			<span class="keyword">return</span> i % <span class="number">2</span> === <span class="number">1</span>;
		},

		lt: <span class="keyword">function</span>( elem, i, match ) {
			<span class="keyword">return</span> i &lt; match[<span class="number">3</span>] - <span class="number">0</span>;
		},

		gt: <span class="keyword">function</span>( elem, i, match ) {
			<span class="keyword">return</span> i > match[<span class="number">3</span>] - <span class="number">0</span>;
		},

		nth: <span class="keyword">function</span>( elem, i, match ) {
			<span class="keyword">return</span> match[<span class="number">3</span>] - <span class="number">0</span> === i;
		},

		eq: <span class="keyword">function</span>( elem, i, match ) {
			<span class="keyword">return</span> match[<span class="number">3</span>] - <span class="number">0</span> === i;
		}
	},
	filter: {
		PSEUDO: <span class="keyword">function</span>( elem, match, i, array ) {
			<span class="keyword">var</span> name = match[<span class="number">1</span>],
				filter = Expr.filters[ name ];

			<span class="keyword">if</span> ( filter ) {
				<span class="keyword">return</span> filter( elem, i, match, array );

			} <span class="keyword">else</span> <span class="keyword">if</span> ( name === <span class="string">"contains"</span> ) {
				<span class="keyword">return</span> (elem.textContent || elem.innerText || getText([ elem ]) || <span class="string">""</span>).indexOf(match[<span class="number">3</span>]) >= <span class="number">0</span>;

			} <span class="keyword">else</span> <span class="keyword">if</span> ( name === <span class="string">"not"</span> ) {
				<span class="keyword">var</span> not = match[<span class="number">3</span>];

				<span class="keyword">for</span> ( <span class="keyword">var</span> j = <span class="number">0</span>, l = not.length; j &lt; l; j++ ) {
					<span class="keyword">if</span> ( not[j] === elem ) {
						<span class="keyword">return</span> <span class="literal">false</span>;
					}
				}

				<span class="keyword">return</span> <span class="literal">true</span>;

			} <span class="keyword">else</span> {
				Sizzle.error( name );
			}
		},

		CHILD: <span class="keyword">function</span>( elem, match ) {
			<span class="keyword">var</span> first, last,
				doneName, parent, cache,
				count, diff,
				type = match[<span class="number">1</span>],
				node = elem;

			<span class="keyword">switch</span> ( type ) {
				<span class="keyword">case</span> <span class="string">"only"</span>:
				<span class="keyword">case</span> <span class="string">"first"</span>:
					<span class="keyword">while</span> ( (node = node.previousSibling) ) {
						<span class="keyword">if</span> ( node.nodeType === <span class="number">1</span> ) {
							<span class="keyword">return</span> <span class="literal">false</span>;
						}
					}

					<span class="keyword">if</span> ( type === <span class="string">"first"</span> ) {
						<span class="keyword">return</span> <span class="literal">true</span>;
					}

					node = elem;

					<span class="comment">/* falls through */</span>
				<span class="keyword">case</span> <span class="string">"last"</span>:
					<span class="keyword">while</span> ( (node = node.nextSibling) ) {
						<span class="keyword">if</span> ( node.nodeType === <span class="number">1</span> ) {
							<span class="keyword">return</span> <span class="literal">false</span>;
						}
					}

					<span class="keyword">return</span> <span class="literal">true</span>;

				<span class="keyword">case</span> <span class="string">"nth"</span>:
					first = match[<span class="number">2</span>];
					last = match[<span class="number">3</span>];

					<span class="keyword">if</span> ( first === <span class="number">1</span> &amp;&amp; last === <span class="number">0</span> ) {
						<span class="keyword">return</span> <span class="literal">true</span>;
					}

					doneName = match[<span class="number">0</span>];
					parent = elem.parentNode;

					<span class="keyword">if</span> ( parent &amp;&amp; (parent[ expando ] !== doneName || !elem.nodeIndex) ) {
						count = <span class="number">0</span>;

						<span class="keyword">for</span> ( node = parent.firstChild; node; node = node.nextSibling ) {
							<span class="keyword">if</span> ( node.nodeType === <span class="number">1</span> ) {
								node.nodeIndex = ++count;
							}
						}

						parent[ expando ] = doneName;
					}

					diff = elem.nodeIndex - last;

					<span class="keyword">if</span> ( first === <span class="number">0</span> ) {
						<span class="keyword">return</span> diff === <span class="number">0</span>;

					} <span class="keyword">else</span> {
						<span class="keyword">return</span> ( diff % first === <span class="number">0</span> &amp;&amp; diff / first >= <span class="number">0</span> );
					}
			}
		},

		ID: <span class="keyword">function</span>( elem, match ) {
			<span class="keyword">return</span> elem.nodeType === <span class="number">1</span> &amp;&amp; elem.getAttribute(<span class="string">"id"</span>) === match;
		},

		TAG: <span class="keyword">function</span>( elem, match ) {
			<span class="keyword">return</span> (match === <span class="string">"*"</span> &amp;&amp; elem.nodeType === <span class="number">1</span>) || !!elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === match;
		},

		CLASS: <span class="keyword">function</span>( elem, match ) {
			<span class="keyword">return</span> (<span class="string">" "</span> + (elem.className || elem.getAttribute(<span class="string">"class"</span>)) + <span class="string">" "</span>)
				.indexOf( match ) > -<span class="number">1</span>;
		},

		ATTR: <span class="keyword">function</span>( elem, match ) {
			<span class="keyword">var</span> name = match[<span class="number">1</span>],
				result = Sizzle.attr ?
					Sizzle.attr( elem, name ) :
					Expr.attrHandle[ name ] ?
					Expr.attrHandle[ name ]( elem ) :
					elem[ name ] != <span class="literal">null</span> ?
						elem[ name ] :
						elem.getAttribute( name ),
				value = result + <span class="string">""</span>,
				type = match[<span class="number">2</span>],
				check = match[<span class="number">4</span>];

			<span class="keyword">return</span> result == <span class="literal">null</span> ?
				type === <span class="string">"!="</span> :
				!type &amp;&amp; Sizzle.attr ?
				result != <span class="literal">null</span> :
				type === <span class="string">"="</span> ?
				value === check :
				type === <span class="string">"*="</span> ?
				value.indexOf(check) >= <span class="number">0</span> :
				type === <span class="string">"~="</span> ?
				(<span class="string">" "</span> + value + <span class="string">" "</span>).indexOf(check) >= <span class="number">0</span> :
				!check ?
				value &amp;&amp; result !== <span class="literal">false</span> :
				type === <span class="string">"!="</span> ?
				value !== check :
				type === <span class="string">"^="</span> ?
				value.indexOf(check) === <span class="number">0</span> :
				type === <span class="string">"$="</span> ?
				value.substr(value.length - check.length) === check :
				type === <span class="string">"|="</span> ?
				value === check || value.substr(<span class="number">0</span>, check.length + <span class="number">1</span>) === check + <span class="string">"-"</span> :
				<span class="literal">false</span>;
		},

		POS: <span class="keyword">function</span>( elem, match, i, array ) {
			<span class="keyword">var</span> name = match[<span class="number">2</span>],
				filter = Expr.setFilters[ name ];

			<span class="keyword">if</span> ( filter ) {
				<span class="keyword">return</span> filter( elem, i, match, array );
			}
		}
	}
};

<span class="keyword">var</span> origPOS = Expr.match.POS,
	fescape = <span class="keyword">function</span>(all, num){
		<span class="keyword">return</span> <span class="string">"\\"</span> + (num - <span class="number">0</span> + <span class="number">1</span>);
	};

<span class="keyword">for</span> ( <span class="keyword">var</span> type <span class="keyword">in</span> Expr.match ) {
	Expr.match[ type ] = <span class="keyword">new</span> RegExp( Expr.match[ type ].source + (<span class="regexp">/(?![^\[]*\])(?![^\(]*\))/</span>.source) );
	Expr.leftMatch[ type ] = <span class="keyword">new</span> RegExp( <span class="regexp">/(^(?:.|\r|\n)*?)/</span>.source + Expr.match[ type ].source.replace(<span class="regexp">/\\(\d+)/g</span>, fescape) );
}
<span class="comment">// Expose origPOS</span>
<span class="comment">// "global" as in regardless of relation to brackets/parens</span>
Expr.match.globalPOS = origPOS;

<span class="keyword">var</span> makeArray = <span class="keyword">function</span>( array, results ) {
	array = Array.prototype.slice.call( array, <span class="number">0</span> );

	<span class="keyword">if</span> ( results ) {
		results.push.apply( results, array );
		<span class="keyword">return</span> results;
	}

	<span class="keyword">return</span> array;
};

<span class="comment">// Perform a simple check to determine if the browser is capable of</span>
<span class="comment">// converting a NodeList to an array using builtin methods.</span>
<span class="comment">// Also verifies that the returned array holds DOM nodes</span>
<span class="comment">// (which is not the case in the Blackberry browser)</span>
<span class="keyword">try</span> {
	Array.prototype.slice.call( document.documentElement.childNodes, <span class="number">0</span> )[<span class="number">0</span>].nodeType;

<span class="comment">// Provide a fallback method if it does not work</span>
} <span class="keyword">catch</span>( e ) {
	makeArray = <span class="keyword">function</span>( array, results ) {
		<span class="keyword">var</span> i = <span class="number">0</span>,
			ret = results || [];

		<span class="keyword">if</span> ( toString.call(array) === <span class="string">"[object Array]"</span> ) {
			Array.prototype.push.apply( ret, array );

		} <span class="keyword">else</span> {
			<span class="keyword">if</span> ( <span class="keyword">typeof</span> array.length === <span class="string">"number"</span> ) {
				<span class="keyword">for</span> ( <span class="keyword">var</span> l = array.length; i &lt; l; i++ ) {
					ret.push( array[i] );
				}

			} <span class="keyword">else</span> {
				<span class="keyword">for</span> ( ; array[i]; i++ ) {
					ret.push( array[i] );
				}
			}
		}

		<span class="keyword">return</span> ret;
	};
}

<span class="keyword">var</span> sortOrder, siblingCheck;

<span class="keyword">if</span> ( document.documentElement.compareDocumentPosition ) {
	sortOrder = <span class="keyword">function</span>( a, b ) {
		<span class="keyword">if</span> ( a === b ) {
			hasDuplicate = <span class="literal">true</span>;
			<span class="keyword">return</span> <span class="number">0</span>;
		}

		<span class="keyword">if</span> ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {
			<span class="keyword">return</span> a.compareDocumentPosition ? -<span class="number">1</span> : <span class="number">1</span>;
		}

		<span class="keyword">return</span> a.compareDocumentPosition(b) &amp; <span class="number">4</span> ? -<span class="number">1</span> : <span class="number">1</span>;
	};

} <span class="keyword">else</span> {
	sortOrder = <span class="keyword">function</span>( a, b ) {
		<span class="comment">// The nodes are identical, we can exit early</span>
		<span class="keyword">if</span> ( a === b ) {
			hasDuplicate = <span class="literal">true</span>;
			<span class="keyword">return</span> <span class="number">0</span>;

		<span class="comment">// Fallback to using sourceIndex (in IE) if it's available on both nodes</span>
		} <span class="keyword">else</span> <span class="keyword">if</span> ( a.sourceIndex &amp;&amp; b.sourceIndex ) {
			<span class="keyword">return</span> a.sourceIndex - b.sourceIndex;
		}

		<span class="keyword">var</span> al, bl,
			ap = [],
			bp = [],
			aup = a.parentNode,
			bup = b.parentNode,
			cur = aup;

		<span class="comment">// If the nodes are siblings (or identical) we can do a quick check</span>
		<span class="keyword">if</span> ( aup === bup ) {
			<span class="keyword">return</span> siblingCheck( a, b );

		<span class="comment">// If no parents were found then the nodes are disconnected</span>
		} <span class="keyword">else</span> <span class="keyword">if</span> ( !aup ) {
			<span class="keyword">return</span> -<span class="number">1</span>;

		} <span class="keyword">else</span> <span class="keyword">if</span> ( !bup ) {
			<span class="keyword">return</span> <span class="number">1</span>;
		}

		<span class="comment">// Otherwise they're somewhere else in the tree so we need</span>
		<span class="comment">// to build up a full list of the parentNodes for comparison</span>
		<span class="keyword">while</span> ( cur ) {
			ap.unshift( cur );
			cur = cur.parentNode;
		}

		cur = bup;

		<span class="keyword">while</span> ( cur ) {
			bp.unshift( cur );
			cur = cur.parentNode;
		}

		al = ap.length;
		bl = bp.length;

		<span class="comment">// Start walking down the tree looking for a discrepancy</span>
		<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; al &amp;&amp; i &lt; bl; i++ ) {
			<span class="keyword">if</span> ( ap[i] !== bp[i] ) {
				<span class="keyword">return</span> siblingCheck( ap[i], bp[i] );
			}
		}

		<span class="comment">// We ended someplace up the tree so do a sibling check</span>
		<span class="keyword">return</span> i === al ?
			siblingCheck( a, bp[i], -<span class="number">1</span> ) :
			siblingCheck( ap[i], b, <span class="number">1</span> );
	};

	siblingCheck = <span class="keyword">function</span>( a, b, ret ) {
		<span class="keyword">if</span> ( a === b ) {
			<span class="keyword">return</span> ret;
		}

		<span class="keyword">var</span> cur = a.nextSibling;

		<span class="keyword">while</span> ( cur ) {
			<span class="keyword">if</span> ( cur === b ) {
				<span class="keyword">return</span> -<span class="number">1</span>;
			}

			cur = cur.nextSibling;
		}

		<span class="keyword">return</span> <span class="number">1</span>;
	};
}

<span class="comment">// Check to see if the browser returns elements by name when</span>
<span class="comment">// querying by getElementById (and provide a workaround)</span>
(<span class="keyword">function</span>(){
	<span class="comment">// We're going to inject a fake input element with a specified name</span>
	<span class="keyword">var</span> form = document.createElement(<span class="string">"div"</span>),
		id = <span class="string">"script"</span> + (<span class="keyword">new</span> Date()).getTime(),
		root = document.documentElement;

	form.innerHTML = <span class="string">"&lt;a name='"</span> + id + <span class="string">"'/>"</span>;

	<span class="comment">// Inject it into the root element, check its status, and remove it quickly</span>
	root.insertBefore( form, root.firstChild );

	<span class="comment">// The workaround has to do additional checks after a getElementById</span>
	<span class="comment">// Which slows things down for other browsers (hence the branching)</span>
	<span class="keyword">if</span> ( document.getElementById( id ) ) {
		Expr.find.ID = <span class="keyword">function</span>( match, context, isXML ) {
			<span class="keyword">if</span> ( <span class="keyword">typeof</span> context.getElementById !== <span class="string">"undefined"</span> &amp;&amp; !isXML ) {
				<span class="keyword">var</span> m = context.getElementById(match[<span class="number">1</span>]);

				<span class="keyword">return</span> m ?
					m.id === match[<span class="number">1</span>] || <span class="keyword">typeof</span> m.getAttributeNode !== <span class="string">"undefined"</span> &amp;&amp; m.getAttributeNode(<span class="string">"id"</span>).nodeValue === match[<span class="number">1</span>] ?
						[m] :
						<span class="literal">undefined</span> :
					[];
			}
		};

		Expr.filter.ID = <span class="keyword">function</span>( elem, match ) {
			<span class="keyword">var</span> node = <span class="keyword">typeof</span> elem.getAttributeNode !== <span class="string">"undefined"</span> &amp;&amp; elem.getAttributeNode(<span class="string">"id"</span>);

			<span class="keyword">return</span> elem.nodeType === <span class="number">1</span> &amp;&amp; node &amp;&amp; node.nodeValue === match;
		};
	}

	root.removeChild( form );

	<span class="comment">// release memory in IE</span>
	root = form = <span class="literal">null</span>;
})();

(<span class="keyword">function</span>(){
	<span class="comment">// Check to see if the browser returns only elements</span>
	<span class="comment">// when doing getElementsByTagName("*")</span>

	<span class="comment">// Create a fake element</span>
	<span class="keyword">var</span> div = document.createElement(<span class="string">"div"</span>);
	div.appendChild( document.createComment(<span class="string">""</span>) );

	<span class="comment">// Make sure no comments are found</span>
	<span class="keyword">if</span> ( div.getElementsByTagName(<span class="string">"*"</span>).length > <span class="number">0</span> ) {
		Expr.find.TAG = <span class="keyword">function</span>( match, context ) {
			<span class="keyword">var</span> results = context.getElementsByTagName( match[<span class="number">1</span>] );

			<span class="comment">// Filter out possible comments</span>
			<span class="keyword">if</span> ( match[<span class="number">1</span>] === <span class="string">"*"</span> ) {
				<span class="keyword">var</span> tmp = [];

				<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; results[i]; i++ ) {
					<span class="keyword">if</span> ( results[i].nodeType === <span class="number">1</span> ) {
						tmp.push( results[i] );
					}
				}

				results = tmp;
			}

			<span class="keyword">return</span> results;
		};
	}

	<span class="comment">// Check to see if an attribute returns normalized href attributes</span>
	div.innerHTML = <span class="string">"&lt;a href='#'>&lt;/a>"</span>;

	<span class="keyword">if</span> ( div.firstChild &amp;&amp; <span class="keyword">typeof</span> div.firstChild.getAttribute !== <span class="string">"undefined"</span> &amp;&amp;
			div.firstChild.getAttribute(<span class="string">"href"</span>) !== <span class="string">"#"</span> ) {

		Expr.attrHandle.href = <span class="keyword">function</span>( elem ) {
			<span class="keyword">return</span> elem.getAttribute( <span class="string">"href"</span>, <span class="number">2</span> );
		};
	}

	<span class="comment">// release memory in IE</span>
	div = <span class="literal">null</span>;
})();

<span class="keyword">if</span> ( document.querySelectorAll ) {
	(<span class="keyword">function</span>(){
		<span class="keyword">var</span> oldSizzle = Sizzle,
			div = document.createElement(<span class="string">"div"</span>),
			id = <span class="string">"__sizzle__"</span>;

		div.innerHTML = <span class="string">"&lt;p class='TEST'>&lt;/p>"</span>;

		<span class="comment">// Safari can't handle uppercase or unicode characters when</span>
		<span class="comment">// in quirks mode.</span>
		<span class="keyword">if</span> ( div.querySelectorAll &amp;&amp; div.querySelectorAll(<span class="string">".TEST"</span>).length === <span class="number">0</span> ) {
			<span class="keyword">return</span>;
		}

		Sizzle = <span class="keyword">function</span>( query, context, extra, seed ) {
			context = context || document;

			<span class="comment">// Only use querySelectorAll on non-XML documents</span>
			<span class="comment">// (ID selectors don't work in non-HTML documents)</span>
			<span class="keyword">if</span> ( !seed &amp;&amp; !Sizzle.isXML(context) ) {
				<span class="comment">// See if we find a selector to speed up</span>
				<span class="keyword">var</span> match = <span class="regexp">/^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/</span>.exec( query );

				<span class="keyword">if</span> ( match &amp;&amp; (context.nodeType === <span class="number">1</span> || context.nodeType === <span class="number">9</span>) ) {
					<span class="comment">// Speed-up: Sizzle("TAG")</span>
					<span class="keyword">if</span> ( match[<span class="number">1</span>] ) {
						<span class="keyword">return</span> makeArray( context.getElementsByTagName( query ), extra );

					<span class="comment">// Speed-up: Sizzle(".CLASS")</span>
					} <span class="keyword">else</span> <span class="keyword">if</span> ( match[<span class="number">2</span>] &amp;&amp; Expr.find.CLASS &amp;&amp; context.getElementsByClassName ) {
						<span class="keyword">return</span> makeArray( context.getElementsByClassName( match[<span class="number">2</span>] ), extra );
					}
				}

				<span class="keyword">if</span> ( context.nodeType === <span class="number">9</span> ) {
					<span class="comment">// Speed-up: Sizzle("body")</span>
					<span class="comment">// The body element only exists once, optimize finding it</span>
					<span class="keyword">if</span> ( query === <span class="string">"body"</span> &amp;&amp; context.body ) {
						<span class="keyword">return</span> makeArray( [ context.body ], extra );

					<span class="comment">// Speed-up: Sizzle("#ID")</span>
					} <span class="keyword">else</span> <span class="keyword">if</span> ( match &amp;&amp; match[<span class="number">3</span>] ) {
						<span class="keyword">var</span> elem = context.getElementById( match[<span class="number">3</span>] );

						<span class="comment">// Check parentNode to catch when Blackberry 4.6 returns</span>
						<span class="comment">// nodes that are no longer in the document #6963</span>
						<span class="keyword">if</span> ( elem &amp;&amp; elem.parentNode ) {
							<span class="comment">// Handle the case where IE and Opera return items</span>
							<span class="comment">// by name instead of ID</span>
							<span class="keyword">if</span> ( elem.id === match[<span class="number">3</span>] ) {
								<span class="keyword">return</span> makeArray( [ elem ], extra );
							}

						} <span class="keyword">else</span> {
							<span class="keyword">return</span> makeArray( [], extra );
						}
					}

					<span class="keyword">try</span> {
						<span class="keyword">return</span> makeArray( context.querySelectorAll(query), extra );
					} <span class="keyword">catch</span>(qsaError) {}

				<span class="comment">// qSA works strangely on Element-rooted queries</span>
				<span class="comment">// We can work around this by specifying an extra ID on the root</span>
				<span class="comment">// and working up from there (Thanks to Andrew Dupont for the technique)</span>
				<span class="comment">// IE 8 doesn't work on object elements</span>
				} <span class="keyword">else</span> <span class="keyword">if</span> ( context.nodeType === <span class="number">1</span> &amp;&amp; context.nodeName.toLowerCase() !== <span class="string">"object"</span> ) {
					<span class="keyword">var</span> oldContext = context,
						old = context.getAttribute( <span class="string">"id"</span> ),
						nid = old || id,
						hasParent = context.parentNode,
						relativeHierarchySelector = <span class="regexp">/^\s*[+~]/</span>.test( query );

					<span class="keyword">if</span> ( !old ) {
						context.setAttribute( <span class="string">"id"</span>, nid );
					} <span class="keyword">else</span> {
						nid = nid.replace( <span class="regexp">/'/g</span>, <span class="string">"\\$&amp;"</span> );
					}
					<span class="keyword">if</span> ( relativeHierarchySelector &amp;&amp; hasParent ) {
						context = context.parentNode;
					}

					<span class="keyword">try</span> {
						<span class="keyword">if</span> ( !relativeHierarchySelector || hasParent ) {
							<span class="keyword">return</span> makeArray( context.querySelectorAll( <span class="string">"[id='"</span> + nid + <span class="string">"'] "</span> + query ), extra );
						}

					} <span class="keyword">catch</span>(pseudoError) {
					} <span class="keyword">finally</span> {
						<span class="keyword">if</span> ( !old ) {
							oldContext.removeAttribute( <span class="string">"id"</span> );
						}
					}
				}
			}

			<span class="keyword">return</span> oldSizzle(query, context, extra, seed);
		};

		<span class="keyword">for</span> ( <span class="keyword">var</span> prop <span class="keyword">in</span> oldSizzle ) {
			Sizzle[ prop ] = oldSizzle[ prop ];
		}

		<span class="comment">// release memory in IE</span>
		div = <span class="literal">null</span>;
	})();
}

(<span class="keyword">function</span>(){
	<span class="keyword">var</span> html = document.documentElement,
		matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;

	<span class="keyword">if</span> ( matches ) {
		<span class="comment">// Check to see if it's possible to do matchesSelector</span>
		<span class="comment">// on a disconnected node (IE 9 fails this)</span>
		<span class="keyword">var</span> disconnectedMatch = !matches.call( document.createElement( <span class="string">"div"</span> ), <span class="string">"div"</span> ),
			pseudoWorks = <span class="literal">false</span>;

		<span class="keyword">try</span> {
			<span class="comment">// This should fail with an exception</span>
			<span class="comment">// Gecko does not error, returns false instead</span>
			matches.call( document.documentElement, <span class="string">"[test!='']:sizzle"</span> );

		} <span class="keyword">catch</span>( pseudoError ) {
			pseudoWorks = <span class="literal">true</span>;
		}

		Sizzle.matchesSelector = <span class="keyword">function</span>( node, expr ) {
			<span class="comment">// Make sure that attribute selectors are quoted</span>
			expr = expr.replace(<span class="regexp">/\=\s*([^'"\]]*)\s*\]/g</span>, <span class="string">"='$1']"</span>);

			<span class="keyword">if</span> ( !Sizzle.isXML( node ) ) {
				<span class="keyword">try</span> {
					<span class="keyword">if</span> ( pseudoWorks || !Expr.match.PSEUDO.test( expr ) &amp;&amp; !<span class="regexp">/!=/</span>.test( expr ) ) {
						<span class="keyword">var</span> ret = matches.call( node, expr );

						<span class="comment">// IE 9's matchesSelector returns false on disconnected nodes</span>
						<span class="keyword">if</span> ( ret || !disconnectedMatch ||
								<span class="comment">// As well, disconnected nodes are said to be in a document</span>
								<span class="comment">// fragment in IE 9, so check for that</span>
								node.document &amp;&amp; node.document.nodeType !== <span class="number">11</span> ) {
							<span class="keyword">return</span> ret;
						}
					}
				} <span class="keyword">catch</span>(e) {}
			}

			<span class="keyword">return</span> Sizzle(expr, <span class="literal">null</span>, <span class="literal">null</span>, [node]).length > <span class="number">0</span>;
		};
	}
})();

(<span class="keyword">function</span>(){
	<span class="keyword">var</span> div = document.createElement(<span class="string">"div"</span>);

	div.innerHTML = <span class="string">"&lt;div class='test e'>&lt;/div>&lt;div class='test'>&lt;/div>"</span>;

	<span class="comment">// Opera can't find a second classname (in 9.6)</span>
	<span class="comment">// Also, make sure that getElementsByClassName actually exists</span>
	<span class="keyword">if</span> ( !div.getElementsByClassName || div.getElementsByClassName(<span class="string">"e"</span>).length === <span class="number">0</span> ) {
		<span class="keyword">return</span>;
	}

	<span class="comment">// Safari caches class attributes, doesn't catch changes (in 3.2)</span>
	div.lastChild.className = <span class="string">"e"</span>;

	<span class="keyword">if</span> ( div.getElementsByClassName(<span class="string">"e"</span>).length === <span class="number">1</span> ) {
		<span class="keyword">return</span>;
	}

	Expr.order.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="string">"CLASS"</span>);
	Expr.find.CLASS = <span class="keyword">function</span>( match, context, isXML ) {
		<span class="keyword">if</span> ( <span class="keyword">typeof</span> context.getElementsByClassName !== <span class="string">"undefined"</span> &amp;&amp; !isXML ) {
			<span class="keyword">return</span> context.getElementsByClassName(match[<span class="number">1</span>]);
		}
	};

	<span class="comment">// release memory in IE</span>
	div = <span class="literal">null</span>;
})();

<span class="function"><span class="keyword">function</span> <span class="title">dirNodeCheck</span><span class="params">( dir, cur, doneName, checkSet, nodeCheck, isXML )</span> {</span>
	<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, l = checkSet.length; i &lt; l; i++ ) {
		<span class="keyword">var</span> elem = checkSet[i];

		<span class="keyword">if</span> ( elem ) {
			<span class="keyword">var</span> match = <span class="literal">false</span>;

			elem = elem[dir];

			<span class="keyword">while</span> ( elem ) {
				<span class="keyword">if</span> ( elem[ expando ] === doneName ) {
					match = checkSet[elem.sizset];
					<span class="keyword">break</span>;
				}

				<span class="keyword">if</span> ( elem.nodeType === <span class="number">1</span> &amp;&amp; !isXML ){
					elem[ expando ] = doneName;
					elem.sizset = i;
				}

				<span class="keyword">if</span> ( elem.nodeName.toLowerCase() === cur ) {
					match = elem;
					<span class="keyword">break</span>;
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

<span class="function"><span class="keyword">function</span> <span class="title">dirCheck</span><span class="params">( dir, cur, doneName, checkSet, nodeCheck, isXML )</span> {</span>
	<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, l = checkSet.length; i &lt; l; i++ ) {
		<span class="keyword">var</span> elem = checkSet[i];

		<span class="keyword">if</span> ( elem ) {
			<span class="keyword">var</span> match = <span class="literal">false</span>;

			elem = elem[dir];

			<span class="keyword">while</span> ( elem ) {
				<span class="keyword">if</span> ( elem[ expando ] === doneName ) {
					match = checkSet[elem.sizset];
					<span class="keyword">break</span>;
				}

				<span class="keyword">if</span> ( elem.nodeType === <span class="number">1</span> ) {
					<span class="keyword">if</span> ( !isXML ) {
						elem[ expando ] = doneName;
						elem.sizset = i;
					}

					<span class="keyword">if</span> ( <span class="keyword">typeof</span> cur !== <span class="string">"string"</span> ) {
						<span class="keyword">if</span> ( elem === cur ) {
							match = <span class="literal">true</span>;
							<span class="keyword">break</span>;
						}

					} <span class="keyword">else</span> <span class="keyword">if</span> ( Sizzle.filter( cur, [elem] ).length > <span class="number">0</span> ) {
						match = elem;
						<span class="keyword">break</span>;
					}
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

<span class="keyword">if</span> ( document.documentElement.contains ) {
	Sizzle.contains = <span class="keyword">function</span>( a, b ) {
		<span class="keyword">return</span> a !== b &amp;&amp; (a.contains ? a.contains(b) : <span class="literal">true</span>);
	};

} <span class="keyword">else</span> <span class="keyword">if</span> ( document.documentElement.compareDocumentPosition ) {
	Sizzle.contains = <span class="keyword">function</span>( a, b ) {
		<span class="keyword">return</span> !!(a.compareDocumentPosition(b) &amp; <span class="number">16</span>);
	};

} <span class="keyword">else</span> {
	Sizzle.contains = <span class="keyword">function</span>() {
		<span class="keyword">return</span> <span class="literal">false</span>;
	};
}

Sizzle.isXML = <span class="keyword">function</span>( elem ) {
	<span class="comment">// documentElement is verified for cases where it doesn't yet exist</span>
	<span class="comment">// (such as loading iframes in IE - #4833)</span>
	<span class="keyword">var</span> documentElement = (elem ? elem.ownerDocument || elem : <span class="number">0</span>).documentElement;

	<span class="keyword">return</span> documentElement ? documentElement.nodeName !== <span class="string">"HTML"</span> : <span class="literal">false</span>;
};

<span class="keyword">var</span> posProcess = <span class="keyword">function</span>( selector, context, seed ) {
	<span class="keyword">var</span> match,
		tmpSet = [],
		later = <span class="string">""</span>,
		root = context.nodeType ? [context] : context;

	<span class="comment">// Position selectors must be done after the filter</span>
	<span class="comment">// And so must :not(positional) so we move all PSEUDOs to the end</span>
	<span class="keyword">while</span> ( (match = Expr.match.PSEUDO.exec( selector )) ) {
		later += match[<span class="number">0</span>];
		selector = selector.replace( Expr.match.PSEUDO, <span class="string">""</span> );
	}

	selector = Expr.relative[selector] ? selector + <span class="string">"*"</span> : selector;

	<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, l = root.length; i &lt; l; i++ ) {
		Sizzle( selector, root[i], tmpSet, seed );
	}

	<span class="keyword">return</span> Sizzle.filter( later, tmpSet );
};

<span class="comment">// EXPOSE</span>

<span class="keyword">if</span> (<span class="keyword">typeof</span> module !== <span class="string">'undefined'</span> &amp;&amp; module.exports) {
  module.exports = Sizzle;
} <span class="keyword">else</span> {
  window.Sizzle = Sizzle;
}

})();
</code></pre>